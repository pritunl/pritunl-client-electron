/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 181:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
/* unused reexport */ __webpack_require__(6991)/* .SourceMapGenerator */ .x;
exports.SourceMapConsumer = __webpack_require__(8272).SourceMapConsumer;
/* unused reexport */ __webpack_require__(8537);


/***/ }),

/***/ 287:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fL: () => (/* binding */ pascalCase)
/* harmony export */ });
/* unused harmony exports pascalCaseTransform, pascalCaseTransformMerge */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1635);
/* harmony import */ var no_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3780);


function pascalCaseTransform(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCaseTransformMerge(input) {
    return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
}
function pascalCase(input, options) {
    if (options === void 0) { options = {}; }
    return (0,no_case__WEBPACK_IMPORTED_MODULE_0__/* .noCase */ .W)(input, (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__assign */ .Cl)({ delimiter: "", transform: pascalCaseTransform }, options));
}


/***/ }),

/***/ 314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// unix absolute paths are also absolute on win32, so we use this for both
const { isAbsolute, parse } = (__webpack_require__(6928).win32)

// returns [root, stripped]
// Note that windows will think that //x/y/z/a has a "root" of //x/y, and in
// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /
// explicitly if it's the first character.
// drive-specific relative paths on Windows get their root stripped off even
// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']
module.exports = path => {
  let r = ''

  let parsed = parse(path)
  while (isAbsolute(path) || parsed.root) {
    // windows will think that //x/y/z has a "root" of //x/y/
    // but strip the //?/C:/ off of //?/C:/path
    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'
      : parsed.root
    path = path.slice(root.length)
    r += root
    parsed = parse(path)
  }
  return [r, path]
}


/***/ }),

/***/ 422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(8477);
} else {}


/***/ }),

/***/ 472:
/***/ ((module) => {

"use strict";

module.exports = Base => class extends Base {
  warn (code, message, data = {}) {
    if (this.file) {
      data.file = this.file
    }
    if (this.cwd) {
      data.cwd = this.cwd
    }
    data.code = message instanceof Error && message.code || code
    data.tarCode = code
    if (!this.strict && data.recoverable !== false) {
      if (message instanceof Error) {
        data = Object.assign(message, data)
        message = message.message
      }
      this.emit('warn', data.tarCode, message, data)
    } else if (message instanceof Error) {
      this.emit('error', Object.assign(message, data))
    } else {
      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))
    }
  }
}


/***/ }),

/***/ 772:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ IconSize)
/* harmony export */ });
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IconSize;
(function (IconSize) {
    IconSize[IconSize["STANDARD"] = 16] = "STANDARD";
    IconSize[IconSize["LARGE"] = 20] = "LARGE";
})(IconSize || (IconSize = {}));


/***/ }),

/***/ 877:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// parse a 512-byte header block to a data object, or vice-versa
// encode returns `true` if a pax extended header is needed, because
// the data could not be faithfully encoded in a simple header.
// (Also, check header.needPax to see if it needs a pax header.)

const types = __webpack_require__(6543)
const pathModule = (__webpack_require__(6928).posix)
const large = __webpack_require__(4318)

const SLURP = Symbol('slurp')
const TYPE = Symbol('type')

class Header {
  constructor (data, off, ex, gex) {
    this.cksumValid = false
    this.needPax = false
    this.nullBlock = false

    this.block = null
    this.path = null
    this.mode = null
    this.uid = null
    this.gid = null
    this.size = null
    this.mtime = null
    this.cksum = null
    this[TYPE] = '0'
    this.linkpath = null
    this.uname = null
    this.gname = null
    this.devmaj = 0
    this.devmin = 0
    this.atime = null
    this.ctime = null

    if (Buffer.isBuffer(data)) {
      this.decode(data, off || 0, ex, gex)
    } else if (data) {
      this.set(data)
    }
  }

  decode (buf, off, ex, gex) {
    if (!off) {
      off = 0
    }

    if (!buf || !(buf.length >= off + 512)) {
      throw new Error('need 512 bytes for header')
    }

    this.path = decString(buf, off, 100)
    this.mode = decNumber(buf, off + 100, 8)
    this.uid = decNumber(buf, off + 108, 8)
    this.gid = decNumber(buf, off + 116, 8)
    this.size = decNumber(buf, off + 124, 12)
    this.mtime = decDate(buf, off + 136, 12)
    this.cksum = decNumber(buf, off + 148, 12)

    // if we have extended or global extended headers, apply them now
    // See https://github.com/npm/node-tar/pull/187
    this[SLURP](ex)
    this[SLURP](gex, true)

    // old tar versions marked dirs as a file with a trailing /
    this[TYPE] = decString(buf, off + 156, 1)
    if (this[TYPE] === '') {
      this[TYPE] = '0'
    }
    if (this[TYPE] === '0' && this.path.slice(-1) === '/') {
      this[TYPE] = '5'
    }

    // tar implementations sometimes incorrectly put the stat(dir).size
    // as the size in the tarball, even though Directory entries are
    // not able to have any body at all.  In the very rare chance that
    // it actually DOES have a body, we weren't going to do anything with
    // it anyway, and it'll just be a warning about an invalid header.
    if (this[TYPE] === '5') {
      this.size = 0
    }

    this.linkpath = decString(buf, off + 157, 100)
    if (buf.slice(off + 257, off + 265).toString() === 'ustar\u000000') {
      this.uname = decString(buf, off + 265, 32)
      this.gname = decString(buf, off + 297, 32)
      this.devmaj = decNumber(buf, off + 329, 8)
      this.devmin = decNumber(buf, off + 337, 8)
      if (buf[off + 475] !== 0) {
        // definitely a prefix, definitely >130 chars.
        const prefix = decString(buf, off + 345, 155)
        this.path = prefix + '/' + this.path
      } else {
        const prefix = decString(buf, off + 345, 130)
        if (prefix) {
          this.path = prefix + '/' + this.path
        }
        this.atime = decDate(buf, off + 476, 12)
        this.ctime = decDate(buf, off + 488, 12)
      }
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }

    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }

    this.cksumValid = sum === this.cksum
    if (this.cksum === null && sum === 8 * 0x20) {
      this.nullBlock = true
    }
  }

  [SLURP] (ex, global) {
    for (const k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path')) {
        this[k] = ex[k]
      }
    }
  }

  encode (buf, off) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512)
      off = 0
    }

    if (!off) {
      off = 0
    }

    if (!(buf.length >= off + 512)) {
      throw new Error('need 512 bytes for header')
    }

    const prefixSize = this.ctime || this.atime ? 130 : 155
    const split = splitPrefix(this.path || '', prefixSize)
    const path = split[0]
    const prefix = split[1]
    this.needPax = split[2]

    this.needPax = encString(buf, off, 100, path) || this.needPax
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax
    buf[off + 156] = this[TYPE].charCodeAt(0)
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax
    buf.write('ustar\u000000', off + 257, 8)
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax
    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax
    if (buf[off + 475] !== 0) {
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax
    } else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }

    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }

    this.cksum = sum
    encNumber(buf, off + 148, 8, this.cksum)
    this.cksumValid = true

    return this.needPax
  }

  set (data) {
    for (const i in data) {
      if (data[i] !== null && data[i] !== undefined) {
        this[i] = data[i]
      }
    }
  }

  get type () {
    return types.name.get(this[TYPE]) || this[TYPE]
  }

  get typeKey () {
    return this[TYPE]
  }

  set type (type) {
    if (types.code.has(type)) {
      this[TYPE] = types.code.get(type)
    } else {
      this[TYPE] = type
    }
  }
}

const splitPrefix = (p, prefixSize) => {
  const pathSize = 100
  let pp = p
  let prefix = ''
  let ret
  const root = pathModule.parse(p).root || '.'

  if (Buffer.byteLength(pp) < pathSize) {
    ret = [pp, prefix, false]
  } else {
    // first set prefix to the dir, and path to the base
    prefix = pathModule.dirname(pp)
    pp = pathModule.basename(pp)

    do {
      if (Buffer.byteLength(pp) <= pathSize &&
          Buffer.byteLength(prefix) <= prefixSize) {
        // both fit!
        ret = [pp, prefix, false]
      } else if (Buffer.byteLength(pp) > pathSize &&
          Buffer.byteLength(prefix) <= prefixSize) {
        // prefix fits in prefix, but path doesn't fit in path
        ret = [pp.slice(0, pathSize - 1), prefix, true]
      } else {
        // make path take a bit from prefix
        pp = pathModule.join(pathModule.basename(prefix), pp)
        prefix = pathModule.dirname(prefix)
      }
    } while (prefix !== root && !ret)

    // at this point, found no resolution, just truncate
    if (!ret) {
      ret = [p.slice(0, pathSize - 1), '', true]
    }
  }
  return ret
}

const decString = (buf, off, size) =>
  buf.slice(off, off + size).toString('utf8').replace(/\0.*/, '')

const decDate = (buf, off, size) =>
  numToDate(decNumber(buf, off, size))

const numToDate = num => num === null ? null : new Date(num * 1000)

const decNumber = (buf, off, size) =>
  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))
  : decSmallNumber(buf, off, size)

const nanNull = value => isNaN(value) ? null : value

const decSmallNumber = (buf, off, size) =>
  nanNull(parseInt(
    buf.slice(off, off + size)
      .toString('utf8').replace(/\0.*$/, '').trim(), 8))

// the maximum encodable as a null-terminated octal, by field size
const MAXNUM = {
  12: 0o77777777777,
  8: 0o7777777,
}

const encNumber = (buf, off, size, number) =>
  number === null ? false :
  number > MAXNUM[size] || number < 0
    ? (large.encode(number, buf.slice(off, off + size)), true)
    : (encSmallNumber(buf, off, size, number), false)

const encSmallNumber = (buf, off, size, number) =>
  buf.write(octalString(number, size), off, size, 'ascii')

const octalString = (number, size) =>
  padOctal(Math.floor(number).toString(8), size)

const padOctal = (string, size) =>
  (string.length === size - 1 ? string
  : new Array(size - string.length - 1).join('0') + string + ' ') + '\0'

const encDate = (buf, off, size, date) =>
  date === null ? false :
  encNumber(buf, off, size, date.getTime() / 1000)

// enough to fill the longest string we've got
const NULLS = new Array(156).join('\0')
// pad with nulls, return true if it's longer or non-ascii
const encString = (buf, off, size, string) =>
  string === null ? false :
  (buf.write(string + NULLS, off, size, 'utf8'),
  string.length !== Buffer.byteLength(string) || string.length > size)

module.exports = Header


/***/ }),

/***/ 932:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 1613:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}
function J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;
function M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if("function"===typeof F)S=function(){F(R)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}
exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};
exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};
exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};
exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};


/***/ }),

/***/ 1621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -u

const hlo = __webpack_require__(1743)
const r = __webpack_require__(7150)
// just call tar.r with the filter and mtimeCache

module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file) {
    throw new TypeError('file is required')
  }

  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {
    throw new TypeError('cannot append to compressed archives')
  }

  if (!files || !Array.isArray(files) || !files.length) {
    throw new TypeError('no files or directories specified')
  }

  files = Array.from(files)

  mtimeFilter(opt)
  return r(opt, files, cb)
}

const mtimeFilter = opt => {
  const filter = opt.filter

  if (!opt.mtimeCache) {
    opt.mtimeCache = new Map()
  }

  opt.filter = filter ? (path, stat) =>
    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)
    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)
}


/***/ }),

/***/ 1635:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C6: () => (/* binding */ __extends),
/* harmony export */   Cl: () => (/* binding */ __assign),
/* harmony export */   Tt: () => (/* binding */ __rest),
/* harmony export */   YH: () => (/* binding */ __generator),
/* harmony export */   fX: () => (/* binding */ __spreadArray),
/* harmony export */   sH: () => (/* binding */ __awaiter)
/* harmony export */ });
/* unused harmony exports __decorate, __param, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn, __addDisposableResource, __disposeResources */
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ }),

/***/ 1697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(9896)
const path = __webpack_require__(6928)

/* istanbul ignore next */
const LCHOWN = fs.lchown ? 'lchown' : 'chown'
/* istanbul ignore next */
const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'

/* istanbul ignore next */
const needEISDIRHandled = fs.lchown &&
  !process.version.match(/v1[1-9]+\./) &&
  !process.version.match(/v10\.[6-9]/)

const lchownSync = (path, uid, gid) => {
  try {
    return fs[LCHOWNSYNC](path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const chownSync = (path, uid, gid) => {
  try {
    return fs.chownSync(path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const handleEISDIR =
  needEISDIRHandled ? (path, uid, gid, cb) => er => {
    // Node prior to v10 had a very questionable implementation of
    // fs.lchown, which would always try to call fs.open on a directory
    // Fall back to fs.chown in those cases.
    if (!er || er.code !== 'EISDIR')
      cb(er)
    else
      fs.chown(path, uid, gid, cb)
  }
  : (_, __, ___, cb) => cb

/* istanbul ignore next */
const handleEISDirSync =
  needEISDIRHandled ? (path, uid, gid) => {
    try {
      return lchownSync(path, uid, gid)
    } catch (er) {
      if (er.code !== 'EISDIR')
        throw er
      chownSync(path, uid, gid)
    }
  }
  : (path, uid, gid) => lchownSync(path, uid, gid)

// fs.readdir could only accept an options object as of node v6
const nodeVersion = process.version
let readdir = (path, options, cb) => fs.readdir(path, options, cb)
let readdirSync = (path, options) => fs.readdirSync(path, options)
/* istanbul ignore next */
if (/^v4\./.test(nodeVersion))
  readdir = (path, options, cb) => fs.readdir(path, cb)

const chown = (cpath, uid, gid, cb) => {
  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    // Skip ENOENT error
    cb(er && er.code !== 'ENOENT' ? er : null)
  }))
}

const chownrKid = (p, child, uid, gid, cb) => {
  if (typeof child === 'string')
    return fs.lstat(path.resolve(p, child), (er, stats) => {
      // Skip ENOENT error
      if (er)
        return cb(er.code !== 'ENOENT' ? er : null)
      stats.name = child
      chownrKid(p, stats, uid, gid, cb)
    })

  if (child.isDirectory()) {
    chownr(path.resolve(p, child.name), uid, gid, er => {
      if (er)
        return cb(er)
      const cpath = path.resolve(p, child.name)
      chown(cpath, uid, gid, cb)
    })
  } else {
    const cpath = path.resolve(p, child.name)
    chown(cpath, uid, gid, cb)
  }
}


const chownr = (p, uid, gid, cb) => {
  readdir(p, { withFileTypes: true }, (er, children) => {
    // any error other than ENOTDIR or ENOTSUP means it's not readable,
    // or doesn't exist.  give up.
    if (er) {
      if (er.code === 'ENOENT')
        return cb()
      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')
        return cb(er)
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb)

    let len = children.length
    let errState = null
    const then = er => {
      if (errState)
        return
      if (er)
        return cb(errState = er)
      if (-- len === 0)
        return chown(p, uid, gid, cb)
    }

    children.forEach(child => chownrKid(p, child, uid, gid, then))
  })
}

const chownrKidSync = (p, child, uid, gid) => {
  if (typeof child === 'string') {
    try {
      const stats = fs.lstatSync(path.resolve(p, child))
      stats.name = child
      child = stats
    } catch (er) {
      if (er.code === 'ENOENT')
        return
      else
        throw er
    }
  }

  if (child.isDirectory())
    chownrSync(path.resolve(p, child.name), uid, gid)

  handleEISDirSync(path.resolve(p, child.name), uid, gid)
}

const chownrSync = (p, uid, gid) => {
  let children
  try {
    children = readdirSync(p, { withFileTypes: true })
  } catch (er) {
    if (er.code === 'ENOENT')
      return
    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')
      return handleEISDirSync(p, uid, gid)
    else
      throw er
  }

  if (children && children.length)
    children.forEach(child => chownrKidSync(p, child, uid, gid))

  return handleEISDirSync(p, uid, gid)
}

module.exports = chownr
chownr.sync = chownrSync


/***/ }),

/***/ 1743:
/***/ ((module) => {

"use strict";


// turn tar(1) style args like `C` into the more verbose things like `cwd`

const argmap = new Map([
  ['C', 'cwd'],
  ['f', 'file'],
  ['z', 'gzip'],
  ['P', 'preservePaths'],
  ['U', 'unlink'],
  ['strip-components', 'strip'],
  ['stripComponents', 'strip'],
  ['keep-newer', 'newer'],
  ['keepNewer', 'newer'],
  ['keep-newer-files', 'newer'],
  ['keepNewerFiles', 'newer'],
  ['k', 'keep'],
  ['keep-existing', 'keep'],
  ['keepExisting', 'keep'],
  ['m', 'noMtime'],
  ['no-mtime', 'noMtime'],
  ['p', 'preserveOwner'],
  ['L', 'follow'],
  ['h', 'follow'],
])

module.exports = opt => opt ? Object.keys(opt).map(k => [
  argmap.has(k) ? argmap.get(k) : k, opt[k],
]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}


/***/ }),

/***/ 1793:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
class ArraySet {
  constructor() {
    this._array = [];
    this._set = new Map();
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  static fromArray(aArray, aAllowDuplicates) {
    const set = new ArraySet();
    for (let i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  }

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  size() {
    return this._set.size;
  }

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  add(aStr, aAllowDuplicates) {
    const isDuplicate = this.has(aStr);
    const idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set.set(aStr, idx);
    }
  }

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  has(aStr) {
      return this._set.has(aStr);
  }

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  indexOf(aStr) {
    const idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  }

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  toArray() {
    return this._array.slice();
  }
}
exports.C = ArraySet;


/***/ }),

/***/ 1857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(2613)
const Buffer = (__webpack_require__(181).Buffer)
const realZlib = __webpack_require__(3106)

const constants = exports.constants = __webpack_require__(7880)
const Minipass = __webpack_require__(4211)

const OriginalBufferConcat = Buffer.concat

const _superWrite = Symbol('_superWrite')
class ZlibError extends Error {
  constructor (err) {
    super('zlib: ' + err.message)
    this.code = err.code
    this.errno = err.errno
    /* istanbul ignore if */
    if (!this.code)
      this.code = 'ZLIB_ERROR'

    this.message = 'zlib: ' + err.message
    Error.captureStackTrace(this, this.constructor)
  }

  get name () {
    return 'ZlibError'
  }
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _opts = Symbol('opts')
const _flushFlag = Symbol('flushFlag')
const _finishFlushFlag = Symbol('finishFlushFlag')
const _fullFlushFlag = Symbol('fullFlushFlag')
const _handle = Symbol('handle')
const _onError = Symbol('onError')
const _sawError = Symbol('sawError')
const _level = Symbol('level')
const _strategy = Symbol('strategy')
const _ended = Symbol('ended')
const _defaultFullFlush = Symbol('_defaultFullFlush')

class ZlibBase extends Minipass {
  constructor (opts, mode) {
    if (!opts || typeof opts !== 'object')
      throw new TypeError('invalid options for ZlibBase constructor')

    super(opts)
    this[_sawError] = false
    this[_ended] = false
    this[_opts] = opts

    this[_flushFlag] = opts.flush
    this[_finishFlushFlag] = opts.finishFlush
    // this will throw if any options are invalid for the class selected
    try {
      this[_handle] = new realZlib[mode](opts)
    } catch (er) {
      // make sure that all errors get decorated properly
      throw new ZlibError(er)
    }

    this[_onError] = (err) => {
      // no sense raising multiple errors, since we abort on the first one.
      if (this[_sawError])
        return

      this[_sawError] = true

      // there is no way to cleanly recover.
      // continuing only obscures problems.
      this.close()
      this.emit('error', err)
    }

    this[_handle].on('error', er => this[_onError](new ZlibError(er)))
    this.once('end', () => this.close)
  }

  close () {
    if (this[_handle]) {
      this[_handle].close()
      this[_handle] = null
      this.emit('close')
    }
  }

  reset () {
    if (!this[_sawError]) {
      assert(this[_handle], 'zlib binding closed')
      return this[_handle].reset()
    }
  }

  flush (flushFlag) {
    if (this.ended)
      return

    if (typeof flushFlag !== 'number')
      flushFlag = this[_fullFlushFlag]
    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))
  }

  end (chunk, encoding, cb) {
    if (chunk)
      this.write(chunk, encoding)
    this.flush(this[_finishFlushFlag])
    this[_ended] = true
    return super.end(null, null, cb)
  }

  get ended () {
    return this[_ended]
  }

  write (chunk, encoding, cb) {
    // process the chunk using the sync process
    // then super.write() all the outputted chunks
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (typeof chunk === 'string')
      chunk = Buffer.from(chunk, encoding)

    if (this[_sawError])
      return
    assert(this[_handle], 'zlib binding closed')

    // _processChunk tries to .close() the native handle after it's done, so we
    // intercept that by temporarily making it a no-op.
    const nativeHandle = this[_handle]._handle
    const originalNativeClose = nativeHandle.close
    nativeHandle.close = () => {}
    const originalClose = this[_handle].close
    this[_handle].close = () => {}
    // It also calls `Buffer.concat()` at the end, which may be convenient
    // for some, but which we are not interested in as it slows us down.
    Buffer.concat = (args) => args
    let result
    try {
      const flushFlag = typeof chunk[_flushFlag] === 'number'
        ? chunk[_flushFlag] : this[_flushFlag]
      result = this[_handle]._processChunk(chunk, flushFlag)
      // if we don't throw, reset it back how it was
      Buffer.concat = OriginalBufferConcat
    } catch (err) {
      // or if we do, put Buffer.concat() back before we emit error
      // Error events call into user code, which may call Buffer.concat()
      Buffer.concat = OriginalBufferConcat
      this[_onError](new ZlibError(err))
    } finally {
      if (this[_handle]) {
        // Core zlib resets `_handle` to null after attempting to close the
        // native handle. Our no-op handler prevented actual closure, but we
        // need to restore the `._handle` property.
        this[_handle]._handle = nativeHandle
        nativeHandle.close = originalNativeClose
        this[_handle].close = originalClose
        // `_processChunk()` adds an 'error' listener. If we don't remove it
        // after each call, these handlers start piling up.
        this[_handle].removeAllListeners('error')
        // make sure OUR error listener is still attached tho
      }
    }

    if (this[_handle])
      this[_handle].on('error', er => this[_onError](new ZlibError(er)))

    let writeReturn
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        // The first buffer is always `handle._outBuffer`, which would be
        // re-used for later invocations; so, we always have to copy that one.
        writeReturn = this[_superWrite](Buffer.from(result[0]))
        for (let i = 1; i < result.length; i++) {
          writeReturn = this[_superWrite](result[i])
        }
      } else {
        writeReturn = this[_superWrite](Buffer.from(result))
      }
    }

    if (cb)
      cb()
    return writeReturn
  }

  [_superWrite] (data) {
    return super.write(data)
  }
}

class Zlib extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.Z_NO_FLUSH
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH
    super(opts, mode)

    this[_fullFlushFlag] = constants.Z_FULL_FLUSH
    this[_level] = opts.level
    this[_strategy] = opts.strategy
  }

  params (level, strategy) {
    if (this[_sawError])
      return

    if (!this[_handle])
      throw new Error('cannot switch params when binding is closed')

    // no way to test this without also not supporting params at all
    /* istanbul ignore if */
    if (!this[_handle].params)
      throw new Error('not supported in this implementation')

    if (this[_level] !== level || this[_strategy] !== strategy) {
      this.flush(constants.Z_SYNC_FLUSH)
      assert(this[_handle], 'zlib binding closed')
      // .params() calls .flush(), but the latter is always async in the
      // core zlib. We override .flush() temporarily to intercept that and
      // flush synchronously.
      const origFlush = this[_handle].flush
      this[_handle].flush = (flushFlag, cb) => {
        this.flush(flushFlag)
        cb()
      }
      try {
        this[_handle].params(level, strategy)
      } finally {
        this[_handle].flush = origFlush
      }
      /* istanbul ignore else */
      if (this[_handle]) {
        this[_level] = level
        this[_strategy] = strategy
      }
    }
  }
}

// minimal 2-byte header
class Deflate extends Zlib {
  constructor (opts) {
    super(opts, 'Deflate')
  }
}

class Inflate extends Zlib {
  constructor (opts) {
    super(opts, 'Inflate')
  }
}

// gzip - bigger header, same deflate compression
const _portable = Symbol('_portable')
class Gzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gzip')
    this[_portable] = opts && !!opts.portable
  }

  [_superWrite] (data) {
    if (!this[_portable])
      return super[_superWrite](data)

    // we'll always get the header emitted in one first chunk
    // overwrite the OS indicator byte with 0xFF
    this[_portable] = false
    data[9] = 255
    return super[_superWrite](data)
  }
}

class Gunzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gunzip')
  }
}

// raw - no header
class DeflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'DeflateRaw')
  }
}

class InflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'InflateRaw')
  }
}

// auto-detect header.
class Unzip extends Zlib {
  constructor (opts) {
    super(opts, 'Unzip')
  }
}

class Brotli extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH

    super(opts, mode)

    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH
  }
}

class BrotliCompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliCompress')
  }
}

class BrotliDecompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliDecompress')
  }
}

exports.Deflate = Deflate
exports.Inflate = Inflate
exports.Gzip = Gzip
exports.Gunzip = Gunzip
exports.DeflateRaw = DeflateRaw
exports.InflateRaw = InflateRaw
exports.Unzip = Unzip
/* istanbul ignore else */
if (typeof realZlib.BrotliCompress === 'function') {
  exports.BrotliCompress = BrotliCompress
  exports.BrotliDecompress = BrotliDecompress
} else {
  exports.BrotliCompress = exports.BrotliDecompress = class {
    constructor () {
      throw new Error('Brotli is not supported in this version of Node.js')
    }
  }
}


/***/ }),

/***/ 1996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Minipass } = __webpack_require__(5904)
const Pax = __webpack_require__(8087)
const Header = __webpack_require__(877)
const fs = __webpack_require__(9896)
const path = __webpack_require__(6928)
const normPath = __webpack_require__(3373)
const stripSlash = __webpack_require__(8725)

const prefixPath = (path, prefix) => {
  if (!prefix) {
    return normPath(path)
  }
  path = normPath(path).replace(/^\.(\/|$)/, '')
  return stripSlash(prefix) + '/' + path
}

const maxReadSize = 16 * 1024 * 1024
const PROCESS = Symbol('process')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const HEADER = Symbol('header')
const READ = Symbol('read')
const LSTAT = Symbol('lstat')
const ONLSTAT = Symbol('onlstat')
const ONREAD = Symbol('onread')
const ONREADLINK = Symbol('onreadlink')
const OPENFILE = Symbol('openfile')
const ONOPENFILE = Symbol('onopenfile')
const CLOSE = Symbol('close')
const MODE = Symbol('mode')
const AWAITDRAIN = Symbol('awaitDrain')
const ONDRAIN = Symbol('ondrain')
const PREFIX = Symbol('prefix')
const HAD_ERROR = Symbol('hadError')
const warner = __webpack_require__(472)
const winchars = __webpack_require__(8567)
const stripAbsolutePath = __webpack_require__(314)

const modeFix = __webpack_require__(6425)

const WriteEntry = warner(class WriteEntry extends Minipass {
  constructor (p, opt) {
    opt = opt || {}
    super(opt)
    if (typeof p !== 'string') {
      throw new TypeError('path is required')
    }
    this.path = normPath(p)
    // suppress atime, ctime, uid, gid, uname, gname
    this.portable = !!opt.portable
    // until node has builtin pwnam functions, this'll have to do
    this.myuid = process.getuid && process.getuid() || 0
    this.myuser = {}.USER || ''
    this.maxReadSize = opt.maxReadSize || maxReadSize
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.preservePaths = !!opt.preservePaths
    this.cwd = normPath(opt.cwd || process.cwd())
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null
    this.prefix = opt.prefix ? normPath(opt.prefix) : null

    this.fd = null
    this.blockLen = null
    this.blockRemain = null
    this.buf = null
    this.offset = null
    this.length = null
    this.pos = null
    this.remain = null

    if (typeof opt.onwarn === 'function') {
      this.on('warn', opt.onwarn)
    }

    let pathWarn = false
    if (!this.preservePaths) {
      const [root, stripped] = stripAbsolutePath(this.path)
      if (root) {
        this.path = stripped
        pathWarn = root
      }
    }

    this.win32 = !!opt.win32 || process.platform === 'win32'
    if (this.win32) {
      // force the \ to / normalization, since we might not *actually*
      // be on windows, but want \ to be considered a path separator.
      this.path = winchars.decode(this.path.replace(/\\/g, '/'))
      p = p.replace(/\\/g, '/')
    }

    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))

    if (this.path === '') {
      this.path = './'
    }

    if (pathWarn) {
      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path,
      })
    }

    if (this.statCache.has(this.absolute)) {
      this[ONLSTAT](this.statCache.get(this.absolute))
    } else {
      this[LSTAT]()
    }
  }

  emit (ev, ...data) {
    if (ev === 'error') {
      this[HAD_ERROR] = true
    }
    return super.emit(ev, ...data)
  }

  [LSTAT] () {
    fs.lstat(this.absolute, (er, stat) => {
      if (er) {
        return this.emit('error', er)
      }
      this[ONLSTAT](stat)
    })
  }

  [ONLSTAT] (stat) {
    this.statCache.set(this.absolute, stat)
    this.stat = stat
    if (!stat.isFile()) {
      stat.size = 0
    }
    this.type = getType(stat)
    this.emit('stat', stat)
    this[PROCESS]()
  }

  [PROCESS] () {
    switch (this.type) {
      case 'File': return this[FILE]()
      case 'Directory': return this[DIRECTORY]()
      case 'SymbolicLink': return this[SYMLINK]()
      // unsupported types are ignored.
      default: return this.end()
    }
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory', this.portable)
  }

  [PREFIX] (path) {
    return prefixPath(path, this.prefix)
  }

  [HEADER] () {
    if (this.type === 'Directory' && this.portable) {
      this.noMtime = true
    }

    this.header = new Header({
      path: this[PREFIX](this.path),
      // only apply the prefix to hard links.
      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
      : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? null : this.stat.uid,
      gid: this.portable ? null : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
      type: this.type,
      uname: this.portable ? null :
      this.stat.uid === this.myuid ? this.myuser : '',
      atime: this.portable ? null : this.stat.atime,
      ctime: this.portable ? null : this.stat.ctime,
    })

    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
        : this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink,
      }).encode())
    }
    super.write(this.header.block)
  }

  [DIRECTORY] () {
    if (this.path.slice(-1) !== '/') {
      this.path += '/'
    }
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [SYMLINK] () {
    fs.readlink(this.absolute, (er, linkpath) => {
      if (er) {
        return this.emit('error', er)
      }
      this[ONREADLINK](linkpath)
    })
  }

  [ONREADLINK] (linkpath) {
    this.linkpath = normPath(linkpath)
    this[HEADER]()
    this.end()
  }

  [HARDLINK] (linkpath) {
    this.type = 'Link'
    this.linkpath = normPath(path.relative(this.cwd, linkpath))
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [FILE] () {
    if (this.stat.nlink > 1) {
      const linkKey = this.stat.dev + ':' + this.stat.ino
      if (this.linkCache.has(linkKey)) {
        const linkpath = this.linkCache.get(linkKey)
        if (linkpath.indexOf(this.cwd) === 0) {
          return this[HARDLINK](linkpath)
        }
      }
      this.linkCache.set(linkKey, this.absolute)
    }

    this[HEADER]()
    if (this.stat.size === 0) {
      return this.end()
    }

    this[OPENFILE]()
  }

  [OPENFILE] () {
    fs.open(this.absolute, 'r', (er, fd) => {
      if (er) {
        return this.emit('error', er)
      }
      this[ONOPENFILE](fd)
    })
  }

  [ONOPENFILE] (fd) {
    this.fd = fd
    if (this[HAD_ERROR]) {
      return this[CLOSE]()
    }

    this.blockLen = 512 * Math.ceil(this.stat.size / 512)
    this.blockRemain = this.blockLen
    const bufLen = Math.min(this.blockLen, this.maxReadSize)
    this.buf = Buffer.allocUnsafe(bufLen)
    this.offset = 0
    this.pos = 0
    this.remain = this.stat.size
    this.length = this.buf.length
    this[READ]()
  }

  [READ] () {
    const { fd, buf, offset, length, pos } = this
    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
      if (er) {
        // ignoring the error from close(2) is a bad practice, but at
        // this point we already have an error, don't need another one
        return this[CLOSE](() => this.emit('error', er))
      }
      this[ONREAD](bytesRead)
    })
  }

  [CLOSE] (cb) {
    fs.close(this.fd, cb)
  }

  [ONREAD] (bytesRead) {
    if (bytesRead <= 0 && this.remain > 0) {
      const er = new Error('encountered unexpected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      return this[CLOSE](() => this.emit('error', er))
    }

    if (bytesRead > this.remain) {
      const er = new Error('did not encounter expected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      return this[CLOSE](() => this.emit('error', er))
    }

    // null out the rest of the buffer, if we could fit the block padding
    // at the end of this loop, we've incremented bytesRead and this.remain
    // to be incremented up to the blockRemain level, as if we had expected
    // to get a null-padded file, and read it until the end.  then we will
    // decrement both remain and blockRemain by bytesRead, and know that we
    // reached the expected EOF, without any null buffer to append.
    if (bytesRead === this.remain) {
      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
        this.buf[i + this.offset] = 0
        bytesRead++
        this.remain++
      }
    }

    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?
      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)

    const flushed = this.write(writeBuf)
    if (!flushed) {
      this[AWAITDRAIN](() => this[ONDRAIN]())
    } else {
      this[ONDRAIN]()
    }
  }

  [AWAITDRAIN] (cb) {
    this.once('drain', cb)
  }

  write (writeBuf) {
    if (this.blockRemain < writeBuf.length) {
      const er = new Error('writing more data than expected')
      er.path = this.absolute
      return this.emit('error', er)
    }
    this.remain -= writeBuf.length
    this.blockRemain -= writeBuf.length
    this.pos += writeBuf.length
    this.offset += writeBuf.length
    return super.write(writeBuf)
  }

  [ONDRAIN] () {
    if (!this.remain) {
      if (this.blockRemain) {
        super.write(Buffer.alloc(this.blockRemain))
      }
      return this[CLOSE](er => er ? this.emit('error', er) : this.end())
    }

    if (this.offset >= this.length) {
      // if we only have a smaller bit left to read, alloc a smaller buffer
      // otherwise, keep it the same length it was before.
      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))
      this.offset = 0
    }
    this.length = this.buf.length - this.offset
    this[READ]()
  }
})

class WriteEntrySync extends WriteEntry {
  [LSTAT] () {
    this[ONLSTAT](fs.lstatSync(this.absolute))
  }

  [SYMLINK] () {
    this[ONREADLINK](fs.readlinkSync(this.absolute))
  }

  [OPENFILE] () {
    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))
  }

  [READ] () {
    let threw = true
    try {
      const { fd, buf, offset, length, pos } = this
      const bytesRead = fs.readSync(fd, buf, offset, length, pos)
      this[ONREAD](bytesRead)
      threw = false
    } finally {
      // ignoring the error from close(2) is a bad practice, but at
      // this point we already have an error, don't need another one
      if (threw) {
        try {
          this[CLOSE](() => {})
        } catch (er) {}
      }
    }
  }

  [AWAITDRAIN] (cb) {
    cb()
  }

  [CLOSE] (cb) {
    fs.closeSync(this.fd)
    cb()
  }
}

const WriteEntryTar = warner(class WriteEntryTar extends Minipass {
  constructor (readEntry, opt) {
    opt = opt || {}
    super(opt)
    this.preservePaths = !!opt.preservePaths
    this.portable = !!opt.portable
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime

    this.readEntry = readEntry
    this.type = readEntry.type
    if (this.type === 'Directory' && this.portable) {
      this.noMtime = true
    }

    this.prefix = opt.prefix || null

    this.path = normPath(readEntry.path)
    this.mode = this[MODE](readEntry.mode)
    this.uid = this.portable ? null : readEntry.uid
    this.gid = this.portable ? null : readEntry.gid
    this.uname = this.portable ? null : readEntry.uname
    this.gname = this.portable ? null : readEntry.gname
    this.size = readEntry.size
    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime
    this.atime = this.portable ? null : readEntry.atime
    this.ctime = this.portable ? null : readEntry.ctime
    this.linkpath = normPath(readEntry.linkpath)

    if (typeof opt.onwarn === 'function') {
      this.on('warn', opt.onwarn)
    }

    let pathWarn = false
    if (!this.preservePaths) {
      const [root, stripped] = stripAbsolutePath(this.path)
      if (root) {
        this.path = stripped
        pathWarn = root
      }
    }

    this.remain = readEntry.size
    this.blockRemain = readEntry.startBlockSize

    this.header = new Header({
      path: this[PREFIX](this.path),
      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
      : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this.mode,
      uid: this.portable ? null : this.uid,
      gid: this.portable ? null : this.gid,
      size: this.size,
      mtime: this.noMtime ? null : this.mtime,
      type: this.type,
      uname: this.portable ? null : this.uname,
      atime: this.portable ? null : this.atime,
      ctime: this.portable ? null : this.ctime,
    })

    if (pathWarn) {
      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path,
      })
    }

    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
        gid: this.portable ? null : this.gid,
        mtime: this.noMtime ? null : this.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
        : this.linkpath,
        size: this.size,
        uid: this.portable ? null : this.uid,
        uname: this.portable ? null : this.uname,
        dev: this.portable ? null : this.readEntry.dev,
        ino: this.portable ? null : this.readEntry.ino,
        nlink: this.portable ? null : this.readEntry.nlink,
      }).encode())
    }

    super.write(this.header.block)
    readEntry.pipe(this)
  }

  [PREFIX] (path) {
    return prefixPath(path, this.prefix)
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory', this.portable)
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain) {
      throw new Error('writing more to entry than is appropriate')
    }
    this.blockRemain -= writeLen
    return super.write(data)
  }

  end () {
    if (this.blockRemain) {
      super.write(Buffer.alloc(this.blockRemain))
    }
    return super.end()
  }
})

WriteEntry.Sync = WriteEntrySync
WriteEntry.Tar = WriteEntryTar

const getType = stat =>
  stat.isFile() ? 'File'
  : stat.isDirectory() ? 'Directory'
  : stat.isSymbolicLink() ? 'SymbolicLink'
  : 'Unsupported'

module.exports = WriteEntry


/***/ }),

/***/ 2034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const optsArg = __webpack_require__(5571)
const pathArg = __webpack_require__(8790)

const {mkdirpNative, mkdirpNativeSync} = __webpack_require__(2389)
const {mkdirpManual, mkdirpManualSync} = __webpack_require__(7296)
const {useNative, useNativeSync} = __webpack_require__(4921)


const mkdirp = (path, opts) => {
  path = pathArg(path)
  opts = optsArg(opts)
  return useNative(opts)
    ? mkdirpNative(path, opts)
    : mkdirpManual(path, opts)
}

const mkdirpSync = (path, opts) => {
  path = pathArg(path)
  opts = optsArg(opts)
  return useNativeSync(opts)
    ? mkdirpNativeSync(path, opts)
    : mkdirpManualSync(path, opts)
}

mkdirp.sync = mkdirpSync
mkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))
mkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))
mkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))
mkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))

module.exports = mkdirp


/***/ }),

/***/ 2169:
/***/ ((module) => {

/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

var hasElementType = typeof Element !== 'undefined';
var hasMap = typeof Map === 'function';
var hasSet = typeof Set === 'function';
var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

function equal(a, b) {
  // START: fast-deep-equal es6/index.js 3.1.3
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    // START: Modifications:
    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
    //    to co-exist with es5.
    // 2. Replace `for of` with es5 compliant iteration using `for`.
    //    Basically, take:
    //
    //    ```js
    //    for (i of a.entries())
    //      if (!b.has(i[0])) return false;
    //    ```
    //
    //    ... and convert to:
    //
    //    ```js
    //    it = a.entries();
    //    while (!(i = it.next()).done)
    //      if (!b.has(i.value[0])) return false;
    //    ```
    //
    //    **Note**: `i` access switches to `i.value`.
    var it;
    if (hasMap && (a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0]))) return false;
      return true;
    }

    if (hasSet && (a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      return true;
    }
    // END: Modifications

    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    // START: Modifications:
    // Apply guards for `Object.create(null)` handling. See:
    // - https://github.com/FormidableLabs/react-fast-compare/issues/64
    // - https://github.com/epoberezkin/fast-deep-equal/issues/49
    if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
    // END: Modifications

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    // END: fast-deep-equal

    // START: react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element) return false;

    // custom handling for React/Preact
    for (i = length; i-- !== 0;) {
      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner
        // Preact-specific: avoid traversing Preact elements' __v and __o
        //    __v = $_original / $_vnode
        //    __o = $_owner
        // These properties contain circular references and are not needed when
        // comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of elements

        continue;
      }

      // all other properties should be traversed as usual
      if (!equal(a[keys[i]], b[keys[i]])) return false;
    }
    // END: react-fast-compare

    // START: fast-deep-equal
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

module.exports = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (((error.message || '').match(/stack|recursion/i))) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('react-fast-compare cannot handle circular refs');
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};


/***/ }),

/***/ 2203:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 2328:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(1613);
} else {}


/***/ }),

/***/ 2389:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {dirname} = __webpack_require__(6928)
const {findMade, findMadeSync} = __webpack_require__(4625)
const {mkdirpManual, mkdirpManualSync} = __webpack_require__(7296)

const mkdirpNative = (path, opts) => {
  opts.recursive = true
  const parent = dirname(path)
  if (parent === path)
    return opts.mkdirAsync(path, opts)

  return findMade(opts, path).then(made =>
    opts.mkdirAsync(path, opts).then(() => made)
    .catch(er => {
      if (er.code === 'ENOENT')
        return mkdirpManual(path, opts)
      else
        throw er
    }))
}

const mkdirpNativeSync = (path, opts) => {
  opts.recursive = true
  const parent = dirname(path)
  if (parent === path)
    return opts.mkdirSync(path, opts)

  const made = findMadeSync(opts, path)
  try {
    opts.mkdirSync(path, opts)
    return made
  } catch (er) {
    if (er.code === 'ENOENT')
      return mkdirpManualSync(path, opts)
    else
      throw er
  }
}

module.exports = {mkdirpNative, mkdirpNativeSync}


/***/ }),

/***/ 2483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(7045);
} else {}


/***/ }),

/***/ 2613:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 3009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Minipass } = __webpack_require__(5904)
const normPath = __webpack_require__(3373)

const SLURP = Symbol('slurp')
module.exports = class ReadEntry extends Minipass {
  constructor (header, ex, gex) {
    super()
    // read entries always start life paused.  this is to avoid the
    // situation where Minipass's auto-ending empty streams results
    // in an entry ending before we're ready for it.
    this.pause()
    this.extended = ex
    this.globalExtended = gex
    this.header = header
    this.startBlockSize = 512 * Math.ceil(header.size / 512)
    this.blockRemain = this.startBlockSize
    this.remain = header.size
    this.type = header.type
    this.meta = false
    this.ignore = false
    switch (this.type) {
      case 'File':
      case 'OldFile':
      case 'Link':
      case 'SymbolicLink':
      case 'CharacterDevice':
      case 'BlockDevice':
      case 'Directory':
      case 'FIFO':
      case 'ContiguousFile':
      case 'GNUDumpDir':
        break

      case 'NextFileHasLongLinkpath':
      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
      case 'GlobalExtendedHeader':
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this.meta = true
        break

      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
      // it may be worth doing the same, but with a warning.
      default:
        this.ignore = true
    }

    this.path = normPath(header.path)
    this.mode = header.mode
    if (this.mode) {
      this.mode = this.mode & 0o7777
    }
    this.uid = header.uid
    this.gid = header.gid
    this.uname = header.uname
    this.gname = header.gname
    this.size = header.size
    this.mtime = header.mtime
    this.atime = header.atime
    this.ctime = header.ctime
    this.linkpath = normPath(header.linkpath)
    this.uname = header.uname
    this.gname = header.gname

    if (ex) {
      this[SLURP](ex)
    }
    if (gex) {
      this[SLURP](gex, true)
    }
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain) {
      throw new Error('writing more to entry than is appropriate')
    }

    const r = this.remain
    const br = this.blockRemain
    this.remain = Math.max(0, r - writeLen)
    this.blockRemain = Math.max(0, br - writeLen)
    if (this.ignore) {
      return true
    }

    if (r >= writeLen) {
      return super.write(data)
    }

    // r < writeLen
    return super.write(data.slice(0, r))
  }

  [SLURP] (ex, global) {
    for (const k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path')) {
        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]
      }
    }
  }
}


/***/ }),

/***/ 3106:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 3193:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 3373:
/***/ ((module) => {

// on windows, either \ or / are valid directory separators.
// on unix, \ is a valid character in filenames.
// so, on windows, and only on windows, we replace all \ chars with /,
// so that we can use / as our one and only directory separator char.

const platform = {}.TESTING_TAR_FAKE_PLATFORM || process.platform
module.exports = platform !== 'win32' ? p => p
  : p => p && p.replace(/\\/g, '/')


/***/ }),

/***/ 3593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

class PackJob {
  constructor (path, absolute) {
    this.path = path || './'
    this.absolute = absolute
    this.entry = null
    this.stat = null
    this.readdir = null
    this.pending = false
    this.ignore = false
    this.piped = false
  }
}

const { Minipass } = __webpack_require__(5904)
const zlib = __webpack_require__(1857)
const ReadEntry = __webpack_require__(3009)
const WriteEntry = __webpack_require__(1996)
const WriteEntrySync = WriteEntry.Sync
const WriteEntryTar = WriteEntry.Tar
const Yallist = __webpack_require__(7841)
const EOF = Buffer.alloc(1024)
const ONSTAT = Symbol('onStat')
const ENDED = Symbol('ended')
const QUEUE = Symbol('queue')
const CURRENT = Symbol('current')
const PROCESS = Symbol('process')
const PROCESSING = Symbol('processing')
const PROCESSJOB = Symbol('processJob')
const JOBS = Symbol('jobs')
const JOBDONE = Symbol('jobDone')
const ADDFSENTRY = Symbol('addFSEntry')
const ADDTARENTRY = Symbol('addTarEntry')
const STAT = Symbol('stat')
const READDIR = Symbol('readdir')
const ONREADDIR = Symbol('onreaddir')
const PIPE = Symbol('pipe')
const ENTRY = Symbol('entry')
const ENTRYOPT = Symbol('entryOpt')
const WRITEENTRYCLASS = Symbol('writeEntryClass')
const WRITE = Symbol('write')
const ONDRAIN = Symbol('ondrain')

const fs = __webpack_require__(9896)
const path = __webpack_require__(6928)
const warner = __webpack_require__(472)
const normPath = __webpack_require__(3373)

const Pack = warner(class Pack extends Minipass {
  constructor (opt) {
    super(opt)
    opt = opt || Object.create(null)
    this.opt = opt
    this.file = opt.file || ''
    this.cwd = opt.cwd || process.cwd()
    this.maxReadSize = opt.maxReadSize
    this.preservePaths = !!opt.preservePaths
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.prefix = normPath(opt.prefix || '')
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.readdirCache = opt.readdirCache || new Map()

    this[WRITEENTRYCLASS] = WriteEntry
    if (typeof opt.onwarn === 'function') {
      this.on('warn', opt.onwarn)
    }

    this.portable = !!opt.portable
    this.zip = null

    if (opt.gzip || opt.brotli) {
      if (opt.gzip && opt.brotli) {
        throw new TypeError('gzip and brotli are mutually exclusive')
      }
      if (opt.gzip) {
        if (typeof opt.gzip !== 'object') {
          opt.gzip = {}
        }
        if (this.portable) {
          opt.gzip.portable = true
        }
        this.zip = new zlib.Gzip(opt.gzip)
      }
      if (opt.brotli) {
        if (typeof opt.brotli !== 'object') {
          opt.brotli = {}
        }
        this.zip = new zlib.BrotliCompress(opt.brotli)
      }
      this.zip.on('data', chunk => super.write(chunk))
      this.zip.on('end', _ => super.end())
      this.zip.on('drain', _ => this[ONDRAIN]())
      this.on('resume', _ => this.zip.resume())
    } else {
      this.on('drain', this[ONDRAIN])
    }

    this.noDirRecurse = !!opt.noDirRecurse
    this.follow = !!opt.follow
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null

    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true

    this[QUEUE] = new Yallist()
    this[JOBS] = 0
    this.jobs = +opt.jobs || 4
    this[PROCESSING] = false
    this[ENDED] = false
  }

  [WRITE] (chunk) {
    return super.write(chunk)
  }

  add (path) {
    this.write(path)
    return this
  }

  end (path) {
    if (path) {
      this.write(path)
    }
    this[ENDED] = true
    this[PROCESS]()
    return this
  }

  write (path) {
    if (this[ENDED]) {
      throw new Error('write after end')
    }

    if (path instanceof ReadEntry) {
      this[ADDTARENTRY](path)
    } else {
      this[ADDFSENTRY](path)
    }
    return this.flowing
  }

  [ADDTARENTRY] (p) {
    const absolute = normPath(path.resolve(this.cwd, p.path))
    // in this case, we don't have to wait for the stat
    if (!this.filter(p.path, p)) {
      p.resume()
    } else {
      const job = new PackJob(p.path, absolute, false)
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))
      job.entry.on('end', _ => this[JOBDONE](job))
      this[JOBS] += 1
      this[QUEUE].push(job)
    }

    this[PROCESS]()
  }

  [ADDFSENTRY] (p) {
    const absolute = normPath(path.resolve(this.cwd, p))
    this[QUEUE].push(new PackJob(p, absolute))
    this[PROCESS]()
  }

  [STAT] (job) {
    job.pending = true
    this[JOBS] += 1
    const stat = this.follow ? 'stat' : 'lstat'
    fs[stat](job.absolute, (er, stat) => {
      job.pending = false
      this[JOBS] -= 1
      if (er) {
        this.emit('error', er)
      } else {
        this[ONSTAT](job, stat)
      }
    })
  }

  [ONSTAT] (job, stat) {
    this.statCache.set(job.absolute, stat)
    job.stat = stat

    // now we have the stat, we can filter it.
    if (!this.filter(job.path, stat)) {
      job.ignore = true
    }

    this[PROCESS]()
  }

  [READDIR] (job) {
    job.pending = true
    this[JOBS] += 1
    fs.readdir(job.absolute, (er, entries) => {
      job.pending = false
      this[JOBS] -= 1
      if (er) {
        return this.emit('error', er)
      }
      this[ONREADDIR](job, entries)
    })
  }

  [ONREADDIR] (job, entries) {
    this.readdirCache.set(job.absolute, entries)
    job.readdir = entries
    this[PROCESS]()
  }

  [PROCESS] () {
    if (this[PROCESSING]) {
      return
    }

    this[PROCESSING] = true
    for (let w = this[QUEUE].head;
      w !== null && this[JOBS] < this.jobs;
      w = w.next) {
      this[PROCESSJOB](w.value)
      if (w.value.ignore) {
        const p = w.next
        this[QUEUE].removeNode(w)
        w.next = p
      }
    }

    this[PROCESSING] = false

    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
      if (this.zip) {
        this.zip.end(EOF)
      } else {
        super.write(EOF)
        super.end()
      }
    }
  }

  get [CURRENT] () {
    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value
  }

  [JOBDONE] (job) {
    this[QUEUE].shift()
    this[JOBS] -= 1
    this[PROCESS]()
  }

  [PROCESSJOB] (job) {
    if (job.pending) {
      return
    }

    if (job.entry) {
      if (job === this[CURRENT] && !job.piped) {
        this[PIPE](job)
      }
      return
    }

    if (!job.stat) {
      if (this.statCache.has(job.absolute)) {
        this[ONSTAT](job, this.statCache.get(job.absolute))
      } else {
        this[STAT](job)
      }
    }
    if (!job.stat) {
      return
    }

    // filtered out!
    if (job.ignore) {
      return
    }

    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
      if (this.readdirCache.has(job.absolute)) {
        this[ONREADDIR](job, this.readdirCache.get(job.absolute))
      } else {
        this[READDIR](job)
      }
      if (!job.readdir) {
        return
      }
    }

    // we know it doesn't have an entry, because that got checked above
    job.entry = this[ENTRY](job)
    if (!job.entry) {
      job.ignore = true
      return
    }

    if (job === this[CURRENT] && !job.piped) {
      this[PIPE](job)
    }
  }

  [ENTRYOPT] (job) {
    return {
      onwarn: (code, msg, data) => this.warn(code, msg, data),
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime,
      prefix: this.prefix,
    }
  }

  [ENTRY] (job) {
    this[JOBS] += 1
    try {
      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))
        .on('end', () => this[JOBDONE](job))
        .on('error', er => this.emit('error', er))
    } catch (er) {
      this.emit('error', er)
    }
  }

  [ONDRAIN] () {
    if (this[CURRENT] && this[CURRENT].entry) {
      this[CURRENT].entry.resume()
    }
  }

  // like .pipe() but using super, because our write() is special
  [PIPE] (job) {
    job.piped = true

    if (job.readdir) {
      job.readdir.forEach(entry => {
        const p = job.path
        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })
    }

    const source = job.entry
    const zip = this.zip

    if (zip) {
      source.on('data', chunk => {
        if (!zip.write(chunk)) {
          source.pause()
        }
      })
    } else {
      source.on('data', chunk => {
        if (!super.write(chunk)) {
          source.pause()
        }
      })
    }
  }

  pause () {
    if (this.zip) {
      this.zip.pause()
    }
    return super.pause()
  }
})

class PackSync extends Pack {
  constructor (opt) {
    super(opt)
    this[WRITEENTRYCLASS] = WriteEntrySync
  }

  // pause/resume are no-ops in sync streams.
  pause () {}
  resume () {}

  [STAT] (job) {
    const stat = this.follow ? 'statSync' : 'lstatSync'
    this[ONSTAT](job, fs[stat](job.absolute))
  }

  [READDIR] (job, stat) {
    this[ONREADDIR](job, fs.readdirSync(job.absolute))
  }

  // gotta get it all in this tick
  [PIPE] (job) {
    const source = job.entry
    const zip = this.zip

    if (job.readdir) {
      job.readdir.forEach(entry => {
        const p = job.path
        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })
    }

    if (zip) {
      source.on('data', chunk => {
        zip.write(chunk)
      })
    } else {
      source.on('data', chunk => {
        super[WRITE](chunk)
      })
    }
  }
}

Pack.Sync = PackSync

module.exports = Pack


/***/ }),

/***/ 3780:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  W: () => (/* binding */ noCase)
});

;// ./node_modules/lower-case/dist.es2015/index.js
/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
var SUPPORTED_LOCALE = {
    tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
            : "\u0069",
            I: "\u0131",
            I: "\u0069",
        },
    },
    az: {
        regexp: /\u0130/g,
        map: {
            : "\u0069",
            I: "\u0131",
            I: "\u0069",
        },
    },
    lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
            I: "\u0069\u0307",
            J: "\u006A\u0307",
            : "\u012F\u0307",
            : "\u0069\u0307\u0300",
            : "\u0069\u0307\u0301",
            : "\u0069\u0307\u0303",
        },
    },
};
/**
 * Localized lower case.
 */
function localeLowerCase(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));
    return lowerCase(str);
}
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}

;// ./node_modules/no-case/dist.es2015/index.js

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}


/***/ }),

/***/ 4211:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const proc = typeof process === 'object' && process ? process : {
  stdout: null,
  stderr: null,
}
const EE = __webpack_require__(4434)
const Stream = __webpack_require__(2203)
const SD = (__webpack_require__(3193).StringDecoder)

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const EMITTED_ERROR = Symbol('emittedError')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
const DESTROYED = Symbol('destroyed')
const EMITDATA = Symbol('emitData')
const EMITEND = Symbol('emitEnd')
const EMITEND2 = Symbol('emitEnd2')
const ASYNC = Symbol('async')

const defer = fn => Promise.resolve().then(fn)

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'
const ASYNCITERATOR = doIter && Symbol.asyncIterator
  || Symbol('asyncIterator not implemented')
const ITERATOR = doIter && Symbol.iterator
  || Symbol('iterator not implemented')

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev =>
  ev === 'end' ||
  ev === 'finish' ||
  ev === 'prefinish'

const isArrayBuffer = b => b instanceof ArrayBuffer ||
  typeof b === 'object' &&
  b.constructor &&
  b.constructor.name === 'ArrayBuffer' &&
  b.byteLength >= 0

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

class Pipe {
  constructor (src, dest, opts) {
    this.src = src
    this.dest = dest
    this.opts = opts
    this.ondrain = () => src[RESUME]()
    dest.on('drain', this.ondrain)
  }
  unpipe () {
    this.dest.removeListener('drain', this.ondrain)
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors () {}
  end () {
    this.unpipe()
    if (this.opts.end)
      this.dest.end()
  }
}

class PipeProxyErrors extends Pipe {
  unpipe () {
    this.src.removeListener('error', this.proxyErrors)
    super.unpipe()
  }
  constructor (src, dest, opts) {
    super(src, dest, opts)
    this.proxyErrors = er => dest.emit('error', er)
    src.on('error', this.proxyErrors)
  }
}

module.exports = class Minipass extends Stream {
  constructor (options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this.pipes = []
    this.buffer = []
    this[OBJECTMODE] = options && options.objectMode || false
    if (this[OBJECTMODE])
      this[ENCODING] = null
    else
      this[ENCODING] = options && options.encoding || null
    if (this[ENCODING] === 'buffer')
      this[ENCODING] = null
    this[ASYNC] = options && !!options.async || false
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this[EMITTED_ERROR] = null
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
  }

  get bufferLength () { return this[BUFFERLENGTH] }

  get encoding () { return this[ENCODING] }
  set encoding (enc) {
    if (this[OBJECTMODE])
      throw new Error('cannot set encoding in objectMode')

    if (this[ENCODING] && enc !== this[ENCODING] &&
        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this.buffer.length)
        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding (enc) {
    this.encoding = enc
  }

  get objectMode () { return this[OBJECTMODE] }
  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }

  get ['async'] () { return this[ASYNC] }
  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }

  write (chunk, encoding, cb) {
    if (this[EOF])
      throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit('error', Object.assign(
        new Error('Cannot call write after a stream was destroyed'),
        { code: 'ERR_STREAM_DESTROYED' }
      ))
      return true
    }

    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (!encoding)
      encoding = 'utf8'

    const fn = this[ASYNC] ? defer : f => f()

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk))
        chunk = Buffer.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true)

      if (this.flowing)
        this.emit('data', chunk)
      else
        this[BUFFERPUSH](chunk)

      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')

      if (cb)
        fn(cb)

      return this.flowing
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        fn(cb)
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (typeof chunk === 'string' &&
        // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
      chunk = Buffer.from(chunk, encoding)
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true)

    if (this.flowing)
      this.emit('data', chunk)
    else
      this[BUFFERPUSH](chunk)

    if (this[BUFFERLENGTH] !== 0)
      this.emit('readable')

    if (cb)
      fn(cb)

    return this.flowing
  }

  read (n) {
    if (this[DESTROYED])
      return null

    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]()
      return null
    }

    if (this[OBJECTMODE])
      n = null

    if (this.buffer.length > 1 && !this[OBJECTMODE]) {
      if (this.encoding)
        this.buffer = [this.buffer.join('')]
      else
        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]
    }

    const ret = this[READ](n || null, this.buffer[0])
    this[MAYBE_EMIT_END]()
    return ret
  }

  [READ] (n, chunk) {
    if (n === chunk.length || n === null)
      this[BUFFERSHIFT]()
    else {
      this.buffer[0] = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')

    return chunk
  }

  end (chunk, encoding, cb) {
    if (typeof chunk === 'function')
      cb = chunk, chunk = null
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'
    if (chunk)
      this.write(chunk, encoding)
    if (cb)
      this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED])
      this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME] () {
    if (this[DESTROYED])
      return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this.buffer.length)
      this[FLUSH]()
    else if (this[EOF])
      this[MAYBE_EMIT_END]()
    else
      this.emit('drain')
  }

  resume () {
    return this[RESUME]()
  }

  pause () {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed () {
    return this[DESTROYED]
  }

  get flowing () {
    return this[FLOWING]
  }

  get paused () {
    return this[PAUSED]
  }

  [BUFFERPUSH] (chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1
    else
      this[BUFFERLENGTH] += chunk.length
    this.buffer.push(chunk)
  }

  [BUFFERSHIFT] () {
    if (this.buffer.length) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1
      else
        this[BUFFERLENGTH] -= this.buffer[0].length
    }
    return this.buffer.shift()
  }

  [FLUSH] (noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

    if (!noDrain && !this.buffer.length && !this[EOF])
      this.emit('drain')
  }

  [FLUSHCHUNK] (chunk) {
    return chunk ? (this.emit('data', chunk), this.flowing) : false
  }

  pipe (dest, opts) {
    if (this[DESTROYED])
      return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false
    else
      opts.end = opts.end !== false
    opts.proxyErrors = !!opts.proxyErrors

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end)
        dest.end()
    } else {
      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)
        : new PipeProxyErrors(this, dest, opts))
      if (this[ASYNC])
        defer(() => this[RESUME]())
      else
        this[RESUME]()
    }

    return dest
  }

  unpipe (dest) {
    const p = this.pipes.find(p => p.dest === dest)
    if (p) {
      this.pipes.splice(this.pipes.indexOf(p), 1)
      p.unpipe()
    }
  }

  addListener (ev, fn) {
    return this.on(ev, fn)
  }

  on (ev, fn) {
    const ret = super.on(ev, fn)
    if (ev === 'data' && !this.pipes.length && !this.flowing)
      this[RESUME]()
    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)
      super.emit('readable')
    else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev)
      this.removeAllListeners(ev)
    } else if (ev === 'error' && this[EMITTED_ERROR]) {
      if (this[ASYNC])
        defer(() => fn.call(this, this[EMITTED_ERROR]))
      else
        fn.call(this, this[EMITTED_ERROR])
    }
    return ret
  }

  get emittedEnd () {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END] () {
    if (!this[EMITTING_END] &&
        !this[EMITTED_END] &&
        !this[DESTROYED] &&
        this.buffer.length === 0 &&
        this[EOF]) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED])
        this.emit('close')
      this[EMITTING_END] = false
    }
  }

  emit (ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      return !data ? false
        : this[ASYNC] ? defer(() => this[EMITDATA](data))
        : this[EMITDATA](data)
    } else if (ev === 'end') {
      return this[EMITEND]()
    } else if (ev === 'close') {
      this[CLOSED] = true
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED])
        return
      const ret = super.emit('close')
      this.removeAllListeners('close')
      return ret
    } else if (ev === 'error') {
      this[EMITTED_ERROR] = data
      const ret = super.emit('error', data)
      this[MAYBE_EMIT_END]()
      return ret
    } else if (ev === 'resume') {
      const ret = super.emit('resume')
      this[MAYBE_EMIT_END]()
      return ret
    } else if (ev === 'finish' || ev === 'prefinish') {
      const ret = super.emit(ev)
      this.removeAllListeners(ev)
      return ret
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra)
    this[MAYBE_EMIT_END]()
    return ret
  }

  [EMITDATA] (data) {
    for (const p of this.pipes) {
      if (p.dest.write(data) === false)
        this.pause()
    }
    const ret = super.emit('data', data)
    this[MAYBE_EMIT_END]()
    return ret
  }

  [EMITEND] () {
    if (this[EMITTED_END])
      return

    this[EMITTED_END] = true
    this.readable = false
    if (this[ASYNC])
      defer(() => this[EMITEND2]())
    else
      this[EMITEND2]()
  }

  [EMITEND2] () {
    if (this[DECODER]) {
      const data = this[DECODER].end()
      if (data) {
        for (const p of this.pipes) {
          p.dest.write(data)
        }
        super.emit('data', data)
      }
    }

    for (const p of this.pipes) {
      p.end()
    }
    const ret = super.emit('end')
    this.removeAllListeners('end')
    return ret
  }

  // const all = await stream.collect()
  collect () {
    const buf = []
    if (!this[OBJECTMODE])
      buf.dataLength = 0
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise()
    this.on('data', c => {
      buf.push(c)
      if (!this[OBJECTMODE])
        buf.dataLength += c.length
    })
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat () {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))
  }

  // stream.promise().then(() => done, er => emitted error)
  promise () {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')))
      this.on('error', er => reject(er))
      this.on('end', () => resolve())
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR] () {
    const next = () => {
      const res = this.read()
      if (res !== null)
        return Promise.resolve({ done: false, value: res })

      if (this[EOF])
        return Promise.resolve({ done: true })

      let resolve = null
      let reject = null
      const onerr = er => {
        this.removeListener('data', ondata)
        this.removeListener('end', onend)
        reject(er)
      }
      const ondata = value => {
        this.removeListener('error', onerr)
        this.removeListener('end', onend)
        this.pause()
        resolve({ value: value, done: !!this[EOF] })
      }
      const onend = () => {
        this.removeListener('error', onerr)
        this.removeListener('data', ondata)
        resolve({ done: true })
      }
      const ondestroy = () => onerr(new Error('stream destroyed'))
      return new Promise((res, rej) => {
        reject = rej
        resolve = res
        this.once(DESTROYED, ondestroy)
        this.once('error', onerr)
        this.once('end', onend)
        this.once('data', ondata)
      })
    }

    return { next }
  }

  // for (let chunk of stream)
  [ITERATOR] () {
    const next = () => {
      const value = this.read()
      const done = value === null
      return { value, done }
    }
    return { next }
  }

  destroy (er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit('error', er)
      else
        this.emit(DESTROYED)
      return this
    }

    this[DESTROYED] = true

    // throw away all buffered data, it's never coming out
    this.buffer.length = 0
    this[BUFFERLENGTH] = 0

    if (typeof this.close === 'function' && !this[CLOSED])
      this.close()

    if (er)
      this.emit('error', er)
    else // if no error to emit, still reject pending promises
      this.emit(DESTROYED)

    return this
  }

  static isStream (s) {
    return !!s && (s instanceof Minipass || s instanceof Stream ||
      s instanceof EE && (
        typeof s.pipe === 'function' || // readable
        (typeof s.write === 'function' && typeof s.end === 'function') // writable
      ))
  }
}


/***/ }),

/***/ 4286:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const base64 = __webpack_require__(7890);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

const VLQ_BASE_SHIFT = 5;

// binary: 100000
const VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
const VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
const VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
// eslint-disable-next-line no-unused-vars
function fromVLQSigned(aValue) {
  const isNegative = (aValue & 1) === 1;
  const shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  let encoded = "";
  let digit;

  let vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};


/***/ }),

/***/ 4297:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  const mid = Math.floor((aHigh - aLow) / 2) + aLow;
  const cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    }
    return mid;
  }

  // Our needle is less than aHaystack[mid].
  if (mid - aLow > 1) {
    // The element is in the lower half.
    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
  }

  // we are in termination case (3) or (2) and return the appropriate thing.
  if (aBias == exports.LEAST_UPPER_BOUND) {
    return mid;
  }
  return aLow < 0 ? -1 : aLow;
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ 4318:
/***/ ((module) => {

"use strict";

// Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.

const encode = (num, buf) => {
  if (!Number.isSafeInteger(num)) {
  // The number is so large that javascript cannot represent it with integer
  // precision.
    throw Error('cannot encode number outside of javascript safe integer range')
  } else if (num < 0) {
    encodeNegative(num, buf)
  } else {
    encodePositive(num, buf)
  }
  return buf
}

const encodePositive = (num, buf) => {
  buf[0] = 0x80

  for (var i = buf.length; i > 1; i--) {
    buf[i - 1] = num & 0xff
    num = Math.floor(num / 0x100)
  }
}

const encodeNegative = (num, buf) => {
  buf[0] = 0xff
  var flipped = false
  num = num * -1
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 0xff
    num = Math.floor(num / 0x100)
    if (flipped) {
      buf[i - 1] = onesComp(byte)
    } else if (byte === 0) {
      buf[i - 1] = 0
    } else {
      flipped = true
      buf[i - 1] = twosComp(byte)
    }
  }
}

const parse = (buf) => {
  const pre = buf[0]
  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))
    : pre === 0xff ? twos(buf)
    : null
  if (value === null) {
    throw Error('invalid base256 encoding')
  }

  if (!Number.isSafeInteger(value)) {
  // The number is so large that javascript cannot represent it with integer
  // precision.
    throw Error('parsed number outside of javascript safe integer range')
  }

  return value
}

const twos = (buf) => {
  var len = buf.length
  var sum = 0
  var flipped = false
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    var f
    if (flipped) {
      f = onesComp(byte)
    } else if (byte === 0) {
      f = byte
    } else {
      flipped = true
      f = twosComp(byte)
    }
    if (f !== 0) {
      sum -= f * Math.pow(256, len - i - 1)
    }
  }
  return sum
}

const pos = (buf) => {
  var len = buf.length
  var sum = 0
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    if (byte !== 0) {
      sum += byte * Math.pow(256, len - i - 1)
    }
  }
  return sum
}

const onesComp = byte => (0xff ^ byte) & 0xff

const twosComp = byte => ((0xff ^ byte) + 1) & 0xff

module.exports = {
  encode,
  parse,
}


/***/ }),

/***/ 4434:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 4625:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {dirname} = __webpack_require__(6928)

const findMade = (opts, parent, path = undefined) => {
  // we never want the 'made' return value to be a root directory
  if (path === parent)
    return Promise.resolve()

  return opts.statAsync(parent).then(
    st => st.isDirectory() ? path : undefined, // will fail later
    er => er.code === 'ENOENT'
      ? findMade(opts, dirname(parent), parent)
      : undefined
  )
}

const findMadeSync = (opts, parent, path = undefined) => {
  if (path === parent)
    return undefined

  try {
    return opts.statSync(parent).isDirectory() ? path : undefined
  } catch (er) {
    return er.code === 'ENOENT'
      ? findMadeSync(opts, dirname(parent), parent)
      : undefined
  }
}

module.exports = {findMade, findMadeSync}


/***/ }),

/***/ 4656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -c
const hlo = __webpack_require__(1743)

const Pack = __webpack_require__(3593)
const fsm = __webpack_require__(5733)
const t = __webpack_require__(4832)
const path = __webpack_require__(6928)

module.exports = (opt_, files, cb) => {
  if (typeof files === 'function') {
    cb = files
  }

  if (Array.isArray(opt_)) {
    files = opt_, opt_ = {}
  }

  if (!files || !Array.isArray(files) || !files.length) {
    throw new TypeError('no files or directories specified')
  }

  files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function') {
    throw new TypeError('callback not supported for sync tar functions')
  }

  if (!opt.file && typeof cb === 'function') {
    throw new TypeError('callback only supported with file option')
  }

  return opt.file && opt.sync ? createFileSync(opt, files)
    : opt.file ? createFile(opt, files, cb)
    : opt.sync ? createSync(opt, files)
    : create(opt, files)
}

const createFileSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  const stream = new fsm.WriteStreamSync(opt.file, {
    mode: opt.mode || 0o666,
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const createFile = (opt, files, cb) => {
  const p = new Pack(opt)
  const stream = new fsm.WriteStream(opt.file, {
    mode: opt.mode || 0o666,
  })
  p.pipe(stream)

  const promise = new Promise((res, rej) => {
    stream.on('error', rej)
    stream.on('close', res)
    p.on('error', rej)
  })

  addFilesAsync(p, files)

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@') {
      t({
        file: path.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry),
      })
    } else {
      p.add(file)
    }
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@') {
      return t({
        file: path.resolve(p.cwd, file.slice(1)),
        noResume: true,
        onentry: entry => p.add(entry),
      }).then(_ => addFilesAsync(p, files))
    } else {
      p.add(file)
    }
  }
  p.end()
}

const createSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  addFilesSync(p, files)
  return p
}

const create = (opt, files) => {
  const p = new Pack(opt)
  addFilesAsync(p, files)
  return p
}


/***/ }),

/***/ 4831:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Get the appropriate flag to use for creating files
// We use fmap on Windows platforms for files less than
// 512kb.  This is a fairly low limit, but avoids making
// things slower in some cases.  Since most of what this
// library is used for is extracting tarballs of many
// relatively small files in npm packages and the like,
// it can be a big boost on Windows platforms.
// Only supported in Node v12.9.0 and above.
const platform = {}.__FAKE_PLATFORM__ || process.platform
const isWindows = platform === 'win32'
const fs = global.__FAKE_TESTING_FS__ || __webpack_require__(9896)

/* istanbul ignore next */
const { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants

const fMapEnabled = isWindows && !!UV_FS_O_FILEMAP
const fMapLimit = 512 * 1024
const fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY
module.exports = !fMapEnabled ? () => 'w'
  : size => size < fMapLimit ? fMapFlag : 'w'


/***/ }),

/***/ 4832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// XXX: This shares a lot in common with extract.js
// maybe some DRY opportunity here?

// tar -t
const hlo = __webpack_require__(1743)
const Parser = __webpack_require__(5009)
const fs = __webpack_require__(9896)
const fsm = __webpack_require__(5733)
const path = __webpack_require__(6928)
const stripSlash = __webpack_require__(8725)

module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function') {
    cb = opt_, files = null, opt_ = {}
  } else if (Array.isArray(opt_)) {
    files = opt_, opt_ = {}
  }

  if (typeof files === 'function') {
    cb = files, files = null
  }

  if (!files) {
    files = []
  } else {
    files = Array.from(files)
  }

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function') {
    throw new TypeError('callback not supported for sync tar functions')
  }

  if (!opt.file && typeof cb === 'function') {
    throw new TypeError('callback only supported with file option')
  }

  if (files.length) {
    filesFilter(opt, files)
  }

  if (!opt.noResume) {
    onentryFunction(opt)
  }

  return opt.file && opt.sync ? listFileSync(opt)
    : opt.file ? listFile(opt, cb)
    : list(opt)
}

const onentryFunction = opt => {
  const onentry = opt.onentry
  opt.onentry = onentry ? e => {
    onentry(e)
    e.resume()
  } : e => e.resume()
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [stripSlash(f), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))
    : file => mapHas(stripSlash(file))
}

const listFileSync = opt => {
  const p = list(opt)
  const file = opt.file
  let threw = true
  let fd
  try {
    const stat = fs.statSync(file)
    const readSize = opt.maxReadSize || 16 * 1024 * 1024
    if (stat.size < readSize) {
      p.end(fs.readFileSync(file))
    } else {
      let pos = 0
      const buf = Buffer.allocUnsafe(readSize)
      fd = fs.openSync(file, 'r')
      while (pos < stat.size) {
        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
        pos += bytesRead
        p.write(buf.slice(0, bytesRead))
      }
      p.end()
    }
    threw = false
  } finally {
    if (threw && fd) {
      try {
        fs.closeSync(fd)
      } catch (er) {}
    }
  }
}

const listFile = (opt, cb) => {
  const parse = new Parser(opt)
  const readSize = opt.maxReadSize || 16 * 1024 * 1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    parse.on('error', reject)
    parse.on('end', resolve)

    fs.stat(file, (er, stat) => {
      if (er) {
        reject(er)
      } else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size,
        })
        stream.on('error', reject)
        stream.pipe(parse)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const list = opt => new Parser(opt)


/***/ }),

/***/ 4921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(9896)

const version = {}.__TESTING_MKDIRP_NODE_VERSION__ || process.version
const versArr = version.replace(/^v/, '').split('.')
const hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12

const useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir
const useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync

module.exports = {useNative, useNativeSync}


/***/ }),

/***/ 5009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away

const warner = __webpack_require__(472)
const Header = __webpack_require__(877)
const EE = __webpack_require__(4434)
const Yallist = __webpack_require__(7841)
const maxMetaEntrySize = 1024 * 1024
const Entry = __webpack_require__(3009)
const Pax = __webpack_require__(8087)
const zlib = __webpack_require__(1857)
const { nextTick } = __webpack_require__(932)

const gzipHeader = Buffer.from([0x1f, 0x8b])
const STATE = Symbol('state')
const WRITEENTRY = Symbol('writeEntry')
const READENTRY = Symbol('readEntry')
const NEXTENTRY = Symbol('nextEntry')
const PROCESSENTRY = Symbol('processEntry')
const EX = Symbol('extendedHeader')
const GEX = Symbol('globalExtendedHeader')
const META = Symbol('meta')
const EMITMETA = Symbol('emitMeta')
const BUFFER = Symbol('buffer')
const QUEUE = Symbol('queue')
const ENDED = Symbol('ended')
const EMITTEDEND = Symbol('emittedEnd')
const EMIT = Symbol('emit')
const UNZIP = Symbol('unzip')
const CONSUMECHUNK = Symbol('consumeChunk')
const CONSUMECHUNKSUB = Symbol('consumeChunkSub')
const CONSUMEBODY = Symbol('consumeBody')
const CONSUMEMETA = Symbol('consumeMeta')
const CONSUMEHEADER = Symbol('consumeHeader')
const CONSUMING = Symbol('consuming')
const BUFFERCONCAT = Symbol('bufferConcat')
const MAYBEEND = Symbol('maybeEnd')
const WRITING = Symbol('writing')
const ABORTED = Symbol('aborted')
const DONE = Symbol('onDone')
const SAW_VALID_ENTRY = Symbol('sawValidEntry')
const SAW_NULL_BLOCK = Symbol('sawNullBlock')
const SAW_EOF = Symbol('sawEOF')
const CLOSESTREAM = Symbol('closeStream')

const noop = _ => true

module.exports = warner(class Parser extends EE {
  constructor (opt) {
    opt = opt || {}
    super(opt)

    this.file = opt.file || ''

    // set to boolean false when an entry starts.  1024 bytes of \0
    // is technically a valid tarball, albeit a boring one.
    this[SAW_VALID_ENTRY] = null

    // these BADARCHIVE errors can't be detected early. listen on DONE.
    this.on(DONE, _ => {
      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {
        // either less than 1 block of data, or all entries were invalid.
        // Either way, probably not even a tarball.
        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')
      }
    })

    if (opt.ondone) {
      this.on(DONE, opt.ondone)
    } else {
      this.on(DONE, _ => {
        this.emit('prefinish')
        this.emit('finish')
        this.emit('end')
      })
    }

    this.strict = !!opt.strict
    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize
    this.filter = typeof opt.filter === 'function' ? opt.filter : noop
    // Unlike gzip, brotli doesn't have any magic bytes to identify it
    // Users need to explicitly tell us they're extracting a brotli file
    // Or we infer from the file extension
    const isTBR = (opt.file && (
        opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')))
    // if it's a tbr file it MIGHT be brotli, but we don't know until
    // we look at it and verify it's not a valid tar file.
    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli
      : isTBR ? undefined
      : false

    // have to set this so that streams are ok piping into it
    this.writable = true
    this.readable = false

    this[QUEUE] = new Yallist()
    this[BUFFER] = null
    this[READENTRY] = null
    this[WRITEENTRY] = null
    this[STATE] = 'begin'
    this[META] = ''
    this[EX] = null
    this[GEX] = null
    this[ENDED] = false
    this[UNZIP] = null
    this[ABORTED] = false
    this[SAW_NULL_BLOCK] = false
    this[SAW_EOF] = false

    this.on('end', () => this[CLOSESTREAM]())

    if (typeof opt.onwarn === 'function') {
      this.on('warn', opt.onwarn)
    }
    if (typeof opt.onentry === 'function') {
      this.on('entry', opt.onentry)
    }
  }

  [CONSUMEHEADER] (chunk, position) {
    if (this[SAW_VALID_ENTRY] === null) {
      this[SAW_VALID_ENTRY] = false
    }
    let header
    try {
      header = new Header(chunk, position, this[EX], this[GEX])
    } catch (er) {
      return this.warn('TAR_ENTRY_INVALID', er)
    }

    if (header.nullBlock) {
      if (this[SAW_NULL_BLOCK]) {
        this[SAW_EOF] = true
        // ending an archive with no entries.  pointless, but legal.
        if (this[STATE] === 'begin') {
          this[STATE] = 'header'
        }
        this[EMIT]('eof')
      } else {
        this[SAW_NULL_BLOCK] = true
        this[EMIT]('nullBlock')
      }
    } else {
      this[SAW_NULL_BLOCK] = false
      if (!header.cksumValid) {
        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })
      } else if (!header.path) {
        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })
      } else {
        const type = header.type
        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })
        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })
        } else {
          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])

          // we do this for meta & ignored entries as well, because they
          // are still valid tar, or else we wouldn't know to ignore them
          if (!this[SAW_VALID_ENTRY]) {
            if (entry.remain) {
              // this might be the one!
              const onend = () => {
                if (!entry.invalid) {
                  this[SAW_VALID_ENTRY] = true
                }
              }
              entry.on('end', onend)
            } else {
              this[SAW_VALID_ENTRY] = true
            }
          }

          if (entry.meta) {
            if (entry.size > this.maxMetaEntrySize) {
              entry.ignore = true
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = 'ignore'
              entry.resume()
            } else if (entry.size > 0) {
              this[META] = ''
              entry.on('data', c => this[META] += c)
              this[STATE] = 'meta'
            }
          } else {
            this[EX] = null
            entry.ignore = entry.ignore || !this.filter(entry.path, entry)

            if (entry.ignore) {
              // probably valid, just not something we care about
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = entry.remain ? 'ignore' : 'header'
              entry.resume()
            } else {
              if (entry.remain) {
                this[STATE] = 'body'
              } else {
                this[STATE] = 'header'
                entry.end()
              }

              if (!this[READENTRY]) {
                this[QUEUE].push(entry)
                this[NEXTENTRY]()
              } else {
                this[QUEUE].push(entry)
              }
            }
          }
        }
      }
    }
  }

  [CLOSESTREAM] () {
    nextTick(() => this.emit('close'))
  }

  [PROCESSENTRY] (entry) {
    let go = true

    if (!entry) {
      this[READENTRY] = null
      go = false
    } else if (Array.isArray(entry)) {
      this.emit.apply(this, entry)
    } else {
      this[READENTRY] = entry
      this.emit('entry', entry)
      if (!entry.emittedEnd) {
        entry.on('end', _ => this[NEXTENTRY]())
        go = false
      }
    }

    return go
  }

  [NEXTENTRY] () {
    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))

    if (!this[QUEUE].length) {
      // At this point, there's nothing in the queue, but we may have an
      // entry which is being consumed (readEntry).
      // If we don't, then we definitely can handle more data.
      // If we do, and either it's flowing, or it has never had any data
      // written to it, then it needs more.
      // The only other possibility is that it has returned false from a
      // write() call, so we wait for the next drain to continue.
      const re = this[READENTRY]
      const drainNow = !re || re.flowing || re.size === re.remain
      if (drainNow) {
        if (!this[WRITING]) {
          this.emit('drain')
        }
      } else {
        re.once('drain', _ => this.emit('drain'))
      }
    }
  }

  [CONSUMEBODY] (chunk, position) {
    // write up to but no  more than writeEntry.blockRemain
    const entry = this[WRITEENTRY]
    const br = entry.blockRemain
    const c = (br >= chunk.length && position === 0) ? chunk
      : chunk.slice(position, position + br)

    entry.write(c)

    if (!entry.blockRemain) {
      this[STATE] = 'header'
      this[WRITEENTRY] = null
      entry.end()
    }

    return c.length
  }

  [CONSUMEMETA] (chunk, position) {
    const entry = this[WRITEENTRY]
    const ret = this[CONSUMEBODY](chunk, position)

    // if we finished, then the entry is reset
    if (!this[WRITEENTRY]) {
      this[EMITMETA](entry)
    }

    return ret
  }

  [EMIT] (ev, data, extra) {
    if (!this[QUEUE].length && !this[READENTRY]) {
      this.emit(ev, data, extra)
    } else {
      this[QUEUE].push([ev, data, extra])
    }
  }

  [EMITMETA] (entry) {
    this[EMIT]('meta', this[META])
    switch (entry.type) {
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this[EX] = Pax.parse(this[META], this[EX], false)
        break

      case 'GlobalExtendedHeader':
        this[GEX] = Pax.parse(this[META], this[GEX], true)
        break

      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].path = this[META].replace(/\0.*/, '')
        break

      case 'NextFileHasLongLinkpath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].linkpath = this[META].replace(/\0.*/, '')
        break

      /* istanbul ignore next */
      default: throw new Error('unknown meta: ' + entry.type)
    }
  }

  abort (error) {
    this[ABORTED] = true
    this.emit('abort', error)
    // always throws, even in non-strict mode
    this.warn('TAR_ABORT', error, { recoverable: false })
  }

  write (chunk) {
    if (this[ABORTED]) {
      return
    }

    // first write, might be gzipped
    const needSniff = this[UNZIP] === null ||
      this.brotli === undefined && this[UNZIP] === false
    if (needSniff && chunk) {
      if (this[BUFFER]) {
        chunk = Buffer.concat([this[BUFFER], chunk])
        this[BUFFER] = null
      }
      if (chunk.length < gzipHeader.length) {
        this[BUFFER] = chunk
        return true
      }

      // look for gzip header
      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
        if (chunk[i] !== gzipHeader[i]) {
          this[UNZIP] = false
        }
      }

      const maybeBrotli = this.brotli === undefined
      if (this[UNZIP] === false && maybeBrotli) {
        // read the first header to see if it's a valid tar file. If so,
        // we can safely assume that it's not actually brotli, despite the
        // .tbr or .tar.br file extension.
        // if we ended before getting a full chunk, yes, def brotli
        if (chunk.length < 512) {
          if (this[ENDED]) {
            this.brotli = true
          } else {
            this[BUFFER] = chunk
            return true
          }
        } else {
          // if it's tar, it's pretty reliably not brotli, chances of
          // that happening are astronomical.
          try {
            new Header(chunk.slice(0, 512))
            this.brotli = false
          } catch (_) {
            this.brotli = true
          }
        }
      }

      if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {
        const ended = this[ENDED]
        this[ENDED] = false
        this[UNZIP] = this[UNZIP] === null
          ? new zlib.Unzip()
          : new zlib.BrotliDecompress()
        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))
        this[UNZIP].on('error', er => this.abort(er))
        this[UNZIP].on('end', _ => {
          this[ENDED] = true
          this[CONSUMECHUNK]()
        })
        this[WRITING] = true
        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)
        this[WRITING] = false
        return ret
      }
    }

    this[WRITING] = true
    if (this[UNZIP]) {
      this[UNZIP].write(chunk)
    } else {
      this[CONSUMECHUNK](chunk)
    }
    this[WRITING] = false

    // return false if there's a queue, or if the current entry isn't flowing
    const ret =
      this[QUEUE].length ? false :
      this[READENTRY] ? this[READENTRY].flowing :
      true

    // if we have no queue, then that means a clogged READENTRY
    if (!ret && !this[QUEUE].length) {
      this[READENTRY].once('drain', _ => this.emit('drain'))
    }

    return ret
  }

  [BUFFERCONCAT] (c) {
    if (c && !this[ABORTED]) {
      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c
    }
  }

  [MAYBEEND] () {
    if (this[ENDED] &&
        !this[EMITTEDEND] &&
        !this[ABORTED] &&
        !this[CONSUMING]) {
      this[EMITTEDEND] = true
      const entry = this[WRITEENTRY]
      if (entry && entry.blockRemain) {
        // truncated, likely a damaged file
        const have = this[BUFFER] ? this[BUFFER].length : 0
        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${
          entry.blockRemain} more bytes, only ${have} available)`, { entry })
        if (this[BUFFER]) {
          entry.write(this[BUFFER])
        }
        entry.end()
      }
      this[EMIT](DONE)
    }
  }

  [CONSUMECHUNK] (chunk) {
    if (this[CONSUMING]) {
      this[BUFFERCONCAT](chunk)
    } else if (!chunk && !this[BUFFER]) {
      this[MAYBEEND]()
    } else {
      this[CONSUMING] = true
      if (this[BUFFER]) {
        this[BUFFERCONCAT](chunk)
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      } else {
        this[CONSUMECHUNKSUB](chunk)
      }

      while (this[BUFFER] &&
          this[BUFFER].length >= 512 &&
          !this[ABORTED] &&
          !this[SAW_EOF]) {
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      }
      this[CONSUMING] = false
    }

    if (!this[BUFFER] || this[ENDED]) {
      this[MAYBEEND]()
    }
  }

  [CONSUMECHUNKSUB] (chunk) {
    // we know that we are in CONSUMING mode, so anything written goes into
    // the buffer.  Advance the position and put any remainder in the buffer.
    let position = 0
    const length = chunk.length
    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
      switch (this[STATE]) {
        case 'begin':
        case 'header':
          this[CONSUMEHEADER](chunk, position)
          position += 512
          break

        case 'ignore':
        case 'body':
          position += this[CONSUMEBODY](chunk, position)
          break

        case 'meta':
          position += this[CONSUMEMETA](chunk, position)
          break

        /* istanbul ignore next */
        default:
          throw new Error('invalid state: ' + this[STATE])
      }
    }

    if (position < length) {
      if (this[BUFFER]) {
        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])
      } else {
        this[BUFFER] = chunk.slice(position)
      }
    }
  }

  end (chunk) {
    if (!this[ABORTED]) {
      if (this[UNZIP]) {
        this[UNZIP].end(chunk)
      } else {
        this[ENDED] = true
        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0)
        this.write(chunk)
      }
    }
  }
})


/***/ }),

/***/ 5401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const readWasm = __webpack_require__(9874);

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.lastGeneratedColumn = null;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

let cachedWasm = null;

module.exports = function wasm() {
  if (cachedWasm) {
    return cachedWasm;
  }

  const callbackStack = [];

  cachedWasm = readWasm().then(buffer => {
      return WebAssembly.instantiate(buffer, {
        env: {
          mapping_callback(
            generatedLine,
            generatedColumn,

            hasLastGeneratedColumn,
            lastGeneratedColumn,

            hasOriginal,
            source,
            originalLine,
            originalColumn,

            hasName,
            name
          ) {
            const mapping = new Mapping();
            // JS uses 1-based line numbers, wasm uses 0-based.
            mapping.generatedLine = generatedLine + 1;
            mapping.generatedColumn = generatedColumn;

            if (hasLastGeneratedColumn) {
              // JS uses inclusive last generated column, wasm uses exclusive.
              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
            }

            if (hasOriginal) {
              mapping.source = source;
              // JS uses 1-based line numbers, wasm uses 0-based.
              mapping.originalLine = originalLine + 1;
              mapping.originalColumn = originalColumn;

              if (hasName) {
                mapping.name = name;
              }
            }

            callbackStack[callbackStack.length - 1](mapping);
          },

          start_all_generated_locations_for() { console.time("all_generated_locations_for"); },
          end_all_generated_locations_for() { console.timeEnd("all_generated_locations_for"); },

          start_compute_column_spans() { console.time("compute_column_spans"); },
          end_compute_column_spans() { console.timeEnd("compute_column_spans"); },

          start_generated_location_for() { console.time("generated_location_for"); },
          end_generated_location_for() { console.timeEnd("generated_location_for"); },

          start_original_location_for() { console.time("original_location_for"); },
          end_original_location_for() { console.timeEnd("original_location_for"); },

          start_parse_mappings() { console.time("parse_mappings"); },
          end_parse_mappings() { console.timeEnd("parse_mappings"); },

          start_sort_by_generated_location() { console.time("sort_by_generated_location"); },
          end_sort_by_generated_location() { console.timeEnd("sort_by_generated_location"); },

          start_sort_by_original_location() { console.time("sort_by_original_location"); },
          end_sort_by_original_location() { console.timeEnd("sort_by_original_location"); },
        }
      });
  }).then(Wasm => {
    return {
      exports: Wasm.instance.exports,
      withMappingCallback: (mappingCallback, f) => {
        callbackStack.push(mappingCallback);
        try {
          f();
        } finally {
          callbackStack.pop();
        }
      }
    };
  }).then(null, e => {
    cachedWasm = null;
    throw e;
  });

  return cachedWasm;
};


/***/ }),

/***/ 5571:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { promisify } = __webpack_require__(9023)
const fs = __webpack_require__(9896)
const optsArg = opts => {
  if (!opts)
    opts = { mode: 0o777, fs }
  else if (typeof opts === 'object')
    opts = { mode: 0o777, fs, ...opts }
  else if (typeof opts === 'number')
    opts = { mode: opts, fs }
  else if (typeof opts === 'string')
    opts = { mode: parseInt(opts, 8), fs }
  else
    throw new TypeError('invalid options argument')

  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir
  opts.mkdirAsync = promisify(opts.mkdir)
  opts.stat = opts.stat || opts.fs.stat || fs.stat
  opts.statAsync = promisify(opts.stat)
  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync
  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync
  return opts
}
module.exports = optsArg


/***/ }),

/***/ 5677:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}
var B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};
E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;
H.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
function N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}
var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};function X(){throw Error("act(...) is not supported in production builds of React.");}
exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;exports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;exports.act=X;
exports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};
exports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=X;exports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};
exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};exports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};
exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};exports.useTransition=function(){return U.current.useTransition()};exports.version="18.3.1";


/***/ }),

/***/ 5733:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const MiniPass = __webpack_require__(8607)
const EE = (__webpack_require__(4434).EventEmitter)
const fs = __webpack_require__(9896)

let writev = fs.writev
/* istanbul ignore next */
if (!writev) {
  // This entire block can be removed if support for earlier than Node.js
  // 12.9.0 is not needed.
  const binding = process.binding('fs')
  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback

  writev = (fd, iovec, pos, cb) => {
    const done = (er, bw) => cb(er, bw, iovec)
    const req = new FSReqWrap()
    req.oncomplete = done
    binding.writeBuffers(fd, iovec, pos, req)
  }
}

const _autoClose = Symbol('_autoClose')
const _close = Symbol('_close')
const _ended = Symbol('_ended')
const _fd = Symbol('_fd')
const _finished = Symbol('_finished')
const _flags = Symbol('_flags')
const _flush = Symbol('_flush')
const _handleChunk = Symbol('_handleChunk')
const _makeBuf = Symbol('_makeBuf')
const _mode = Symbol('_mode')
const _needDrain = Symbol('_needDrain')
const _onerror = Symbol('_onerror')
const _onopen = Symbol('_onopen')
const _onread = Symbol('_onread')
const _onwrite = Symbol('_onwrite')
const _open = Symbol('_open')
const _path = Symbol('_path')
const _pos = Symbol('_pos')
const _queue = Symbol('_queue')
const _read = Symbol('_read')
const _readSize = Symbol('_readSize')
const _reading = Symbol('_reading')
const _remain = Symbol('_remain')
const _size = Symbol('_size')
const _write = Symbol('_write')
const _writing = Symbol('_writing')
const _defaultFlag = Symbol('_defaultFlag')
const _errored = Symbol('_errored')

class ReadStream extends MiniPass {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)

    this.readable = true
    this.writable = false

    if (typeof path !== 'string')
      throw new TypeError('path must be a string')

    this[_errored] = false
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_path] = path
    this[_readSize] = opt.readSize || 16*1024*1024
    this[_reading] = false
    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity
    this[_remain] = this[_size]
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    if (typeof this[_fd] === 'number')
      this[_read]()
    else
      this[_open]()
  }

  get fd () { return this[_fd] }
  get path () { return this[_path] }

  write () {
    throw new TypeError('this is a readable stream')
  }

  end () {
    throw new TypeError('this is a readable stream')
  }

  [_open] () {
    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_read]()
    }
  }

  [_makeBuf] () {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))
  }

  [_read] () {
    if (!this[_reading]) {
      this[_reading] = true
      const buf = this[_makeBuf]()
      /* istanbul ignore if */
      if (buf.length === 0)
        return process.nextTick(() => this[_onread](null, 0, buf))
      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>
        this[_onread](er, br, buf))
    }
  }

  [_onread] (er, br, buf) {
    this[_reading] = false
    if (er)
      this[_onerror](er)
    else if (this[_handleChunk](br, buf))
      this[_read]()
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))
    }
  }

  [_onerror] (er) {
    this[_reading] = true
    this[_close]()
    this.emit('error', er)
  }

  [_handleChunk] (br, buf) {
    let ret = false
    // no effect if infinite
    this[_remain] -= br
    if (br > 0)
      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)

    if (br === 0 || this[_remain] <= 0) {
      ret = false
      this[_close]()
      super.end()
    }

    return ret
  }

  emit (ev, data) {
    switch (ev) {
      case 'prefinish':
      case 'finish':
        break

      case 'drain':
        if (typeof this[_fd] === 'number')
          this[_read]()
        break

      case 'error':
        if (this[_errored])
          return
        this[_errored] = true
        return super.emit(ev, data)

      default:
        return super.emit(ev, data)
    }
  }
}

class ReadStreamSync extends ReadStream {
  [_open] () {
    let threw = true
    try {
      this[_onopen](null, fs.openSync(this[_path], 'r'))
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_read] () {
    let threw = true
    try {
      if (!this[_reading]) {
        this[_reading] = true
        do {
          const buf = this[_makeBuf]()
          /* istanbul ignore next */
          const br = buf.length === 0 ? 0
            : fs.readSync(this[_fd], buf, 0, buf.length, null)
          if (!this[_handleChunk](br, buf))
            break
        } while (true)
        this[_reading] = false
      }
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.closeSync(fd)
      this.emit('close')
    }
  }
}

class WriteStream extends EE {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)
    this.readable = false
    this.writable = true
    this[_errored] = false
    this[_writing] = false
    this[_ended] = false
    this[_needDrain] = false
    this[_queue] = []
    this[_path] = path
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode
    this[_pos] = typeof opt.start === 'number' ? opt.start : null
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    // truncating makes no sense when writing into the middle
    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'
    this[_defaultFlag] = opt.flags === undefined
    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags

    if (this[_fd] === null)
      this[_open]()
  }

  emit (ev, data) {
    if (ev === 'error') {
      if (this[_errored])
        return
      this[_errored] = true
    }
    return super.emit(ev, data)
  }


  get fd () { return this[_fd] }
  get path () { return this[_path] }

  [_onerror] (er) {
    this[_close]()
    this[_writing] = true
    this.emit('error', er)
  }

  [_open] () {
    fs.open(this[_path], this[_flags], this[_mode],
      (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (this[_defaultFlag] &&
        this[_flags] === 'r+' &&
        er && er.code === 'ENOENT') {
      this[_flags] = 'w'
      this[_open]()
    } else if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_flush]()
    }
  }

  end (buf, enc) {
    if (buf)
      this.write(buf, enc)

    this[_ended] = true

    // synthetic after-write logic, where drain/finish live
    if (!this[_writing] && !this[_queue].length &&
        typeof this[_fd] === 'number')
      this[_onwrite](null, 0)
    return this
  }

  write (buf, enc) {
    if (typeof buf === 'string')
      buf = Buffer.from(buf, enc)

    if (this[_ended]) {
      this.emit('error', new Error('write() after end()'))
      return false
    }

    if (this[_fd] === null || this[_writing] || this[_queue].length) {
      this[_queue].push(buf)
      this[_needDrain] = true
      return false
    }

    this[_writing] = true
    this[_write](buf)
    return true
  }

  [_write] (buf) {
    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>
      this[_onwrite](er, bw))
  }

  [_onwrite] (er, bw) {
    if (er)
      this[_onerror](er)
    else {
      if (this[_pos] !== null)
        this[_pos] += bw
      if (this[_queue].length)
        this[_flush]()
      else {
        this[_writing] = false

        if (this[_ended] && !this[_finished]) {
          this[_finished] = true
          this[_close]()
          this.emit('finish')
        } else if (this[_needDrain]) {
          this[_needDrain] = false
          this.emit('drain')
        }
      }
    }
  }

  [_flush] () {
    if (this[_queue].length === 0) {
      if (this[_ended])
        this[_onwrite](null, 0)
    } else if (this[_queue].length === 1)
      this[_write](this[_queue].pop())
    else {
      const iovec = this[_queue]
      this[_queue] = []
      writev(this[_fd], iovec, this[_pos],
        (er, bw) => this[_onwrite](er, bw))
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))
    }
  }
}

class WriteStreamSync extends WriteStream {
  [_open] () {
    let fd
    // only wrap in a try{} block if we know we'll retry, to avoid
    // the rethrow obscuring the error's source frame in most cases.
    if (this[_defaultFlag] && this[_flags] === 'r+') {
      try {
        fd = fs.openSync(this[_path], this[_flags], this[_mode])
      } catch (er) {
        if (er.code === 'ENOENT') {
          this[_flags] = 'w'
          return this[_open]()
        } else
          throw er
      }
    } else
      fd = fs.openSync(this[_path], this[_flags], this[_mode])

    this[_onopen](null, fd)
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.closeSync(fd)
      this.emit('close')
    }
  }

  [_write] (buf) {
    // throw the original, but try to close if it fails
    let threw = true
    try {
      this[_onwrite](null,
        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))
      threw = false
    } finally {
      if (threw)
        try { this[_close]() } catch (_) {}
    }
  }
}

exports.ReadStream = ReadStream
exports.ReadStreamSync = ReadStreamSync

exports.WriteStream = WriteStream
exports.WriteStreamSync = WriteStreamSync


/***/ }),

/***/ 5823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A path exclusive reservation system
// reserve([list, of, paths], fn)
// When the fn is first in line for all its paths, it
// is called with a cb that clears the reservation.
//
// Used by async unpack to avoid clobbering paths in use,
// while still allowing maximal safe parallelization.

const assert = __webpack_require__(2613)
const normalize = __webpack_require__(5995)
const stripSlashes = __webpack_require__(8725)
const { join } = __webpack_require__(6928)

const platform = {}.TESTING_TAR_FAKE_PLATFORM || process.platform
const isWindows = platform === 'win32'

module.exports = () => {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  const queues = new Map()

  // fn => {paths:[path,...], dirs:[path, ...]}
  const reservations = new Map()

  // return a set of parent dirs for a given path
  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']
  const getDirs = path => {
    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {
      if (set.length) {
        path = join(set[set.length - 1], path)
      }
      set.push(path || '/')
      return set
    }, [])
    return dirs
  }

  // functions currently running
  const running = new Set()

  // return the queues for each path the function cares about
  // fn => {paths, dirs}
  const getQueues = fn => {
    const res = reservations.get(fn)
    /* istanbul ignore if - unpossible */
    if (!res) {
      throw new Error('function does not have any path reservations')
    }
    return {
      paths: res.paths.map(path => queues.get(path)),
      dirs: [...res.dirs].map(path => queues.get(path)),
    }
  }

  // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues
  const check = fn => {
    const { paths, dirs } = getQueues(fn)
    return paths.every(q => q[0] === fn) &&
      dirs.every(q => q[0] instanceof Set && q[0].has(fn))
  }

  // run the function if it's first in line and not already running
  const run = fn => {
    if (running.has(fn) || !check(fn)) {
      return false
    }
    running.add(fn)
    fn(() => clear(fn))
    return true
  }

  const clear = fn => {
    if (!running.has(fn)) {
      return false
    }

    const { paths, dirs } = reservations.get(fn)
    const next = new Set()

    paths.forEach(path => {
      const q = queues.get(path)
      assert.equal(q[0], fn)
      if (q.length === 1) {
        queues.delete(path)
      } else {
        q.shift()
        if (typeof q[0] === 'function') {
          next.add(q[0])
        } else {
          q[0].forEach(fn => next.add(fn))
        }
      }
    })

    dirs.forEach(dir => {
      const q = queues.get(dir)
      assert(q[0] instanceof Set)
      if (q[0].size === 1 && q.length === 1) {
        queues.delete(dir)
      } else if (q[0].size === 1) {
        q.shift()

        // must be a function or else the Set would've been reused
        next.add(q[0])
      } else {
        q[0].delete(fn)
      }
    })
    running.delete(fn)

    next.forEach(fn => run(fn))
    return true
  }

  const reserve = (paths, fn) => {
    // collide on matches across case and unicode normalization
    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally
    // impossible to determine whether two paths refer to the same thing on
    // disk, without asking the kernel for a shortname.
    // So, we just pretend that every path matches every other path here,
    // effectively removing all parallelization on windows.
    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {
      // don't need normPath, because we skip this entirely for windows
      return stripSlashes(join(normalize(p))).toLowerCase()
    })

    const dirs = new Set(
      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))
    )
    reservations.set(fn, { dirs, paths })
    paths.forEach(path => {
      const q = queues.get(path)
      if (!q) {
        queues.set(path, [fn])
      } else {
        q.push(fn)
      }
    })
    dirs.forEach(dir => {
      const q = queues.get(dir)
      if (!q) {
        queues.set(dir, [new Set([fn])])
      } else if (q[q.length - 1] instanceof Set) {
        q[q.length - 1].add(fn)
      } else {
        q.push(new Set([fn]))
      }
    })

    return run(fn)
  }

  return { check, reserve }
}


/***/ }),

/***/ 5904:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const proc =
  typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
      }
const EE = __webpack_require__(4434)
const Stream = __webpack_require__(2203)
const stringdecoder = __webpack_require__(3193)
const SD = stringdecoder.StringDecoder

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const EMITTED_ERROR = Symbol('emittedError')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFER = Symbol('buffer')
const PIPES = Symbol('pipes')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed')
// internal event when stream has an error
const ERROR = Symbol('error')
const EMITDATA = Symbol('emitData')
const EMITEND = Symbol('emitEnd')
const EMITEND2 = Symbol('emitEnd2')
const ASYNC = Symbol('async')
const ABORT = Symbol('abort')
const ABORTED = Symbol('aborted')
const SIGNAL = Symbol('signal')

const defer = fn => Promise.resolve().then(fn)

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'
const ASYNCITERATOR =
  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')
const ITERATOR =
  (doIter && Symbol.iterator) || Symbol('iterator not implemented')

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'

const isArrayBuffer = b =>
  b instanceof ArrayBuffer ||
  (typeof b === 'object' &&
    b.constructor &&
    b.constructor.name === 'ArrayBuffer' &&
    b.byteLength >= 0)

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

class Pipe {
  constructor(src, dest, opts) {
    this.src = src
    this.dest = dest
    this.opts = opts
    this.ondrain = () => src[RESUME]()
    dest.on('drain', this.ondrain)
  }
  unpipe() {
    this.dest.removeListener('drain', this.ondrain)
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors() {}
  end() {
    this.unpipe()
    if (this.opts.end) this.dest.end()
  }
}

class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener('error', this.proxyErrors)
    super.unpipe()
  }
  constructor(src, dest, opts) {
    super(src, dest, opts)
    this.proxyErrors = er => dest.emit('error', er)
    src.on('error', this.proxyErrors)
  }
}

class Minipass extends Stream {
  constructor(options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this[PIPES] = []
    this[BUFFER] = []
    this[OBJECTMODE] = (options && options.objectMode) || false
    if (this[OBJECTMODE]) this[ENCODING] = null
    else this[ENCODING] = (options && options.encoding) || null
    if (this[ENCODING] === 'buffer') this[ENCODING] = null
    this[ASYNC] = (options && !!options.async) || false
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this[EMITTED_ERROR] = null
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })
    }
    this[SIGNAL] = options && options.signal
    this[ABORTED] = false
    if (this[SIGNAL]) {
      this[SIGNAL].addEventListener('abort', () => this[ABORT]())
      if (this[SIGNAL].aborted) {
        this[ABORT]()
      }
    }
  }

  get bufferLength() {
    return this[BUFFERLENGTH]
  }

  get encoding() {
    return this[ENCODING]
  }
  set encoding(enc) {
    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')

    if (
      this[ENCODING] &&
      enc !== this[ENCODING] &&
      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
    )
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this[BUFFER].length)
        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding(enc) {
    this.encoding = enc
  }

  get objectMode() {
    return this[OBJECTMODE]
  }
  set objectMode(om) {
    this[OBJECTMODE] = this[OBJECTMODE] || !!om
  }

  get ['async']() {
    return this[ASYNC]
  }
  set ['async'](a) {
    this[ASYNC] = this[ASYNC] || !!a
  }

  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true
    this.emit('abort', this[SIGNAL].reason)
    this.destroy(this[SIGNAL].reason)
  }

  get aborted() {
    return this[ABORTED]
  }
  set aborted(_) {}

  write(chunk, encoding, cb) {
    if (this[ABORTED]) return false
    if (this[EOF]) throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit(
        'error',
        Object.assign(
          new Error('Cannot call write after a stream was destroyed'),
          { code: 'ERR_STREAM_DESTROYED' }
        )
      )
      return true
    }

    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')

    if (!encoding) encoding = 'utf8'

    const fn = this[ASYNC] ? defer : f => f()

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)

      if (this.flowing) this.emit('data', chunk)
      else this[BUFFERPUSH](chunk)

      if (this[BUFFERLENGTH] !== 0) this.emit('readable')

      if (cb) fn(cb)

      return this.flowing
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0) this.emit('readable')
      if (cb) fn(cb)
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (
      typeof chunk === 'string' &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
    ) {
      chunk = Buffer.from(chunk, encoding)
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)

    if (this.flowing) this.emit('data', chunk)
    else this[BUFFERPUSH](chunk)

    if (this[BUFFERLENGTH] !== 0) this.emit('readable')

    if (cb) fn(cb)

    return this.flowing
  }

  read(n) {
    if (this[DESTROYED]) return null

    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]()
      return null
    }

    if (this[OBJECTMODE]) n = null

    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]
      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]
    }

    const ret = this[READ](n || null, this[BUFFER][0])
    this[MAYBE_EMIT_END]()
    return ret
  }

  [READ](n, chunk) {
    if (n === chunk.length || n === null) this[BUFFERSHIFT]()
    else {
      this[BUFFER][0] = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')

    return chunk
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') (cb = chunk), (chunk = null)
    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')
    if (chunk) this.write(chunk, encoding)
    if (cb) this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED]) return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this[BUFFER].length) this[FLUSH]()
    else if (this[EOF]) this[MAYBE_EMIT_END]()
    else this.emit('drain')
  }

  resume() {
    return this[RESUME]()
  }

  pause() {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed() {
    return this[DESTROYED]
  }

  get flowing() {
    return this[FLOWING]
  }

  get paused() {
    return this[PAUSED]
  }

  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1
    else this[BUFFERLENGTH] += chunk.length
    this[BUFFER].push(chunk)
  }

  [BUFFERSHIFT]() {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1
    else this[BUFFERLENGTH] -= this[BUFFER][0].length
    return this[BUFFER].shift()
  }

  [FLUSH](noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)

    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')
  }

  [FLUSHCHUNK](chunk) {
    this.emit('data', chunk)
    return this.flowing
  }

  pipe(dest, opts) {
    if (this[DESTROYED]) return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === proc.stdout || dest === proc.stderr) opts.end = false
    else opts.end = opts.end !== false
    opts.proxyErrors = !!opts.proxyErrors

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end) dest.end()
    } else {
      this[PIPES].push(
        !opts.proxyErrors
          ? new Pipe(this, dest, opts)
          : new PipeProxyErrors(this, dest, opts)
      )
      if (this[ASYNC]) defer(() => this[RESUME]())
      else this[RESUME]()
    }

    return dest
  }

  unpipe(dest) {
    const p = this[PIPES].find(p => p.dest === dest)
    if (p) {
      this[PIPES].splice(this[PIPES].indexOf(p), 1)
      p.unpipe()
    }
  }

  addListener(ev, fn) {
    return this.on(ev, fn)
  }

  on(ev, fn) {
    const ret = super.on(ev, fn)
    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()
    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)
      super.emit('readable')
    else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev)
      this.removeAllListeners(ev)
    } else if (ev === 'error' && this[EMITTED_ERROR]) {
      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))
      else fn.call(this, this[EMITTED_ERROR])
    }
    return ret
  }

  get emittedEnd() {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END]() {
    if (
      !this[EMITTING_END] &&
      !this[EMITTED_END] &&
      !this[DESTROYED] &&
      this[BUFFER].length === 0 &&
      this[EOF]
    ) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED]) this.emit('close')
      this[EMITTING_END] = false
    }
  }

  emit(ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      return !this[OBJECTMODE] && !data
        ? false
        : this[ASYNC]
        ? defer(() => this[EMITDATA](data))
        : this[EMITDATA](data)
    } else if (ev === 'end') {
      return this[EMITEND]()
    } else if (ev === 'close') {
      this[CLOSED] = true
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED]) return
      const ret = super.emit('close')
      this.removeAllListeners('close')
      return ret
    } else if (ev === 'error') {
      this[EMITTED_ERROR] = data
      super.emit(ERROR, data)
      const ret =
        !this[SIGNAL] || this.listeners('error').length
          ? super.emit('error', data)
          : false
      this[MAYBE_EMIT_END]()
      return ret
    } else if (ev === 'resume') {
      const ret = super.emit('resume')
      this[MAYBE_EMIT_END]()
      return ret
    } else if (ev === 'finish' || ev === 'prefinish') {
      const ret = super.emit(ev)
      this.removeAllListeners(ev)
      return ret
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra)
    this[MAYBE_EMIT_END]()
    return ret
  }

  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false) this.pause()
    }
    const ret = super.emit('data', data)
    this[MAYBE_EMIT_END]()
    return ret
  }

  [EMITEND]() {
    if (this[EMITTED_END]) return

    this[EMITTED_END] = true
    this.readable = false
    if (this[ASYNC]) defer(() => this[EMITEND2]())
    else this[EMITEND2]()
  }

  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end()
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data)
        }
        super.emit('data', data)
      }
    }

    for (const p of this[PIPES]) {
      p.end()
    }
    const ret = super.emit('end')
    this.removeAllListeners('end')
    return ret
  }

  // const all = await stream.collect()
  collect() {
    const buf = []
    if (!this[OBJECTMODE]) buf.dataLength = 0
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise()
    this.on('data', c => {
      buf.push(c)
      if (!this[OBJECTMODE]) buf.dataLength += c.length
    })
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat() {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength)
        )
  }

  // stream.promise().then(() => done, er => emitted error)
  promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')))
      this.on('error', er => reject(er))
      this.on('end', () => resolve())
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR]() {
    let stopped = false
    const stop = () => {
      this.pause()
      stopped = true
      return Promise.resolve({ done: true })
    }
    const next = () => {
      if (stopped) return stop()
      const res = this.read()
      if (res !== null) return Promise.resolve({ done: false, value: res })

      if (this[EOF]) return stop()

      let resolve = null
      let reject = null
      const onerr = er => {
        this.removeListener('data', ondata)
        this.removeListener('end', onend)
        this.removeListener(DESTROYED, ondestroy)
        stop()
        reject(er)
      }
      const ondata = value => {
        this.removeListener('error', onerr)
        this.removeListener('end', onend)
        this.removeListener(DESTROYED, ondestroy)
        this.pause()
        resolve({ value: value, done: !!this[EOF] })
      }
      const onend = () => {
        this.removeListener('error', onerr)
        this.removeListener('data', ondata)
        this.removeListener(DESTROYED, ondestroy)
        stop()
        resolve({ done: true })
      }
      const ondestroy = () => onerr(new Error('stream destroyed'))
      return new Promise((res, rej) => {
        reject = rej
        resolve = res
        this.once(DESTROYED, ondestroy)
        this.once('error', onerr)
        this.once('end', onend)
        this.once('data', ondata)
      })
    }

    return {
      next,
      throw: stop,
      return: stop,
      [ASYNCITERATOR]() {
        return this
      },
    }
  }

  // for (let chunk of stream)
  [ITERATOR]() {
    let stopped = false
    const stop = () => {
      this.pause()
      this.removeListener(ERROR, stop)
      this.removeListener(DESTROYED, stop)
      this.removeListener('end', stop)
      stopped = true
      return { done: true }
    }

    const next = () => {
      if (stopped) return stop()
      const value = this.read()
      return value === null ? stop() : { value }
    }
    this.once('end', stop)
    this.once(ERROR, stop)
    this.once(DESTROYED, stop)

    return {
      next,
      throw: stop,
      return: stop,
      [ITERATOR]() {
        return this
      },
    }
  }

  destroy(er) {
    if (this[DESTROYED]) {
      if (er) this.emit('error', er)
      else this.emit(DESTROYED)
      return this
    }

    this[DESTROYED] = true

    // throw away all buffered data, it's never coming out
    this[BUFFER].length = 0
    this[BUFFERLENGTH] = 0

    if (typeof this.close === 'function' && !this[CLOSED]) this.close()

    if (er) this.emit('error', er)
    // if no error to emit, still reject pending promises
    else this.emit(DESTROYED)

    return this
  }

  static isStream(s) {
    return (
      !!s &&
      (s instanceof Minipass ||
        s instanceof Stream ||
        (s instanceof EE &&
          // readable
          (typeof s.pipe === 'function' ||
            // writable
            (typeof s.write === 'function' && typeof s.end === 'function'))))
    )
  }
}

exports.Minipass = Minipass


/***/ }),

/***/ 5995:
/***/ ((module) => {

// warning: extremely hot code path.
// This has been meticulously optimized for use
// within npm install on large package trees.
// Do not edit without careful benchmarking.
const normalizeCache = Object.create(null)
const { hasOwnProperty } = Object.prototype
module.exports = s => {
  if (!hasOwnProperty.call(normalizeCache, s)) {
    normalizeCache[s] = s.normalize('NFD')
  }
  return normalizeCache[s]
}


/***/ }),

/***/ 6365:
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = "production" !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;


/***/ }),

/***/ 6425:
/***/ ((module) => {

"use strict";

module.exports = (mode, isDir, portable) => {
  mode &= 0o7777

  // in portable mode, use the minimum reasonable umask
  // if this system creates files with 0o664 by default
  // (as some linux distros do), then we'll write the
  // archive with 0o644 instead.  Also, don't ever create
  // a file that is not readable/writable by the owner.
  if (portable) {
    mode = (mode | 0o600) & ~0o22
  }

  // if dirs are readable, then they should be listable
  if (isDir) {
    if (mode & 0o400) {
      mode |= 0o100
    }
    if (mode & 0o40) {
      mode |= 0o10
    }
    if (mode & 0o4) {
      mode |= 0o1
    }
  }
  return mode
}


/***/ }),

/***/ 6543:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// map types from key to human-friendly name
exports.name = new Map([
  ['0', 'File'],
  // same as File
  ['', 'OldFile'],
  ['1', 'Link'],
  ['2', 'SymbolicLink'],
  // Devices and FIFOs aren't fully supported
  // they are parsed, but skipped when unpacking
  ['3', 'CharacterDevice'],
  ['4', 'BlockDevice'],
  ['5', 'Directory'],
  ['6', 'FIFO'],
  // same as File
  ['7', 'ContiguousFile'],
  // pax headers
  ['g', 'GlobalExtendedHeader'],
  ['x', 'ExtendedHeader'],
  // vendor-specific stuff
  // skip
  ['A', 'SolarisACL'],
  // like 5, but with data, which should be skipped
  ['D', 'GNUDumpDir'],
  // metadata only, skip
  ['I', 'Inode'],
  // data = link path of next file
  ['K', 'NextFileHasLongLinkpath'],
  // data = path of next file
  ['L', 'NextFileHasLongPath'],
  // skip
  ['M', 'ContinuationFile'],
  // like L
  ['N', 'OldGnuLongPath'],
  // skip
  ['S', 'SparseFile'],
  // skip
  ['V', 'TapeVolumeHeader'],
  // like x
  ['X', 'OldExtendedHeader'],
])

// map the other direction
exports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))


/***/ }),

/***/ 6559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -x
const hlo = __webpack_require__(1743)
const Unpack = __webpack_require__(8646)
const fs = __webpack_require__(9896)
const fsm = __webpack_require__(5733)
const path = __webpack_require__(6928)
const stripSlash = __webpack_require__(8725)

module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function') {
    cb = opt_, files = null, opt_ = {}
  } else if (Array.isArray(opt_)) {
    files = opt_, opt_ = {}
  }

  if (typeof files === 'function') {
    cb = files, files = null
  }

  if (!files) {
    files = []
  } else {
    files = Array.from(files)
  }

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function') {
    throw new TypeError('callback not supported for sync tar functions')
  }

  if (!opt.file && typeof cb === 'function') {
    throw new TypeError('callback only supported with file option')
  }

  if (files.length) {
    filesFilter(opt, files)
  }

  return opt.file && opt.sync ? extractFileSync(opt)
    : opt.file ? extractFile(opt, cb)
    : opt.sync ? extractSync(opt)
    : extract(opt)
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [stripSlash(f), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))
    : file => mapHas(stripSlash(file))
}

const extractFileSync = opt => {
  const u = new Unpack.Sync(opt)

  const file = opt.file
  const stat = fs.statSync(file)
  // This trades a zero-byte read() syscall for a stat
  // However, it will usually result in less memory allocation
  const readSize = opt.maxReadSize || 16 * 1024 * 1024
  const stream = new fsm.ReadStreamSync(file, {
    readSize: readSize,
    size: stat.size,
  })
  stream.pipe(u)
}

const extractFile = (opt, cb) => {
  const u = new Unpack(opt)
  const readSize = opt.maxReadSize || 16 * 1024 * 1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    u.on('error', reject)
    u.on('close', resolve)

    // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation
    fs.stat(file, (er, stat) => {
      if (er) {
        reject(er)
      } else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size,
        })
        stream.on('error', reject)
        stream.pipe(u)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const extractSync = opt => new Unpack.Sync(opt)

const extract = opt => new Unpack(opt)


/***/ }),

/***/ 6700:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const util = __webpack_require__(7061);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  const lineA = mappingA.generatedLine;
  const lineB = mappingB.generatedLine;
  const columnA = mappingA.generatedColumn;
  const columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a negligible overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
class MappingList {
  constructor() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  unsortedForEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  }

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  }
}

exports.P = MappingList;


/***/ }),

/***/ 6928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 6982:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 6991:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const base64VLQ = __webpack_require__(4286);
const util = __webpack_require__(7061);
const ArraySet = (__webpack_require__(1793)/* .ArraySet */ .C);
const MappingList = (__webpack_require__(6700)/* .MappingList */ .P);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
class SourceMapGenerator {
  constructor(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  static fromSourceMap(aSourceMapConsumer) {
    const sourceRoot = aSourceMapConsumer.sourceRoot;
    const generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      const newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      let sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      const content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  }

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  addMapping(aArgs) {
    const generated = util.getArg(aArgs, "generated");
    const original = util.getArg(aArgs, "original", null);
    let source = util.getArg(aArgs, "source", null);
    let name = util.getArg(aArgs, "name", null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  }

  /**
   * Set the source content for a source file.
   */
  setSourceContent(aSourceFile, aSourceContent) {
    let source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  }

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    let sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    const sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    const newSources = this._mappings.toArray().length > 0
      ? new ArraySet()
      : this._sources;
    const newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        const original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      const source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      const name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(srcFile) {
      const content = aSourceMapConsumer.sourceContentFor(srcFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          srcFile = util.join(aSourceMapPath, srcFile);
        }
        if (sourceRoot != null) {
          srcFile = util.relative(sourceRoot, srcFile);
        }
        this.setSourceContent(srcFile, content);
      }
    }, this);
  }

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  _validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit " +
            "the original mapping entirely and only map the generated position. If so, pass " +
            "null for the original mapping instead of an object with empty or null values."
        );
    }

    if (aGenerated && "line" in aGenerated && "column" in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.

    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated
             && aOriginal && "line" in aOriginal && "column" in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.

    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  _serializeMappings() {
    let previousGeneratedColumn = 0;
    let previousGeneratedLine = 1;
    let previousOriginalColumn = 0;
    let previousOriginalLine = 0;
    let previousName = 0;
    let previousSource = 0;
    let result = "";
    let next;
    let mapping;
    let nameIdx;
    let sourceIdx;

    const mappings = this._mappings.toArray();
    for (let i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ",";
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  }

  _generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      const key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  }

  /**
   * Externalize the source map.
   */
  toJSON() {
    const map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  }

  /**
   * Render the source map being generated to a string.
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
}

SourceMapGenerator.prototype._version = 3;
exports.x = SourceMapGenerator;


/***/ }),

/***/ 7045:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(7810),ca=__webpack_require__(2328);function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b)}
function ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}
var ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la=
{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});
["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,
sa);z[b]=new v(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});
z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});
function ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}
var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");
var Ia=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return"function"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La=b&&b[1]||""}return"\n"+La+a}var Na=!1;
function Oa(a,b){if(!a||Na)return"";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Ma(a):""}
function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return""}}
function Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||"Context")+".Consumer";case Ba:return(a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||
b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}
function Ra(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return"Offscreen";
case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}
function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,!1)}
function bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var eb=Array.isArray;
function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}
function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}
function lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var mb,nb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,
zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}
function sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}
function vb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}
function Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==
typeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}
function Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}
function Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}
var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}
var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;
function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
default:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}
function vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}
function wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}
function Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId)}}
function Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),!0;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),!0;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}
function Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}
function Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}
function ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}
function bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;
function ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}
function fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;
function Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}
function jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
case "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}
function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}
function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}
var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}
var Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;
function ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}
function ve(a,b){if("change"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}
function Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;
function Ie(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}
var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;
function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}
function Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};
ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);
ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}
function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}
function D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf("selectionchange",!1,b))}}
function pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}
function hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];
a:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==
n&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=
vf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
xa.controlled&&"number"===h.type&&cb(h,"number",h.value)}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),
0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return("string"===typeof a?a:""+a).replace(xf,"\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}
var Cf=null,Df=null;function Ef(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}
function Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
function Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;
function Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}
function E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
function Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||"Unknown",e));return A({},c,d)}
function cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}
function jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}
function ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;
function Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}
function Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=
null,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}
function Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}yg=
null}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;
function Lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}
function Mg(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ng(a){var b=a._init;return b(a._payload)}
function Og(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Pg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Qg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&Ng(f)===b.type))return d=e(b,c.props),d.ref=Lg(a,b,c),d.return=a,d;d=Rg(c.type,c.key,c.props,null,a.mode,d);d.ref=Lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=Sg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Tg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=Qg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=Rg(b.type,b.key,b.props,null,a.mode,c),
c.ref=Lg(a,null,b),c.return=a,c;case wa:return b=Sg(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Tg(b,a.mode,c,null),b.return=a,b;Mg(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,
b,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);Mg(a,c)}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);Mg(b,d)}return null}
function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,
m),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=
f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&Ng(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=Lg(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Tg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Rg(f.type,f.key,f.props,null,a.mode,h),h.ref=Lg(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==
d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=Sg(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);Mg(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
(c(a,d),d=Qg(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(a){var b=Wg.current;E(Wg);a._currentValue=b}function bh(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}
function ch(a,b){Xg=a;Zg=Yg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(dh=!0),a.firstContext=null)}function eh(a){var b=a._currentValue;if(Zg!==a)if(a={context:a,memoizedValue:b,next:null},null===Yg){if(null===Xg)throw Error(p(308));Yg=a;Xg.dependencies={lanes:0,firstContext:a}}else Yg=Yg.next=a;return b}var fh=null;function gh(a){null===fh?fh=[a]:fh.push(a)}
function hh(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,gh(b)):(c.next=e.next,e.next=c);b.interleaved=c;return ih(a,d)}function ih(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var jh=!1;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}
function lh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function mh(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
function nh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return ih(a,c)}e=d.interleaved;null===e?(b.next=b,gh(d)):(b.next=e.next,e.next=b);d.interleaved=b;return ih(a,c)}function oh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
function ph(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b}
function qh(a,b,c,d){var e=a.updateQueue;jh=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:jh=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);rh|=g;a.lanes=g;a.memoizedState=q}}
function sh(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(a){if(a===th)throw Error(p(174));return a}
function yh(a,b){G(wh,b);G(vh,a);G(uh,th);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(uh);G(uh,b)}function zh(){E(uh);E(vh);E(wh)}function Ah(a){xh(wh.current);var b=xh(uh.current);var c=lb(b,a.type);b!==c&&(G(vh,a),G(uh,c))}function Bh(a){vh.current===a&&(E(uh),E(vh))}var L=Uf(0);
function Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Dh=[];
function Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M=null,N=null,O=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P(){throw Error(p(321));}function Mh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}
function Nh(a,b,c,d,e,f){Hh=f;M=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh.current=null===a||null===a.memoizedState?Oh:Ph;a=c(d,e);if(Jh){f=0;do{Jh=!1;Kh=0;if(25<=f)throw Error(p(301));f+=1;O=N=null;b.updateQueue=null;Fh.current=Qh;a=c(d,e)}while(Jh)}Fh.current=Rh;b=null!==N&&null!==N.next;Hh=0;O=N=M=null;Ih=!1;if(b)throw Error(p(300));return a}function Sh(){var a=0!==Kh;Kh=0;return a}
function Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===O?M.memoizedState=O=a:O=O.next=a;return O}function Uh(){if(null===N){var a=M.alternate;a=null!==a?a.memoizedState:null}else a=N.next;var b=null===O?M.memoizedState:O.next;if(null!==b)O=b,N=a;else{if(null===a)throw Error(p(310));N=a;a={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null};null===O?M.memoizedState=O=a:O=O.next=a}return O}
function Vh(a,b){return"function"===typeof b?b(a):b}
function Wh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=N,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;M.lanes|=m;rh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(dh=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,M.lanes|=f,rh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}
function Xh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(dh=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function Yh(){}
function Zh(a,b){var c=M,d=Uh(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,dh=!0);d=d.queue;$h(ai.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==O&&O.memoizedState.tag&1){c.flags|=2048;bi(9,ci.bind(null,c,d,e,b),void 0,null);if(null===Q)throw Error(p(349));0!==(Hh&30)||di(c,b,e)}return e}function di(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}
function ci(a,b,c,d){b.value=c;b.getSnapshot=d;ei(b)&&fi(a)}function ai(a,b,c){return c(function(){ei(b)&&fi(a)})}function ei(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function fi(a){var b=ih(a,1);null!==b&&gi(b,a,1,-1)}
function hi(a){var b=Th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=ii.bind(null,M,a);return[b.memoizedState,a]}
function bi(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function ji(){return Uh().memoizedState}function ki(a,b,c,d){var e=Th();M.flags|=a;e.memoizedState=bi(1|b,c,void 0,void 0===d?null:d)}
function li(a,b,c,d){var e=Uh();d=void 0===d?null:d;var f=void 0;if(null!==N){var g=N.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi(b,c,f,d);return}}M.flags|=a;e.memoizedState=bi(1|b,c,f,d)}function mi(a,b){return ki(8390656,8,a,b)}function $h(a,b){return li(2048,8,a,b)}function ni(a,b){return li(4,2,a,b)}function oi(a,b){return li(4,4,a,b)}
function pi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function qi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return li(4,4,pi.bind(null,b,a),c)}function ri(){}function si(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function ti(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function ui(a,b,c){if(0===(Hh&21))return a.baseState&&(a.baseState=!1,dh=!0),a.memoizedState=c;He(c,b)||(c=yc(),M.lanes|=c,rh|=c,a.baseState=!0);return b}function vi(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Gh.transition;Gh.transition={};try{a(!1),b()}finally{C=c,Gh.transition=d}}function wi(){return Uh().memoizedState}
function xi(a,b,c){var d=yi(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,c);else if(c=hh(a,b,c,d),null!==c){var e=R();gi(c,a,d,e);Bi(c,b,d)}}
function ii(a,b,c){var d=yi(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,gh(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=hh(a,b,e,d);null!==c&&(e=R(),gi(c,a,d,e),Bi(c,b,d))}}
function zi(a){var b=a.alternate;return a===M||null!==b&&b===M}function Ai(a,b){Jh=Ih=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Bi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
var Rh={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(a,b){Th().memoizedState=[a,void 0===b?null:b];return a},useContext:eh,useEffect:mi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ki(4194308,
4,pi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ki(4194308,4,a,b)},useInsertionEffect:function(a,b){return ki(4,2,a,b)},useMemo:function(a,b){var c=Th();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=xi.bind(null,M,a);return[d.memoizedState,a]},useRef:function(a){var b=
Th();a={current:a};return b.memoizedState=a},useState:hi,useDebugValue:ri,useDeferredValue:function(a){return Th().memoizedState=a},useTransition:function(){var a=hi(!1),b=a[0];a=vi.bind(null,a[1]);Th().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=M,e=Th();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===Q)throw Error(p(349));0!==(Hh&30)||di(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;mi(ai.bind(null,d,
f,a),[a]);d.flags|=2048;bi(9,ci.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th(),b=Q.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Lh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},
useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return ui(b,N.memoizedState,a)},useTransition:function(){var a=Wh(Vh)[0],b=Uh().memoizedState;return[a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return null===
N?b.memoizedState=a:ui(b,N.memoizedState,a)},useTransition:function(){var a=Xh(Vh)[0],b=Uh().memoizedState;return[a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}function Di(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}
var Ei={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=R(),d=
yi(a),e=mh(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=nh(a,e,d);null!==b&&(gi(b,a,d,c),oh(b,a,d))}};function Fi(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}
function Gi(a,b,c){var d=!1,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=eh(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ei;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Hi(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ei.enqueueReplaceState(b,b.state,null)}
function Ii(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};kh(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=eh(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Di(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ei.enqueueReplaceState(e,e.state,null),qh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}function Ji(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack}return{value:a,source:b,stack:e,digest:null}}
function Ki(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function Li(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Mi="function"===typeof WeakMap?WeakMap:Map;function Ni(a,b,c){c=mh(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Oi||(Oi=!0,Pi=d);Li(a,b)};return c}
function Qi(a,b,c){c=mh(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Li(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Li(a,b);"function"!==typeof d&&(null===Ri?Ri=new Set([this]):Ri.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
function Si(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Mi;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ti.bind(null,a,b,c),b.then(a,a))}function Ui(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}
function Vi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=mh(-1,1),b.tag=2,nh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(a,b,c,d){b.child=null===a?Vg(b,null,c,d):Ug(b,a.child,c,d)}
function Yi(a,b,c,d,e){c=c.render;var f=b.ref;ch(b,e);d=Nh(a,b,c,d,f,e);c=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&c&&vg(b);b.flags|=1;Xi(a,b,d,e);return b.child}
function $i(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=Rg(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return Zi(a,b,e)}b.flags|=1;a=Pg(f,d);a.ref=b.ref;a.return=b;return b.child=a}
function bj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(dh=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(dh=!0);else return b.lanes=a.lanes,Zi(a,b,e)}return cj(a,b,c,d,e)}
function dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(ej,fj),fj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(ej,fj);fj|=d}else null!==
f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(ej,fj),fj|=d;Xi(a,b,e,c);return b.child}function gj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function cj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);ch(b,e);c=Nh(a,b,c,d,f,e);d=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&d&&vg(b);b.flags|=1;Xi(a,b,c,e);return b.child}
function hj(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;ch(b,e);if(null===b.stateNode)ij(a,b),Gi(b,c,d),Ii(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=eh(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
(h!==d||k!==l)&&Hi(b,g,d,l);jh=!1;var r=b.memoizedState;g.state=r;qh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||jh?("function"===typeof m&&(Di(b,c,m,d),k=b.memoizedState),(h=jh||Fi(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;lh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Ci(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=eh(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&Hi(b,g,d,k);jh=!1;r=b.memoizedState;g.state=r;qh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||jh?("function"===typeof y&&(Di(b,c,y,d),n=b.memoizedState),(l=jh||Fi(b,c,l,d,r,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return jj(a,b,c,d,f,e)}
function jj(a,b,c,d,e,f){gj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),Zi(a,b,f);d=b.stateNode;Wi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Ug(b,a.child,null,f),b.child=Ug(b,null,h,f)):Xi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function kj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);yh(a,b.containerInfo)}
function lj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Xi(a,b,c,d);return b.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return{baseLanes:a,cachePool:null,transitions:null}}
function oj(a,b,c){var d=b.pendingProps,e=L.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(L,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
g):f=pj(g,d,0,null),a=Tg(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=nj(c),b.memoizedState=mj,a):qj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return rj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=Pg(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=Pg(h,f):(f=Tg(f,g,c,null),f.flags|=2);f.return=
b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?nj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=mj;return d}f=a.child;a=f.sibling;d=Pg(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function qj(a,b){b=pj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){null!==d&&Jg(d);Ug(b,a.child,null,c);a=qj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
function rj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Ki(Error(p(422))),sj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=pj({mode:"visible",children:d.children},e,0,null);f=Tg(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Ug(b,a.child,null,g);b.child.memoizedState=nj(g);b.memoizedState=mj;return f}if(0===(b.mode&1))return sj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
if(d)var h=d.dgst;d=h;f=Error(p(419));d=Ki(f,d,void 0);return sj(a,b,g,d)}h=0!==(g&a.childLanes);if(dh||h){d=Q;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;
0!==e&&e!==f.retryLane&&(f.retryLane=e,ih(a,e),gi(d,a,e,-1))}tj();d=Ki(Error(p(421)));return sj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=uj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=qj(b,d.children);b.flags|=4096;return b}function vj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);bh(a.return,b,c)}
function wj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}
function xj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi(a,b,d.children,c);d=L.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&vj(a,c,b);else if(19===a.tag)vj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(L,d);if(0===(b.mode&1))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);wj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}wj(b,!0,c,null,f);break;case "together":wj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}
function ij(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function Zi(a,b,c){null!==a&&(b.dependencies=a.dependencies);rh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=Pg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Pg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function yj(a,b,c){switch(b.tag){case 3:kj(b);Ig();break;case 5:Ah(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:yh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Wg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(L,L.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return oj(a,b,c);G(L,L.current&1);a=Zi(a,b,c);return null!==a?a.sibling:null}G(L,L.current&1);break;case 19:d=0!==(c&
b.childLanes);if(0!==(a.flags&128)){if(d)return xj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(L,L.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi(a,b,c)}var zj,Aj,Bj,Cj;
zj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Aj=function(){};
Bj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh(uh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,
c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Cj=function(a,b,c,d){c!==d&&(b.flags|=4)};
function Dj(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
function Ej(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;zh();E(Wf);E(H);Eh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Fj(zg),zg=null));Aj(a,b);S(b);return null;case 5:Bh(b);var e=xh(wh.current);
c=b.type;if(null!==a&&null!=b.stateNode)Bj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",
d);D("load",d);break;case "details":D("toggle",d);break;case "input":Za(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":hb(d,f),D("invalid",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,
h,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d)}switch(c){case "input":Va(d);db(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;zj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",
a);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D("invalid",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==
c||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&ta(a,f,k,g))}switch(c){case "input":Va(a);db(a,d,!1);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,
!0);break;default:"function"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Cj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=xh(wh.current);xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=
xg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(L);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===
a){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Fj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(L.current&1)?0===T&&(T=3):tj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return zh(),
Aj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return ah(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(L);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dj(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Dj(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(L,L.current&1|2);return b.child}a=
a.sibling}null!==f.tail&&B()>Gj&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304)}else{if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dj(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Gj&&1073741824!==c&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=
b,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=L.current,G(L,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Hj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(fj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}
function Ij(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh(),E(Wf),E(H),Eh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh(b),null;case 13:E(L);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(b.type._context),null;case 22:case 23:return Hj(),
null;case 24:return null;default:return null}}var Jj=!1,U=!1,Kj="function"===typeof WeakSet?WeakSet:Set,V=null;function Lj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Mj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Nj=!1;
function Oj(a,b){Cf=dd;a=Me();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Ci(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Nj;Nj=!1;return n}
function Pj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Mj(b,c,f)}e=e.next}while(e!==d)}}function Qj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Rj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}
function Sj(a){var b=a.alternate;null!==b&&(a.alternate=null,Sj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Tj(a){return 5===a.tag||3===a.tag||4===a.tag}
function Uj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Tj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}
function Vj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Vj(a,b,c),a=a.sibling;null!==a;)Vj(a,b,c),a=a.sibling}
function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}var X=null,Xj=!1;function Yj(a,b,c){for(c=c.child;null!==c;)Zj(a,b,c),c=c.sibling}
function Zj(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Lj(c,b);case 6:var d=X,e=Xj;X=null;Yj(a,b,c);X=d;Xj=e;null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Xj;X=c.stateNode.containerInfo;Xj=!0;
Yj(a,b,c);X=d;Xj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Mj(c,b,g):0!==(f&4)&&Mj(c,b,g));e=e.next}while(e!==d)}Yj(a,b,c);break;case 1:if(!U&&(Lj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Yj(a,b,c);break;case 21:Yj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==
c.memoizedState,Yj(a,b,c),U=d):Yj(a,b,c);break;default:Yj(a,b,c)}}function ak(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Kj);b.forEach(function(b){var d=bk.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
function ck(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Xj=!1;break a;case 3:X=h.stateNode.containerInfo;Xj=!0;break a;case 4:X=h.stateNode.containerInfo;Xj=!0;break a}h=h.return}if(null===X)throw Error(p(160));Zj(f,g,e);X=null;Xj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)dk(b,a),b=b.sibling}
function dk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ck(b,a);ek(a);if(d&4){try{Pj(3,a,a.return),Qj(3,a)}catch(t){W(a,a.return,t)}try{Pj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);break;case 5:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l)}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,
f.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:ck(b,a);ek(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:ck(b,a);ek(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:ck(b,a);ek(a);break;case 13:ck(b,a);ek(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
null!==e.alternate&&null!==e.alternate.memoizedState||(fk=B()));d&4&&ak(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,ck(b,a),U=l):ck(b,a);ek(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Pj(4,r,r.return);break;case 1:Lj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Lj(r,r.return);break;case 22:if(null!==r.memoizedState){gk(q);continue}}null!==y?(y.return=r,V=y):gk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
rb("display",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:ck(b,a);ek(a);d&4&&ak(a);break;case 21:break;default:ck(b,
a),ek(a)}}function ek(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Tj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Uj(a);Wj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Uj(a);Vj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function hk(a,b,c){V=a;ik(a,b,c)}
function ik(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Jj;var l=U;Jj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?jk(e):null!==k?(k.return=g,V=k):jk(e);for(;null!==f;)V=f,ik(f,b,c),f=f.sibling;V=e;Jj=h;U=l}kk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):kk(a,b,c)}}
function kk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Qj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Ci(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&sh(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
b.child.stateNode;break;case 1:c=b.child.stateNode}sh(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
default:throw Error(p(163));}U||b.flags&512&&Rj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function gk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}
function jk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Qj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Rj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Rj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}
var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=Infinity,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return 0!==(K&6)?B():-1!==Ak?Ak:Ak=B()}
function yi(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Bk&&(Bk=yc()),Bk;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function gi(a,b,c,d){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==Q)a===Q&&(0===(K&2)&&(qk|=c),4===T&&Ck(a,Z)),Dk(a,d),1===c&&0===K&&0===(b.mode&1)&&(Gj=B()+500,fg&&jg())}
function Dk(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===Q?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Ek.bind(null,a)):hg(Ek.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Fk(c,Gk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}
function Gk(a,b){Ak=-1;Bk=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Hk()&&a.callbackNode!==c)return null;var d=uc(a,a===Q?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Ik(a,d);else{b=d;var e=K;K|=2;var f=Jk();if(Q!==a||Z!==b)uk=null,Gj=B()+500,Kk(a,b);do try{Lk();break}catch(h){Mk(a,h)}while(1);$g();mk.current=f;K=e;null!==Y?b=0:(Q=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Nk(a,e)));if(1===b)throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;if(6===b)Ck(a,d);
else{e=a.current.alternate;if(0===(d&30)&&!Ok(e)&&(b=Ik(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Nk(a,f))),1===b))throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Pk(a,tk,uk);break;case 3:Ck(a,d);if((d&130023424)===d&&(b=fk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){R();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),b);break}Pk(a,tk,uk);break;case 4:Ck(a,d);if((d&4194240)===
d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*lk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),d);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p(329));}}}Dk(a,B());return a.callbackNode===c?Gk.bind(null,a):null}
function Nk(a,b){var c=sk;a.current.memoizedState.isDehydrated&&(Kk(a,b).flags|=256);a=Ik(a,b);2!==a&&(b=tk,tk=c,null!==b&&Fj(b));return a}function Fj(a){null===tk?tk=a:tk.push.apply(tk,a)}
function Ok(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}
function Ck(a,b){b&=~rk;b&=~qk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Ek(a){if(0!==(K&6))throw Error(p(327));Hk();var b=uc(a,0);if(0===(b&1))return Dk(a,B()),null;var c=Ik(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Nk(a,d))}if(1===c)throw c=pk,Kk(a,0),Ck(a,b),Dk(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Pk(a,tk,uk);Dk(a,B());return null}
function Qk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Gj=B()+500,fg&&jg())}}function Rk(a){null!==wk&&0===wk.tag&&0===(K&6)&&Hk();var b=K;K|=1;var c=ok.transition,d=C;try{if(ok.transition=null,C=1,a)return a()}finally{C=d,ok.transition=c,K=b,0===(K&6)&&jg()}}function Hj(){fj=ej.current;E(ej)}
function Kk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:zh();E(Wf);E(H);Eh();break;case 5:Bh(d);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(d.type._context);break;case 22:case 23:Hj()}c=c.return}Q=a;Y=a=Pg(a.current,null);Z=fj=b;T=0;pk=null;rk=qk=rh=0;tk=sk=null;if(null!==fh){for(b=
0;b<fh.length;b++)if(c=fh[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}fh=null}return a}
function Mk(a,b){do{var c=Y;try{$g();Fh.current=Rh;if(Ih){for(var d=M.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Ih=!1}Hh=0;O=N=M=null;Jh=!1;Kh=0;nk.current=null;if(null===c||null===c.return){T=1;pk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Ui(g);if(null!==y){y.flags&=-257;Vi(y,g,h,f,b);y.mode&1&&Si(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Si(f,l,b);tj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Ui(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Vi(J,g,h,f,b);Jg(Ji(k,h));break a}}f=k=Ji(k,h);4!==T&&(T=2);null===sk?sk=[f]:sk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
b&=-b;f.lanes|=b;var x=Ni(f,k,b);ph(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Ri||!Ri.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Qi(f,h,b);ph(f,F);break a}}f=f.return}while(null!==f)}Sk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Jk(){var a=mk.current;mk.current=Rh;return null===a?Rh:a}
function tj(){if(0===T||3===T||2===T)T=4;null===Q||0===(rh&268435455)&&0===(qk&268435455)||Ck(Q,Z)}function Ik(a,b){var c=K;K|=2;var d=Jk();if(Q!==a||Z!==b)uk=null,Kk(a,b);do try{Tk();break}catch(e){Mk(a,e)}while(1);$g();K=c;mk.current=d;if(null!==Y)throw Error(p(261));Q=null;Z=0;return T}function Tk(){for(;null!==Y;)Uk(Y)}function Lk(){for(;null!==Y&&!cc();)Uk(Y)}function Uk(a){var b=Vk(a.alternate,a,fj);a.memoizedProps=a.pendingProps;null===b?Sk(a):Y=b;nk.current=null}
function Sk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Ej(c,b,fj),null!==c){Y=c;return}}else{c=Ij(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Pk(a,b,c){var d=C,e=ok.transition;try{ok.transition=null,C=1,Wk(a,b,c,d)}finally{ok.transition=e,C=d}return null}
function Wk(a,b,c,d){do Hk();while(null!==wk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===Q&&(Y=Q=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||vk||(vk=!0,Fk(hc,function(){Hk();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ok.transition;ok.transition=null;
var g=C;C=1;var h=K;K|=4;nk.current=null;Oj(a,c);dk(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;hk(c,a,e);dc();K=h;C=g;ok.transition=f}else a.current=c;vk&&(vk=!1,wk=a,xk=e);f=a.pendingLanes;0===f&&(Ri=null);mc(c.stateNode,d);Dk(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Oi)throw Oi=!1,a=Pi,Pi=null,a;0!==(xk&1)&&0!==a.tag&&Hk();f=a.pendingLanes;0!==(f&1)?a===zk?yk++:(yk=0,zk=a):yk=0;jg();return null}
function Hk(){if(null!==wk){var a=Dc(xk),b=ok.transition,c=C;try{ok.transition=null;C=16>a?16:a;if(null===wk)var d=!1;else{a=wk;wk=null;xk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Pj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Sj(m);if(m===
l){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Pj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
u)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Qj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,ok.transition=b}}return!1}function Xk(a,b,c){b=Ji(c,b);b=Ni(a,b,1);a=nh(a,b,1);b=R();null!==a&&(Ac(a,1,b),Dk(a,b))}
function W(a,b,c){if(3===a.tag)Xk(a,a,c);else for(;null!==b;){if(3===b.tag){Xk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ri||!Ri.has(d))){a=Ji(c,a);a=Qi(b,a,1);b=nh(b,a,1);a=R();null!==b&&(Ac(b,1,a),Dk(b,a));break}}b=b.return}}
function Ti(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=R();a.pingedLanes|=a.suspendedLanes&c;Q===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-fk?Kk(a,0):rk|=c);Dk(a,b)}function Yk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=R();a=ih(a,b);null!==a&&(Ac(a,b,c),Dk(a,c))}function uj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Yk(a,c)}
function bk(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Yk(a,c)}var Vk;
Vk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)dh=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return dh=!1,yj(a,b,c);dh=0!==(a.flags&131072)?!0:!1}else dh=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;ij(a,b);a=b.pendingProps;var e=Yf(b,H.current);ch(b,c);e=Nh(null,b,d,a,e,c);var f=Sh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
null,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,kh(b),e.updater=Ei,b.stateNode=e,e._reactInternals=b,Ii(b,d,a,c),b=jj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Xi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{ij(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Zk(d);a=Ci(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=hj(null,b,d,a,c);break a;case 11:b=Yi(null,b,d,a,c);break a;case 14:b=$i(null,b,d,Ci(d.type,a),c);break a}throw Error(p(306,
d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),hj(a,b,d,e,c);case 3:a:{kj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;lh(a,b);qh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
f,b.memoizedState=f,b.flags&256){e=Ji(Error(p(423)),b);b=lj(a,b,d,c,e);break a}else if(d!==e){e=Ji(Error(p(424)),b);b=lj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Vg(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=Zi(a,b,c);break a}Xi(a,b,d,c)}b=b.child}return b;case 5:return Ah(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),
gj(a,b),Xi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return oj(a,b,c);case 4:return yh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Ug(b,null,d,c):Xi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),Yi(a,b,d,e,c);case 7:return Xi(a,b,b.pendingProps,c),b.child;case 8:return Xi(a,b,b.pendingProps.children,c),b.child;case 12:return Xi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
g=e.value;G(Wg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=Zi(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=mh(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);bh(f.return,
c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);bh(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Xi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,ch(b,c),e=eh(e),d=d(e),b.flags|=1,Xi(a,b,d,c),
b.child;case 14:return d=b.type,e=Ci(d,b.pendingProps),e=Ci(d.type,e),$i(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),ij(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,ch(b,c),Gi(b,d,e),Ii(b,d,e,c),jj(null,b,d,!0,a,c);case 19:return xj(a,b,c);case 22:return dj(a,b,c)}throw Error(p(156,b.tag));};function Fk(a,b){return ac(a,b)}
function $k(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new $k(a,b,c,d)}function aj(a){a=a.prototype;return!(!a||!a.isReactComponent)}
function Zk(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}
function Pg(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Rg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Tg(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return pj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;
break a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Tg(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function pj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function Qg(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}
function Sg(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function al(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
null}function bl(a,b,c,d,e,f,g,h,k){a=new al(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};kh(f);return a}function cl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function dl(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}
function el(a,b,c,d,e,f,g,h,k){a=bl(c,d,!0,a,e,f,g,h,k);a.context=dl(null);c=a.current;d=R();e=yi(c);f=mh(d,e);f.callback=void 0!==b&&null!==b?b:null;nh(c,f,e);a.current.lanes=e;Ac(a,e,d);Dk(a,d);return a}function fl(a,b,c,d){var e=b.current,f=R(),g=yi(e);c=dl(c);null===b.context?b.context=c:b.pendingContext=c;b=mh(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=nh(e,b,g);null!==a&&(gi(a,e,g,f),oh(a,e,g));return g}
function gl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function il(a,b){hl(a,b);(a=a.alternate)&&hl(a,b)}function jl(){return null}var kl="function"===typeof reportError?reportError:function(a){console.error(a)};function ll(a){this._internalRoot=a}
ml.prototype.render=ll.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));fl(a,b,null,null)};ml.prototype.unmount=ll.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Rk(function(){fl(null,a,null,null)});b[uf]=null}};function ml(a){this._internalRoot=a}
ml.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function nl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function pl(){}
function ql(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=gl(g);f.call(a)}}var g=el(b,d,a,0,null,!1,!1,"",pl);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Rk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=gl(k);h.call(a)}}var k=bl(a,0,!1,null,null,!1,!1,"",pl);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Rk(function(){fl(b,k,c,d)});return k}
function rl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=gl(g);h.call(a)}}fl(b,g,a,e)}else g=ql(c,b,a,e,d);return gl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Dk(b,B()),0===(K&6)&&(Gj=B()+500,jg()))}break;case 13:Rk(function(){var b=ih(a,1);if(null!==b){var c=R();gi(b,a,1,c)}}),il(a,1)}};
Fc=function(a){if(13===a.tag){var b=ih(a,134217728);if(null!==b){var c=R();gi(b,a,134217728,c)}il(a,134217728)}};Gc=function(a){if(13===a.tag){var b=yi(a),c=ih(a,b);if(null!==c){var d=R();gi(c,a,b,d)}il(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};
yb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Qk;Hb=Rk;
var sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"};
var ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||
jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;
exports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!nl(b))throw Error(p(200));return cl(a,b,null,c)};exports.createRoot=function(a,b){if(!nl(a))throw Error(p(299));var c=!1,d="",e=kl;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=bl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ll(b)};
exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Rk(a)};exports.hydrate=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,!0,c)};
exports.hydrateRoot=function(a,b,c){if(!nl(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=kl;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=el(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
e);return new ml(b)};exports.render=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!ol(a))throw Error(p(40));return a._reactRootContainer?(Rk(function(){rl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Qk;
exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!ol(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return rl(a,b,c,!1,d)};exports.version="18.3.1-next-f1338f8080-20240426";


/***/ }),

/***/ 7061:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  }
    throw new Error('"' + aName + '" is a required argument.');

}
exports.getArg = getArg;

const urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
const dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  const match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  let url = "";
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ":";
  }
  url += "//";
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + "@";
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

const MAX_CACHED_INPUTS = 32;

/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */
function lruMemoize(f) {
  const cache = [];

  return function(input) {
    for (let i = 0; i < cache.length; i++) {
      if (cache[i].input === input) {
        const temp = cache[0];
        cache[0] = cache[i];
        cache[i] = temp;
        return cache[0].result;
      }
    }

    const result = f(input);

    cache.unshift({
      input,
      result,
    });

    if (cache.length > MAX_CACHED_INPUTS) {
      cache.pop();
    }

    return result;
  };
}

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
const normalize = lruMemoize(function normalize(aPath) {
  let path = aPath;
  const url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  const isAbsolute = exports.isAbsolute(path);

  // Split the path into parts between `/` characters. This is much faster than
  // using `.split(/\/+/g)`.
  const parts = [];
  let start = 0;
  let i = 0;
  while (true) {
    start = i;
    i = path.indexOf("/", start);
    if (i === -1) {
      parts.push(path.slice(start));
      break;
    } else {
      parts.push(path.slice(start, i));
      while (i < path.length && path[i] === "/") {
        i++;
      }
    }
  }

  let up = 0;
  for (i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    if (part === ".") {
      parts.splice(i, 1);
    } else if (part === "..") {
      up++;
    } else if (up > 0) {
      if (part === "") {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join("/");

  if (path === "") {
    path = isAbsolute ? "/" : ".";
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
});
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  const aPathUrl = urlParse(aPath);
  const aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || "/";
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  const joined = aPath.charAt(0) === "/"
    ? aPath
    : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function(aPath) {
  return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, "");

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  let level = 0;
  while (aPath.indexOf(aRoot + "/") !== 0) {
    const index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

const supportsNullProto = (function() {
  const obj = Object.create(null);
  return !("__proto__" in obj);
}());

function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return "$" + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  const length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  /* eslint-disable no-multi-spaces */
  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }
  /* eslint-enable no-multi-spaces */

  for (let i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  let cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  let cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  let cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || "";

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
      sourceRoot += "/";
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    const parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      const index = parsed.path.lastIndexOf("/");
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ 7150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -r
const hlo = __webpack_require__(1743)
const Pack = __webpack_require__(3593)
const fs = __webpack_require__(9896)
const fsm = __webpack_require__(5733)
const t = __webpack_require__(4832)
const path = __webpack_require__(6928)

// starting at the head of the file, read a Header
// If the checksum is invalid, that's our position to start writing
// If it is, jump forward by the specified size (round up to 512)
// and try again.
// Write the new Pack stream starting there.

const Header = __webpack_require__(877)

module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file) {
    throw new TypeError('file is required')
  }

  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {
    throw new TypeError('cannot append to compressed archives')
  }

  if (!files || !Array.isArray(files) || !files.length) {
    throw new TypeError('no files or directories specified')
  }

  files = Array.from(files)

  return opt.sync ? replaceSync(opt, files)
    : replace(opt, files, cb)
}

const replaceSync = (opt, files) => {
  const p = new Pack.Sync(opt)

  let threw = true
  let fd
  let position

  try {
    try {
      fd = fs.openSync(opt.file, 'r+')
    } catch (er) {
      if (er.code === 'ENOENT') {
        fd = fs.openSync(opt.file, 'w+')
      } else {
        throw er
      }
    }

    const st = fs.fstatSync(fd)
    const headBuf = Buffer.alloc(512)

    POSITION: for (position = 0; position < st.size; position += 512) {
      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
        bytes = fs.readSync(
          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos
        )

        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {
          throw new Error('cannot append to compressed archives')
        }

        if (!bytes) {
          break POSITION
        }
      }

      const h = new Header(headBuf)
      if (!h.cksumValid) {
        break
      }
      const entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > st.size) {
        break
      }
      // the 512 for the header we just parsed will be added as well
      // also jump ahead all the blocks for the body
      position += entryBlockSize
      if (opt.mtimeCache) {
        opt.mtimeCache.set(h.path, h.mtime)
      }
    }
    threw = false

    streamSync(opt, p, position, fd, files)
  } finally {
    if (threw) {
      try {
        fs.closeSync(fd)
      } catch (er) {}
    }
  }
}

const streamSync = (opt, p, position, fd, files) => {
  const stream = new fsm.WriteStreamSync(opt.file, {
    fd: fd,
    start: position,
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const replace = (opt, files, cb) => {
  files = Array.from(files)
  const p = new Pack(opt)

  const getPos = (fd, size, cb_) => {
    const cb = (er, pos) => {
      if (er) {
        fs.close(fd, _ => cb_(er))
      } else {
        cb_(null, pos)
      }
    }

    let position = 0
    if (size === 0) {
      return cb(null, 0)
    }

    let bufPos = 0
    const headBuf = Buffer.alloc(512)
    const onread = (er, bytes) => {
      if (er) {
        return cb(er)
      }
      bufPos += bytes
      if (bufPos < 512 && bytes) {
        return fs.read(
          fd, headBuf, bufPos, headBuf.length - bufPos,
          position + bufPos, onread
        )
      }

      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {
        return cb(new Error('cannot append to compressed archives'))
      }

      // truncated header
      if (bufPos < 512) {
        return cb(null, position)
      }

      const h = new Header(headBuf)
      if (!h.cksumValid) {
        return cb(null, position)
      }

      const entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > size) {
        return cb(null, position)
      }

      position += entryBlockSize + 512
      if (position >= size) {
        return cb(null, position)
      }

      if (opt.mtimeCache) {
        opt.mtimeCache.set(h.path, h.mtime)
      }
      bufPos = 0
      fs.read(fd, headBuf, 0, 512, position, onread)
    }
    fs.read(fd, headBuf, 0, 512, position, onread)
  }

  const promise = new Promise((resolve, reject) => {
    p.on('error', reject)
    let flag = 'r+'
    const onopen = (er, fd) => {
      if (er && er.code === 'ENOENT' && flag === 'r+') {
        flag = 'w+'
        return fs.open(opt.file, flag, onopen)
      }

      if (er) {
        return reject(er)
      }

      fs.fstat(fd, (er, st) => {
        if (er) {
          return fs.close(fd, () => reject(er))
        }

        getPos(fd, st.size, (er, position) => {
          if (er) {
            return reject(er)
          }
          const stream = new fsm.WriteStream(opt.file, {
            fd: fd,
            start: position,
          })
          p.pipe(stream)
          stream.on('error', reject)
          stream.on('close', resolve)
          addFilesAsync(p, files)
        })
      })
    }
    fs.open(opt.file, flag, onopen)
  })

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@') {
      t({
        file: path.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry),
      })
    } else {
      p.add(file)
    }
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@') {
      return t({
        file: path.resolve(p.cwd, file.slice(1)),
        noResume: true,
        onentry: entry => p.add(entry),
      }).then(_ => addFilesAsync(p, files))
    } else {
      p.add(file)
    }
  }
  p.end()
}


/***/ }),

/***/ 7296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {dirname} = __webpack_require__(6928)

const mkdirpManual = (path, opts, made) => {
  opts.recursive = false
  const parent = dirname(path)
  if (parent === path) {
    return opts.mkdirAsync(path, opts).catch(er => {
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== 'EISDIR')
        throw er
    })
  }

  return opts.mkdirAsync(path, opts).then(() => made || path, er => {
    if (er.code === 'ENOENT')
      return mkdirpManual(parent, opts)
        .then(made => mkdirpManual(path, opts, made))
    if (er.code !== 'EEXIST' && er.code !== 'EROFS')
      throw er
    return opts.statAsync(path).then(st => {
      if (st.isDirectory())
        return made
      else
        throw er
    }, () => { throw er })
  })
}

const mkdirpManualSync = (path, opts, made) => {
  const parent = dirname(path)
  opts.recursive = false

  if (parent === path) {
    try {
      return opts.mkdirSync(path, opts)
    } catch (er) {
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== 'EISDIR')
        throw er
      else
        return
    }
  }

  try {
    opts.mkdirSync(path, opts)
    return made || path
  } catch (er) {
    if (er.code === 'ENOENT')
      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))
    if (er.code !== 'EEXIST' && er.code !== 'EROFS')
      throw er
    try {
      if (!opts.statSync(path).isDirectory())
        throw er
    } catch (_) {
      throw er
    }
  }
}

module.exports = {mkdirpManual, mkdirpManualSync}


/***/ }),

/***/ 7810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(5677);
} else {}


/***/ }),

/***/ 7841:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(9417)(Yallist)
} catch (er) {}


/***/ }),

/***/ 7880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
const realZlibConstants = (__webpack_require__(3106).constants) ||
  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }

module.exports = Object.freeze(Object.assign(Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31,
}, realZlibConstants))


/***/ }),

/***/ 7890:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function(number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};


/***/ }),

/***/ 8087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Header = __webpack_require__(877)
const path = __webpack_require__(6928)

class Pax {
  constructor (obj, global) {
    this.atime = obj.atime || null
    this.charset = obj.charset || null
    this.comment = obj.comment || null
    this.ctime = obj.ctime || null
    this.gid = obj.gid || null
    this.gname = obj.gname || null
    this.linkpath = obj.linkpath || null
    this.mtime = obj.mtime || null
    this.path = obj.path || null
    this.size = obj.size || null
    this.uid = obj.uid || null
    this.uname = obj.uname || null
    this.dev = obj.dev || null
    this.ino = obj.ino || null
    this.nlink = obj.nlink || null
    this.global = global || false
  }

  encode () {
    const body = this.encodeBody()
    if (body === '') {
      return null
    }

    const bodyLen = Buffer.byteLength(body)
    // round up to 512 bytes
    // add 512 for header
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)
    const buf = Buffer.allocUnsafe(bufLen)

    // 0-fill the header section, it might not hit every field
    for (let i = 0; i < 512; i++) {
      buf[i] = 0
    }

    new Header({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),
      mode: this.mode || 0o644,
      uid: this.uid || null,
      gid: this.gid || null,
      size: bodyLen,
      mtime: this.mtime || null,
      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
      linkpath: '',
      uname: this.uname || '',
      gname: this.gname || '',
      devmaj: 0,
      devmin: 0,
      atime: this.atime || null,
      ctime: this.ctime || null,
    }).encode(buf)

    buf.write(body, 512, bodyLen, 'utf8')

    // null pad after the body
    for (let i = bodyLen + 512; i < buf.length; i++) {
      buf[i] = 0
    }

    return buf
  }

  encodeBody () {
    return (
      this.encodeField('path') +
      this.encodeField('ctime') +
      this.encodeField('atime') +
      this.encodeField('dev') +
      this.encodeField('ino') +
      this.encodeField('nlink') +
      this.encodeField('charset') +
      this.encodeField('comment') +
      this.encodeField('gid') +
      this.encodeField('gname') +
      this.encodeField('linkpath') +
      this.encodeField('mtime') +
      this.encodeField('size') +
      this.encodeField('uid') +
      this.encodeField('uname')
    )
  }

  encodeField (field) {
    if (this[field] === null || this[field] === undefined) {
      return ''
    }
    const v = this[field] instanceof Date ? this[field].getTime() / 1000
      : this[field]
    const s = ' ' +
      (field === 'dev' || field === 'ino' || field === 'nlink'
        ? 'SCHILY.' : '') +
      field + '=' + v + '\n'
    const byteLen = Buffer.byteLength(s)
    // the digits includes the length of the digits in ascii base-10
    // so if it's 9 characters, then adding 1 for the 9 makes it 10
    // which makes it 11 chars.
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1
    if (byteLen + digits >= Math.pow(10, digits)) {
      digits += 1
    }
    const len = digits + byteLen
    return len + s
  }
}

Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)

const merge = (a, b) =>
  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a

const parseKV = string =>
  string
    .replace(/\n$/, '')
    .split('\n')
    .reduce(parseKVLine, Object.create(null))

const parseKVLine = (set, line) => {
  const n = parseInt(line, 10)

  // XXX Values with \n in them will fail this.
  // Refactor to not be a naive line-by-line parse.
  if (n !== Buffer.byteLength(line) + 1) {
    return set
  }

  line = line.slice((n + ' ').length)
  const kv = line.split('=')
  const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, '$1')
  if (!k) {
    return set
  }

  const v = kv.join('=')
  set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k)
    ? new Date(v * 1000)
    : /^[0-9]+$/.test(v) ? +v
    : v
  return set
}

module.exports = Pax


/***/ }),

/***/ 8272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const util = __webpack_require__(7061);
const binarySearch = __webpack_require__(4297);
const ArraySet = (__webpack_require__(1793)/* .ArraySet */ .C);
const base64VLQ = __webpack_require__(4286); // eslint-disable-line no-unused-vars
const readWasm = __webpack_require__(9874);
const wasm = __webpack_require__(5401);

const INTERNAL = Symbol("smcInternal");

class SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    // If the constructor was called by super(), just return Promise<this>.
    // Yes, this is a hack to retain the pre-existing API of the base-class
    // constructor also being an async factory function.
    if (aSourceMap == INTERNAL) {
      return Promise.resolve(this);
    }

    return _factory(aSourceMap, aSourceMapURL);
  }

  static initialize(opts) {
    readWasm.initialize(opts["lib/mappings.wasm"]);
  }

  static fromSourceMap(aSourceMap, aSourceMapURL) {
    return _factoryBSM(aSourceMap, aSourceMapURL);
  }

  /**
   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`
   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async
   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait
   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return
   * value.
   *
   * You must not use the consumer after `f` completes!
   *
   * By using `with`, you do not have to remember to manually call `destroy` on
   * the consumer, since it will be called automatically once `f` completes.
   *
   * ```js
   * const xSquared = await SourceMapConsumer.with(
   *   myRawSourceMap,
   *   null,
   *   async function (consumer) {
   *     // Use `consumer` inside here and don't worry about remembering
   *     // to call `destroy`.
   *
   *     const x = await whatever(consumer);
   *     return x * x;
   *   }
   * );
   *
   * // You may not use that `consumer` anymore out here; it has
   * // been destroyed. But you can use `xSquared`.
   * console.log(xSquared);
   * ```
   */
  static async with(rawSourceMap, sourceMapUrl, f) {
    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);
    try {
      return await f(consumer);
    } finally {
      consumer.destroy();
    }
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  eachMapping(aCallback, aContext, aOrder) {
    throw new Error("Subclasses must implement eachMapping");
  }

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  allGeneratedPositionsFor(aArgs) {
    throw new Error("Subclasses must implement allGeneratedPositionsFor");
  }

  destroy() {
    throw new Error("Subclasses must implement destroy");
  }
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
class BasicSourceMapConsumer extends SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    return super(INTERNAL).then(that => {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      const version = util.getArg(sourceMap, "version");
      let sources = util.getArg(sourceMap, "sources");
      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
      // requires the array) to play nice here.
      const names = util.getArg(sourceMap, "names", []);
      let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      const mappings = util.getArg(sourceMap, "mappings");
      const file = util.getArg(sourceMap, "file", null);

      // Once again, Sass deviates from the spec and supplies the version as a
      // string rather than a number, so we use loose equality checking here.
      if (version != that._version) {
        throw new Error("Unsupported version: " + version);
      }

      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }

      sources = sources
        .map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
            ? util.relative(sourceRoot, source)
            : source;
        });

      // Pass `true` below to allow duplicate names and sources. While source maps
      // are intended to be compressed and deduplicated, the TypeScript compiler
      // sometimes generates source maps with duplicates in them. See Github issue
      // #72 and bugzil.la/889492.
      that._names = ArraySet.fromArray(names.map(String), true);
      that._sources = ArraySet.fromArray(sources, true);

      that._absoluteSources = that._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });

      that.sourceRoot = sourceRoot;
      that.sourcesContent = sourcesContent;
      that._mappings = mappings;
      that._sourceMapURL = aSourceMapURL;
      that.file = file;

      that._computedColumnSpans = false;
      that._mappingsPtr = 0;
      that._wasm = null;

      return wasm().then(w => {
        that._wasm = w;
        return that;
      });
    });
  }

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  _findSourceIndex(aSource) {
    let relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    for (let i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  }

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  static fromSourceMap(aSourceMap, aSourceMapURL) {
    return new BasicSourceMapConsumer(aSourceMap.toString());
  }

  get sources() {
    return this._absoluteSources.slice();
  }

  _getMappingsPtr() {
    if (this._mappingsPtr === 0) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this._mappingsPtr;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    const size = aStr.length;

    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
    for (let i = 0; i < size; i++) {
      mappingsBuf[i] = aStr.charCodeAt(i);
    }

    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);

    if (!mappingsPtr) {
      const error = this._wasm.exports.get_last_error();
      let msg = `Error parsing mappings (code ${error}): `;

      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.
      switch (error) {
        case 1:
          msg += "the mappings contained a negative line, column, source index, or name index";
          break;
        case 2:
          msg += "the mappings contained a number larger than 2**32";
          break;
        case 3:
          msg += "reached EOF while in the middle of parsing a VLQ";
          break;
        case 4:
          msg += "invalid base 64 character while parsing a VLQ";
          break;
        default:
          msg += "unknown error code";
          break;
      }

      throw new Error(msg);
    }

    this._mappingsPtr = mappingsPtr;
  }

  eachMapping(aCallback, aContext, aOrder) {
    const context = aContext || null;
    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    const sourceRoot = this.sourceRoot;

    this._wasm.withMappingCallback(
      mapping => {
        if (mapping.source !== null) {
          mapping.source = this._sources.at(mapping.source);
          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);

          if (mapping.name !== null) {
            mapping.name = this._names.at(mapping.name);
          }
        }

        aCallback.call(context, mapping);
      },
      () => {
        switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          this._wasm.exports.by_generated_location(this._getMappingsPtr());
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          this._wasm.exports.by_original_location(this._getMappingsPtr());
          break;
        default:
          throw new Error("Unknown order of iteration.");
        }
      }
    );
  }

  allGeneratedPositionsFor(aArgs) {
    let source = util.getArg(aArgs, "source");
    const originalLine = util.getArg(aArgs, "line");
    const originalColumn = aArgs.column || 0;

    source = this._findSourceIndex(source);
    if (source < 0) {
      return [];
    }

    if (originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    const mappings = [];

    this._wasm.withMappingCallback(
      m => {
        let lastColumn = m.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        mappings.push({
          line: m.generatedLine,
          column: m.generatedColumn,
          lastColumn,
        });
      }, () => {
        this._wasm.exports.all_generated_locations_for(
          this._getMappingsPtr(),
          source,
          originalLine - 1,
          "column" in aArgs,
          originalColumn
        );
      }
    );

    return mappings;
  }

  destroy() {
    if (this._mappingsPtr !== 0) {
      this._wasm.exports.free_mappings(this._mappingsPtr);
      this._mappingsPtr = 0;
    }
  }

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  computeColumnSpans() {
    if (this._computedColumnSpans) {
      return;
    }

    this._wasm.exports.compute_column_spans(this._getMappingsPtr());
    this._computedColumnSpans = true;
  }

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  originalPositionFor(aArgs) {
    const needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };

    if (needle.generatedLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.generatedColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
    if (bias == null) {
      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(m => mapping = m, () => {
      this._wasm.exports.original_location_for(
        this._getMappingsPtr(),
        needle.generatedLine - 1,
        needle.generatedColumn,
        bias
      );
    });

    if (mapping) {
      if (mapping.generatedLine === needle.generatedLine) {
        let source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }

        let name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function(sc) { return sc == null; });
  }

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    const index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    let relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    let url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }

    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  generatedPositionFor(aArgs) {
    let source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    const needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };

    if (needle.originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
    if (bias == null) {
      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(m => mapping = m, () => {
      this._wasm.exports.generated_location_for(
        this._getMappingsPtr(),
        needle.source,
        needle.originalLine - 1,
        needle.originalColumn,
        bias
      );
    });

    if (mapping) {
      if (mapping.source === needle.source) {
        let lastColumn = mapping.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn,
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
}

BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
__webpack_unused_export__ = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
class IndexedSourceMapConsumer extends SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    return super(INTERNAL).then(that => {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      const version = util.getArg(sourceMap, "version");
      const sections = util.getArg(sourceMap, "sections");

      if (version != that._version) {
        throw new Error("Unsupported version: " + version);
      }

      that._sources = new ArraySet();
      that._names = new ArraySet();
      that.__generatedMappings = null;
      that.__originalMappings = null;
      that.__generatedMappingsUnsorted = null;
      that.__originalMappingsUnsorted = null;

      let lastOffset = {
        line: -1,
        column: 0
      };
      return Promise.all(sections.map(s => {
        if (s.url) {
          // The url field will require support for asynchronicity.
          // See https://github.com/mozilla/source-map/issues/16
          throw new Error("Support for url field in sections not implemented.");
        }
        const offset = util.getArg(s, "offset");
        const offsetLine = util.getArg(offset, "line");
        const offsetColumn = util.getArg(offset, "column");

        if (offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;

        const cons = new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL);
        return cons.then(consumer => {
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer
          };
        });
      })).then(s => {
        that._sections = s;
        return that;
      });
    });
  }

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.
  get _generatedMappings() {
    if (!this.__generatedMappings) {
      this._sortGeneratedMappings();
    }

    return this.__generatedMappings;
  }

  get _originalMappings() {
    if (!this.__originalMappings) {
      this._sortOriginalMappings();
    }

    return this.__originalMappings;
  }

  get _generatedMappingsUnsorted() {
    if (!this.__generatedMappingsUnsorted) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappingsUnsorted;
  }

  get _originalMappingsUnsorted() {
    if (!this.__originalMappingsUnsorted) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappingsUnsorted;
  }

  _sortGeneratedMappings() {
    const mappings = this._generatedMappingsUnsorted;
    mappings.sort(util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = mappings;
  }

  _sortOriginalMappings() {
    const mappings = this._originalMappingsUnsorted;
    mappings.sort(util.compareByOriginalPositions);
    this.__originalMappings = mappings;
  }

  /**
   * The list of original sources.
   */
  get sources() {
    const sources = [];
    for (let i = 0; i < this._sections.length; i++) {
      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  originalPositionFor(aArgs) {
    const needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    const sectionIndex = binarySearch.search(needle, this._sections,
      function(aNeedle, section) {
        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (aNeedle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    const section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  }

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  }

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  sourceContentFor(aSource, nullOnMissing) {
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      const content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  generatedPositionFor(aArgs) {
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      const generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        const ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    const generatedMappings = this.__generatedMappingsUnsorted = [];
    const originalMappings = this.__originalMappingsUnsorted = [];
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      const sectionMappings = [];
      section.consumer.eachMapping(m => sectionMappings.push(m));

      for (let j = 0; j < sectionMappings.length; j++) {
        const mapping = sectionMappings[j];

        // TODO: test if null is correct here.  The original code used
        // `source`, which would actually have gotten used as null because
        // var's get hoisted.
        // See: https://github.com/mozilla/source-map/issues/333
        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        let name = null;
        if (mapping.name) {
          this._names.add(mapping.name);
          name = this._names.indexOf(mapping.name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        const adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };

        generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          originalMappings.push(adjustedMapping);
        }
      }
    }
  }

  eachMapping(aCallback, aContext, aOrder) {
    const context = aContext || null;
    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    let mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    const sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      let source = null;
      if (mapping.source !== null) {
        source = this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      }
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  }

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  _findMapping(aNeedle, aMappings, aLineName,
              aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got "
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got "
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  }

  allGeneratedPositionsFor(aArgs) {
    const line = util.getArg(aArgs, "line");

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    const needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    if (needle.originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    const mappings = [];

    let index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      let mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        const originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn,
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        const originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn,
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  }

  destroy() {
    for (let i = 0; i < this._sections.length; i++) {
      this._sections[i].consumer.destroy();
    }
  }
}
__webpack_unused_export__ = IndexedSourceMapConsumer;

/*
 * Cheat to get around inter-twingled classes.  `factory()` can be at the end
 * where it has access to non-hoisted classes, but it gets hoisted itself.
 */
function _factory(aSourceMap, aSourceMapURL) {
  let sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  const consumer = sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  return Promise.resolve(consumer);
}

function _factoryBSM(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}


/***/ }),

/***/ 8302:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


// high-level commands
__webpack_unused_export__ = /* unused reexport */ __webpack_require__(4656)
__webpack_unused_export__ = /* unused reexport */ __webpack_require__(7150)
__webpack_unused_export__ = /* unused reexport */ __webpack_require__(4832)
__webpack_unused_export__ = /* unused reexport */ __webpack_require__(1621)
__webpack_unused_export__ = /* unused reexport */ __webpack_require__(6559)

// classes
/* unused reexport */ __webpack_require__(3593)
/* unused reexport */ __webpack_require__(8646)
exports.Parse = __webpack_require__(5009)
/* unused reexport */ __webpack_require__(3009)
/* unused reexport */ __webpack_require__(1996)
/* unused reexport */ __webpack_require__(877)
/* unused reexport */ __webpack_require__(8087)
/* unused reexport */ __webpack_require__(6543)


/***/ }),

/***/ 8477:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e=__webpack_require__(7810);function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k="function"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}
function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;


/***/ }),

/***/ 8537:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const SourceMapGenerator = (__webpack_require__(6991)/* .SourceMapGenerator */ .x);
const util = __webpack_require__(7061);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
const REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
const NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
const isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
class SourceNode {
  constructor(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    const node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    let remainingLinesIndex = 0;
    const shiftNextLine = function() {
      const lineContents = getNextLine();
      // The last line of a file might not have a newline.
      const newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    let lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    let lastMapping = null;
    let nextLine;

    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          nextLine = remainingLines[remainingLinesIndex] || "";
          const code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      const content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        const source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  }

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  }

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (let i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  }

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  walk(aFn) {
    let chunk;
    for (let i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else if (chunk !== "") {
        aFn(chunk, { source: this.source,
                      line: this.line,
                      column: this.column,
                      name: this.name });
      }
    }
  }

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  join(aSep) {
    let newChildren;
    let i;
    const len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  }

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  replaceRight(aPattern, aReplacement) {
    const lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  }

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  }

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  walkSourceContents(aFn) {
    for (let i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    const sources = Object.keys(this.sourceContents);
    for (let i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  }

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  toString() {
    let str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  }

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  toStringWithSourceMap(aArgs) {
    const generated = {
      code: "",
      line: 1,
      column: 0
    };
    const map = new SourceMapGenerator(aArgs);
    let sourceMappingActive = false;
    let lastOriginalSource = null;
    let lastOriginalLine = null;
    let lastOriginalColumn = null;
    let lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if (lastOriginalSource !== original.source
          || lastOriginalLine !== original.line
          || lastOriginalColumn !== original.column
          || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (let idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map };
  }
}

__webpack_unused_export__ = SourceNode;


/***/ }),

/***/ 8567:
/***/ ((module) => {

"use strict";


// When writing files on Windows, translate the characters to their
// 0xf000 higher-encoded versions.

const raw = [
  '|',
  '<',
  '>',
  '?',
  ':',
]

const win = raw.map(char =>
  String.fromCharCode(0xf000 + char.charCodeAt(0)))

const toWin = new Map(raw.map((char, i) => [char, win[i]]))
const toRaw = new Map(win.map((char, i) => [char, raw[i]]))

module.exports = {
  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),
  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),
}


/***/ }),

/***/ 8607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const proc = typeof process === 'object' && process ? process : {
  stdout: null,
  stderr: null,
}
const EE = __webpack_require__(4434)
const Stream = __webpack_require__(2203)
const SD = (__webpack_require__(3193).StringDecoder)

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const EMITTED_ERROR = Symbol('emittedError')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
const DESTROYED = Symbol('destroyed')
const EMITDATA = Symbol('emitData')
const EMITEND = Symbol('emitEnd')
const EMITEND2 = Symbol('emitEnd2')
const ASYNC = Symbol('async')

const defer = fn => Promise.resolve().then(fn)

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'
const ASYNCITERATOR = doIter && Symbol.asyncIterator
  || Symbol('asyncIterator not implemented')
const ITERATOR = doIter && Symbol.iterator
  || Symbol('iterator not implemented')

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev =>
  ev === 'end' ||
  ev === 'finish' ||
  ev === 'prefinish'

const isArrayBuffer = b => b instanceof ArrayBuffer ||
  typeof b === 'object' &&
  b.constructor &&
  b.constructor.name === 'ArrayBuffer' &&
  b.byteLength >= 0

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

class Pipe {
  constructor (src, dest, opts) {
    this.src = src
    this.dest = dest
    this.opts = opts
    this.ondrain = () => src[RESUME]()
    dest.on('drain', this.ondrain)
  }
  unpipe () {
    this.dest.removeListener('drain', this.ondrain)
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors () {}
  end () {
    this.unpipe()
    if (this.opts.end)
      this.dest.end()
  }
}

class PipeProxyErrors extends Pipe {
  unpipe () {
    this.src.removeListener('error', this.proxyErrors)
    super.unpipe()
  }
  constructor (src, dest, opts) {
    super(src, dest, opts)
    this.proxyErrors = er => dest.emit('error', er)
    src.on('error', this.proxyErrors)
  }
}

module.exports = class Minipass extends Stream {
  constructor (options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this.pipes = []
    this.buffer = []
    this[OBJECTMODE] = options && options.objectMode || false
    if (this[OBJECTMODE])
      this[ENCODING] = null
    else
      this[ENCODING] = options && options.encoding || null
    if (this[ENCODING] === 'buffer')
      this[ENCODING] = null
    this[ASYNC] = options && !!options.async || false
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this[EMITTED_ERROR] = null
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
  }

  get bufferLength () { return this[BUFFERLENGTH] }

  get encoding () { return this[ENCODING] }
  set encoding (enc) {
    if (this[OBJECTMODE])
      throw new Error('cannot set encoding in objectMode')

    if (this[ENCODING] && enc !== this[ENCODING] &&
        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this.buffer.length)
        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding (enc) {
    this.encoding = enc
  }

  get objectMode () { return this[OBJECTMODE] }
  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }

  get ['async'] () { return this[ASYNC] }
  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }

  write (chunk, encoding, cb) {
    if (this[EOF])
      throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit('error', Object.assign(
        new Error('Cannot call write after a stream was destroyed'),
        { code: 'ERR_STREAM_DESTROYED' }
      ))
      return true
    }

    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (!encoding)
      encoding = 'utf8'

    const fn = this[ASYNC] ? defer : f => f()

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk))
        chunk = Buffer.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true)

      if (this.flowing)
        this.emit('data', chunk)
      else
        this[BUFFERPUSH](chunk)

      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')

      if (cb)
        fn(cb)

      return this.flowing
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        fn(cb)
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (typeof chunk === 'string' &&
        // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
      chunk = Buffer.from(chunk, encoding)
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true)

    if (this.flowing)
      this.emit('data', chunk)
    else
      this[BUFFERPUSH](chunk)

    if (this[BUFFERLENGTH] !== 0)
      this.emit('readable')

    if (cb)
      fn(cb)

    return this.flowing
  }

  read (n) {
    if (this[DESTROYED])
      return null

    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]()
      return null
    }

    if (this[OBJECTMODE])
      n = null

    if (this.buffer.length > 1 && !this[OBJECTMODE]) {
      if (this.encoding)
        this.buffer = [this.buffer.join('')]
      else
        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]
    }

    const ret = this[READ](n || null, this.buffer[0])
    this[MAYBE_EMIT_END]()
    return ret
  }

  [READ] (n, chunk) {
    if (n === chunk.length || n === null)
      this[BUFFERSHIFT]()
    else {
      this.buffer[0] = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')

    return chunk
  }

  end (chunk, encoding, cb) {
    if (typeof chunk === 'function')
      cb = chunk, chunk = null
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'
    if (chunk)
      this.write(chunk, encoding)
    if (cb)
      this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED])
      this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME] () {
    if (this[DESTROYED])
      return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this.buffer.length)
      this[FLUSH]()
    else if (this[EOF])
      this[MAYBE_EMIT_END]()
    else
      this.emit('drain')
  }

  resume () {
    return this[RESUME]()
  }

  pause () {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed () {
    return this[DESTROYED]
  }

  get flowing () {
    return this[FLOWING]
  }

  get paused () {
    return this[PAUSED]
  }

  [BUFFERPUSH] (chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1
    else
      this[BUFFERLENGTH] += chunk.length
    this.buffer.push(chunk)
  }

  [BUFFERSHIFT] () {
    if (this.buffer.length) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1
      else
        this[BUFFERLENGTH] -= this.buffer[0].length
    }
    return this.buffer.shift()
  }

  [FLUSH] (noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

    if (!noDrain && !this.buffer.length && !this[EOF])
      this.emit('drain')
  }

  [FLUSHCHUNK] (chunk) {
    return chunk ? (this.emit('data', chunk), this.flowing) : false
  }

  pipe (dest, opts) {
    if (this[DESTROYED])
      return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false
    else
      opts.end = opts.end !== false
    opts.proxyErrors = !!opts.proxyErrors

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end)
        dest.end()
    } else {
      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)
        : new PipeProxyErrors(this, dest, opts))
      if (this[ASYNC])
        defer(() => this[RESUME]())
      else
        this[RESUME]()
    }

    return dest
  }

  unpipe (dest) {
    const p = this.pipes.find(p => p.dest === dest)
    if (p) {
      this.pipes.splice(this.pipes.indexOf(p), 1)
      p.unpipe()
    }
  }

  addListener (ev, fn) {
    return this.on(ev, fn)
  }

  on (ev, fn) {
    const ret = super.on(ev, fn)
    if (ev === 'data' && !this.pipes.length && !this.flowing)
      this[RESUME]()
    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)
      super.emit('readable')
    else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev)
      this.removeAllListeners(ev)
    } else if (ev === 'error' && this[EMITTED_ERROR]) {
      if (this[ASYNC])
        defer(() => fn.call(this, this[EMITTED_ERROR]))
      else
        fn.call(this, this[EMITTED_ERROR])
    }
    return ret
  }

  get emittedEnd () {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END] () {
    if (!this[EMITTING_END] &&
        !this[EMITTED_END] &&
        !this[DESTROYED] &&
        this.buffer.length === 0 &&
        this[EOF]) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED])
        this.emit('close')
      this[EMITTING_END] = false
    }
  }

  emit (ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      return !data ? false
        : this[ASYNC] ? defer(() => this[EMITDATA](data))
        : this[EMITDATA](data)
    } else if (ev === 'end') {
      return this[EMITEND]()
    } else if (ev === 'close') {
      this[CLOSED] = true
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED])
        return
      const ret = super.emit('close')
      this.removeAllListeners('close')
      return ret
    } else if (ev === 'error') {
      this[EMITTED_ERROR] = data
      const ret = super.emit('error', data)
      this[MAYBE_EMIT_END]()
      return ret
    } else if (ev === 'resume') {
      const ret = super.emit('resume')
      this[MAYBE_EMIT_END]()
      return ret
    } else if (ev === 'finish' || ev === 'prefinish') {
      const ret = super.emit(ev)
      this.removeAllListeners(ev)
      return ret
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra)
    this[MAYBE_EMIT_END]()
    return ret
  }

  [EMITDATA] (data) {
    for (const p of this.pipes) {
      if (p.dest.write(data) === false)
        this.pause()
    }
    const ret = super.emit('data', data)
    this[MAYBE_EMIT_END]()
    return ret
  }

  [EMITEND] () {
    if (this[EMITTED_END])
      return

    this[EMITTED_END] = true
    this.readable = false
    if (this[ASYNC])
      defer(() => this[EMITEND2]())
    else
      this[EMITEND2]()
  }

  [EMITEND2] () {
    if (this[DECODER]) {
      const data = this[DECODER].end()
      if (data) {
        for (const p of this.pipes) {
          p.dest.write(data)
        }
        super.emit('data', data)
      }
    }

    for (const p of this.pipes) {
      p.end()
    }
    const ret = super.emit('end')
    this.removeAllListeners('end')
    return ret
  }

  // const all = await stream.collect()
  collect () {
    const buf = []
    if (!this[OBJECTMODE])
      buf.dataLength = 0
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise()
    this.on('data', c => {
      buf.push(c)
      if (!this[OBJECTMODE])
        buf.dataLength += c.length
    })
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat () {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))
  }

  // stream.promise().then(() => done, er => emitted error)
  promise () {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')))
      this.on('error', er => reject(er))
      this.on('end', () => resolve())
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR] () {
    const next = () => {
      const res = this.read()
      if (res !== null)
        return Promise.resolve({ done: false, value: res })

      if (this[EOF])
        return Promise.resolve({ done: true })

      let resolve = null
      let reject = null
      const onerr = er => {
        this.removeListener('data', ondata)
        this.removeListener('end', onend)
        reject(er)
      }
      const ondata = value => {
        this.removeListener('error', onerr)
        this.removeListener('end', onend)
        this.pause()
        resolve({ value: value, done: !!this[EOF] })
      }
      const onend = () => {
        this.removeListener('error', onerr)
        this.removeListener('data', ondata)
        resolve({ done: true })
      }
      const ondestroy = () => onerr(new Error('stream destroyed'))
      return new Promise((res, rej) => {
        reject = rej
        resolve = res
        this.once(DESTROYED, ondestroy)
        this.once('error', onerr)
        this.once('end', onend)
        this.once('data', ondata)
      })
    }

    return { next }
  }

  // for (let chunk of stream)
  [ITERATOR] () {
    const next = () => {
      const value = this.read()
      const done = value === null
      return { value, done }
    }
    return { next }
  }

  destroy (er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit('error', er)
      else
        this.emit(DESTROYED)
      return this
    }

    this[DESTROYED] = true

    // throw away all buffered data, it's never coming out
    this.buffer.length = 0
    this[BUFFERLENGTH] = 0

    if (typeof this.close === 'function' && !this[CLOSED])
      this.close()

    if (er)
      this.emit('error', er)
    else // if no error to emit, still reject pending promises
      this.emit(DESTROYED)

    return this
  }

  static isStream (s) {
    return !!s && (s instanceof Minipass || s instanceof Stream ||
      s instanceof EE && (
        typeof s.pipe === 'function' || // readable
        (typeof s.write === 'function' && typeof s.end === 'function') // writable
      ))
  }
}


/***/ }),

/***/ 8646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)

const assert = __webpack_require__(2613)
const Parser = __webpack_require__(5009)
const fs = __webpack_require__(9896)
const fsm = __webpack_require__(5733)
const path = __webpack_require__(6928)
const mkdir = __webpack_require__(9149)
const wc = __webpack_require__(8567)
const pathReservations = __webpack_require__(5823)
const stripAbsolutePath = __webpack_require__(314)
const normPath = __webpack_require__(3373)
const stripSlash = __webpack_require__(8725)
const normalize = __webpack_require__(5995)

const ONENTRY = Symbol('onEntry')
const CHECKFS = Symbol('checkFs')
const CHECKFS2 = Symbol('checkFs2')
const PRUNECACHE = Symbol('pruneCache')
const ISREUSABLE = Symbol('isReusable')
const MAKEFS = Symbol('makeFs')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const LINK = Symbol('link')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const UNSUPPORTED = Symbol('unsupported')
const CHECKPATH = Symbol('checkPath')
const MKDIR = Symbol('mkdir')
const ONERROR = Symbol('onError')
const PENDING = Symbol('pending')
const PEND = Symbol('pend')
const UNPEND = Symbol('unpend')
const ENDED = Symbol('ended')
const MAYBECLOSE = Symbol('maybeClose')
const SKIP = Symbol('skip')
const DOCHOWN = Symbol('doChown')
const UID = Symbol('uid')
const GID = Symbol('gid')
const CHECKED_CWD = Symbol('checkedCwd')
const crypto = __webpack_require__(6982)
const getFlag = __webpack_require__(4831)
const platform = {}.TESTING_TAR_FAKE_PLATFORM || process.platform
const isWindows = platform === 'win32'
const DEFAULT_MAX_DEPTH = 1024

// Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183
/* istanbul ignore next */
const unlinkFile = (path, cb) => {
  if (!isWindows) {
    return fs.unlink(path, cb)
  }

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.rename(path, name, er => {
    if (er) {
      return cb(er)
    }
    fs.unlink(name, cb)
  })
}

/* istanbul ignore next */
const unlinkFileSync = path => {
  if (!isWindows) {
    return fs.unlinkSync(path)
  }

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.renameSync(path, name)
  fs.unlinkSync(name)
}

// this.gid, entry.gid, this.processUid
const uint32 = (a, b, c) =>
  a === a >>> 0 ? a
  : b === b >>> 0 ? b
  : c

// clear the cache if it's a case-insensitive unicode-squashing match.
// we can't know if the current file system is case-sensitive or supports
// unicode fully, so we check for similarity on the maximally compatible
// representation.  Err on the side of pruning, since all it's doing is
// preventing lstats, and it's not the end of the world if we get a false
// positive.
// Note that on windows, we always drop the entire cache whenever a
// symbolic link is encountered, because 8.3 filenames are impossible
// to reason about, and collisions are hazards rather than just failures.
const cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))
  .toLowerCase()

const pruneCache = (cache, abs) => {
  abs = cacheKeyNormalize(abs)
  for (const path of cache.keys()) {
    const pnorm = cacheKeyNormalize(path)
    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {
      cache.delete(path)
    }
  }
}

const dropCache = cache => {
  for (const key of cache.keys()) {
    cache.delete(key)
  }
}

class Unpack extends Parser {
  constructor (opt) {
    if (!opt) {
      opt = {}
    }

    opt.ondone = _ => {
      this[ENDED] = true
      this[MAYBECLOSE]()
    }

    super(opt)

    this[CHECKED_CWD] = false

    this.reservations = pathReservations()

    this.transform = typeof opt.transform === 'function' ? opt.transform : null

    this.writable = true
    this.readable = false

    this[PENDING] = 0
    this[ENDED] = false

    this.dirCache = opt.dirCache || new Map()

    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
      // need both or neither
      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {
        throw new TypeError('cannot set owner without number uid and gid')
      }
      if (opt.preserveOwner) {
        throw new TypeError(
          'cannot preserve owner in archive and also set owner explicitly')
      }
      this.uid = opt.uid
      this.gid = opt.gid
      this.setOwner = true
    } else {
      this.uid = null
      this.gid = null
      this.setOwner = false
    }

    // default true for root
    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {
      this.preserveOwner = process.getuid && process.getuid() === 0
    } else {
      this.preserveOwner = !!opt.preserveOwner
    }

    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?
      process.getuid() : null
    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?
      process.getgid() : null

    // prevent excessively deep nesting of subfolders
    // set to `Infinity` to remove this restriction
    this.maxDepth = typeof opt.maxDepth === 'number'
      ? opt.maxDepth
      : DEFAULT_MAX_DEPTH

    // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what
    this.forceChown = opt.forceChown === true

    // turn ><?| in filenames into 0xf000-higher encoded forms
    this.win32 = !!opt.win32 || isWindows

    // do not unpack over files that are newer than what's in the archive
    this.newer = !!opt.newer

    // do not unpack over ANY files
    this.keep = !!opt.keep

    // do not set mtime/atime of extracted entries
    this.noMtime = !!opt.noMtime

    // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path
    this.preservePaths = !!opt.preservePaths

    // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring
    this.unlink = !!opt.unlink

    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))
    this.strip = +opt.strip || 0
    // if we're not chmodding, then we don't need the process umask
    this.processUmask = opt.noChmod ? 0 : process.umask()
    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask

    // default mode for dirs created as parents
    this.dmode = opt.dmode || (0o0777 & (~this.umask))
    this.fmode = opt.fmode || (0o0666 & (~this.umask))

    this.on('entry', entry => this[ONENTRY](entry))
  }

  // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.
  warn (code, msg, data = {}) {
    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {
      data.recoverable = false
    }
    return super.warn(code, msg, data)
  }

  [MAYBECLOSE] () {
    if (this[ENDED] && this[PENDING] === 0) {
      this.emit('prefinish')
      this.emit('finish')
      this.emit('end')
    }
  }

  [CHECKPATH] (entry) {
    const p = normPath(entry.path)
    const parts = p.split('/')

    if (this.strip) {
      if (parts.length < this.strip) {
        return false
      }
      if (entry.type === 'Link') {
        const linkparts = normPath(entry.linkpath).split('/')
        if (linkparts.length >= this.strip) {
          entry.linkpath = linkparts.slice(this.strip).join('/')
        } else {
          return false
        }
      }
      parts.splice(0, this.strip)
      entry.path = parts.join('/')
    }

    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {
        entry,
        path: p,
        depth: parts.length,
        maxDepth: this.maxDepth,
      })
      return false
    }

    if (!this.preservePaths) {
      if (parts.includes('..') || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {
          entry,
          path: p,
        })
        return false
      }

      // strip off the root
      const [root, stripped] = stripAbsolutePath(p)
      if (root) {
        entry.path = stripped
        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {
          entry,
          path: p,
        })
      }
    }

    if (path.isAbsolute(entry.path)) {
      entry.absolute = normPath(path.resolve(entry.path))
    } else {
      entry.absolute = normPath(path.resolve(this.cwd, entry.path))
    }

    // if we somehow ended up with a path that escapes the cwd, and we are
    // not in preservePaths mode, then something is fishy!  This should have
    // been prevented above, so ignore this for coverage.
    /* istanbul ignore if - defense in depth */
    if (!this.preservePaths &&
        entry.absolute.indexOf(this.cwd + '/') !== 0 &&
        entry.absolute !== this.cwd) {
      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {
        entry,
        path: normPath(entry.path),
        resolvedPath: entry.absolute,
        cwd: this.cwd,
      })
      return false
    }

    // an archive can set properties on the extraction directory, but it
    // may not replace the cwd with a different kind of thing entirely.
    if (entry.absolute === this.cwd &&
        entry.type !== 'Directory' &&
        entry.type !== 'GNUDumpDir') {
      return false
    }

    // only encode : chars that aren't drive letter indicators
    if (this.win32) {
      const { root: aRoot } = path.win32.parse(entry.absolute)
      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))
      const { root: pRoot } = path.win32.parse(entry.path)
      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))
    }

    return true
  }

  [ONENTRY] (entry) {
    if (!this[CHECKPATH](entry)) {
      return entry.resume()
    }

    assert.equal(typeof entry.absolute, 'string')

    switch (entry.type) {
      case 'Directory':
      case 'GNUDumpDir':
        if (entry.mode) {
          entry.mode = entry.mode | 0o700
        }

      // eslint-disable-next-line no-fallthrough
      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
      case 'Link':
      case 'SymbolicLink':
        return this[CHECKFS](entry)

      case 'CharacterDevice':
      case 'BlockDevice':
      case 'FIFO':
      default:
        return this[UNSUPPORTED](entry)
    }
  }

  [ONERROR] (er, entry) {
    // Cwd has to exist, or else nothing works. That's serious.
    // Other errors are warnings, which raise the error in strict
    // mode, but otherwise continue on.
    if (er.name === 'CwdError') {
      this.emit('error', er)
    } else {
      this.warn('TAR_ENTRY_ERROR', er, { entry })
      this[UNPEND]()
      entry.resume()
    }
  }

  [MKDIR] (dir, mode, cb) {
    mkdir(normPath(dir), {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cache: this.dirCache,
      cwd: this.cwd,
      mode: mode,
      noChmod: this.noChmod,
    }, cb)
  }

  [DOCHOWN] (entry) {
    // in preserve owner mode, chown if the entry doesn't match process
    // in set owner mode, chown if setting doesn't match process
    return this.forceChown ||
      this.preserveOwner &&
      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||
        typeof entry.gid === 'number' && entry.gid !== this.processGid)
      ||
      (typeof this.uid === 'number' && this.uid !== this.processUid ||
        typeof this.gid === 'number' && this.gid !== this.processGid)
  }

  [UID] (entry) {
    return uint32(this.uid, entry.uid, this.processUid)
  }

  [GID] (entry) {
    return uint32(this.gid, entry.gid, this.processGid)
  }

  [FILE] (entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.fmode
    const stream = new fsm.WriteStream(entry.absolute, {
      flags: getFlag(entry.size),
      mode: mode,
      autoClose: false,
    })
    stream.on('error', er => {
      if (stream.fd) {
        fs.close(stream.fd, () => {})
      }

      // flush all the data out so that we aren't left hanging
      // if the error wasn't actually fatal.  otherwise the parse
      // is blocked, and we never proceed.
      stream.write = () => true
      this[ONERROR](er, entry)
      fullyDone()
    })

    let actions = 1
    const done = er => {
      if (er) {
        /* istanbul ignore else - we should always have a fd by now */
        if (stream.fd) {
          fs.close(stream.fd, () => {})
        }

        this[ONERROR](er, entry)
        fullyDone()
        return
      }

      if (--actions === 0) {
        fs.close(stream.fd, er => {
          if (er) {
            this[ONERROR](er, entry)
          } else {
            this[UNPEND]()
          }
          fullyDone()
        })
      }
    }

    stream.on('finish', _ => {
      // if futimes fails, try utimes
      // if utimes fails, fail with the original error
      // same for fchown/chown
      const abs = entry.absolute
      const fd = stream.fd

      if (entry.mtime && !this.noMtime) {
        actions++
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        fs.futimes(fd, atime, mtime, er =>
          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))
          : done())
      }

      if (this[DOCHOWN](entry)) {
        actions++
        const uid = this[UID](entry)
        const gid = this[GID](entry)
        fs.fchown(fd, uid, gid, er =>
          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))
          : done())
      }

      done()
    })

    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => {
        this[ONERROR](er, entry)
        fullyDone()
      })
      entry.pipe(tx)
    }
    tx.pipe(stream)
  }

  [DIRECTORY] (entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.dmode
    this[MKDIR](entry.absolute, mode, er => {
      if (er) {
        this[ONERROR](er, entry)
        fullyDone()
        return
      }

      let actions = 1
      const done = _ => {
        if (--actions === 0) {
          fullyDone()
          this[UNPEND]()
          entry.resume()
        }
      }

      if (entry.mtime && !this.noMtime) {
        actions++
        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)
      }

      if (this[DOCHOWN](entry)) {
        actions++
        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)
      }

      done()
    })
  }

  [UNSUPPORTED] (entry) {
    entry.unsupported = true
    this.warn('TAR_ENTRY_UNSUPPORTED',
      `unsupported entry type: ${entry.type}`, { entry })
    entry.resume()
  }

  [SYMLINK] (entry, done) {
    this[LINK](entry, entry.linkpath, 'symlink', done)
  }

  [HARDLINK] (entry, done) {
    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))
    this[LINK](entry, linkpath, 'link', done)
  }

  [PEND] () {
    this[PENDING]++
  }

  [UNPEND] () {
    this[PENDING]--
    this[MAYBECLOSE]()
  }

  [SKIP] (entry) {
    this[UNPEND]()
    entry.resume()
  }

  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE] (entry, st) {
    return entry.type === 'File' &&
      !this.unlink &&
      st.isFile() &&
      st.nlink <= 1 &&
      !isWindows
  }

  // check if a thing is there, and if so, try to clobber it
  [CHECKFS] (entry) {
    this[PEND]()
    const paths = [entry.path]
    if (entry.linkpath) {
      paths.push(entry.linkpath)
    }
    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))
  }

  [PRUNECACHE] (entry) {
    // if we are not creating a directory, and the path is in the dirCache,
    // then that means we are about to delete the directory we created
    // previously, and it is no longer going to be a directory, and neither
    // is any of its children.
    // If a symbolic link is encountered, all bets are off.  There is no
    // reasonable way to sanitize the cache in such a way we will be able to
    // avoid having filesystem collisions.  If this happens with a non-symlink
    // entry, it'll just fail to unpack, but a symlink to a directory, using an
    // 8.3 shortname or certain unicode attacks, can evade detection and lead
    // to arbitrary writes to anywhere on the system.
    if (entry.type === 'SymbolicLink') {
      dropCache(this.dirCache)
    } else if (entry.type !== 'Directory') {
      pruneCache(this.dirCache, entry.absolute)
    }
  }

  [CHECKFS2] (entry, fullyDone) {
    this[PRUNECACHE](entry)

    const done = er => {
      this[PRUNECACHE](entry)
      fullyDone(er)
    }

    const checkCwd = () => {
      this[MKDIR](this.cwd, this.dmode, er => {
        if (er) {
          this[ONERROR](er, entry)
          done()
          return
        }
        this[CHECKED_CWD] = true
        start()
      })
    }

    const start = () => {
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path.dirname(entry.absolute))
        if (parent !== this.cwd) {
          return this[MKDIR](parent, this.dmode, er => {
            if (er) {
              this[ONERROR](er, entry)
              done()
              return
            }
            afterMakeParent()
          })
        }
      }
      afterMakeParent()
    }

    const afterMakeParent = () => {
      fs.lstat(entry.absolute, (lstatEr, st) => {
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          this[SKIP](entry)
          done()
          return
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry, done)
        }

        if (st.isDirectory()) {
          if (entry.type === 'Directory') {
            const needChmod = !this.noChmod &&
              entry.mode &&
              (st.mode & 0o7777) !== entry.mode
            const afterChmod = er => this[MAKEFS](er, entry, done)
            if (!needChmod) {
              return afterChmod()
            }
            return fs.chmod(entry.absolute, entry.mode, afterChmod)
          }
          // Not a dir entry, have to remove it.
          // NB: the only way to end up with an entry that is the cwd
          // itself, in such a way that == does not detect, is a
          // tricky windows absolute path with UNC or 8.3 parts (and
          // preservePaths:true, or else it will have been stripped).
          // In that case, the user has opted out of path protections
          // explicitly, so if they blow away the cwd, c'est la vie.
          if (entry.absolute !== this.cwd) {
            return fs.rmdir(entry.absolute, er =>
              this[MAKEFS](er, entry, done))
          }
        }

        // not a dir, and not reusable
        // don't remove if the cwd, we want that error
        if (entry.absolute === this.cwd) {
          return this[MAKEFS](null, entry, done)
        }

        unlinkFile(entry.absolute, er =>
          this[MAKEFS](er, entry, done))
      })
    }

    if (this[CHECKED_CWD]) {
      start()
    } else {
      checkCwd()
    }
  }

  [MAKEFS] (er, entry, done) {
    if (er) {
      this[ONERROR](er, entry)
      done()
      return
    }

    switch (entry.type) {
      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
        return this[FILE](entry, done)

      case 'Link':
        return this[HARDLINK](entry, done)

      case 'SymbolicLink':
        return this[SYMLINK](entry, done)

      case 'Directory':
      case 'GNUDumpDir':
        return this[DIRECTORY](entry, done)
    }
  }

  [LINK] (entry, linkpath, link, done) {
    // XXX: get the type ('symlink' or 'junction') for windows
    fs[link](linkpath, entry.absolute, er => {
      if (er) {
        this[ONERROR](er, entry)
      } else {
        this[UNPEND]()
        entry.resume()
      }
      done()
    })
  }
}

const callSync = fn => {
  try {
    return [null, fn()]
  } catch (er) {
    return [er, null]
  }
}
class UnpackSync extends Unpack {
  [MAKEFS] (er, entry) {
    return super[MAKEFS](er, entry, () => {})
  }

  [CHECKFS] (entry) {
    this[PRUNECACHE](entry)

    if (!this[CHECKED_CWD]) {
      const er = this[MKDIR](this.cwd, this.dmode)
      if (er) {
        return this[ONERROR](er, entry)
      }
      this[CHECKED_CWD] = true
    }

    // don't bother to make the parent if the current entry is the cwd,
    // we've already checked it.
    if (entry.absolute !== this.cwd) {
      const parent = normPath(path.dirname(entry.absolute))
      if (parent !== this.cwd) {
        const mkParent = this[MKDIR](parent, this.dmode)
        if (mkParent) {
          return this[ONERROR](mkParent, entry)
        }
      }
    }

    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))
    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
      return this[SKIP](entry)
    }

    if (lstatEr || this[ISREUSABLE](entry, st)) {
      return this[MAKEFS](null, entry)
    }

    if (st.isDirectory()) {
      if (entry.type === 'Directory') {
        const needChmod = !this.noChmod &&
          entry.mode &&
          (st.mode & 0o7777) !== entry.mode
        const [er] = needChmod ? callSync(() => {
          fs.chmodSync(entry.absolute, entry.mode)
        }) : []
        return this[MAKEFS](er, entry)
      }
      // not a dir entry, have to remove it
      const [er] = callSync(() => fs.rmdirSync(entry.absolute))
      this[MAKEFS](er, entry)
    }

    // not a dir, and not reusable.
    // don't remove if it's the cwd, since we want that error.
    const [er] = entry.absolute === this.cwd ? []
      : callSync(() => unlinkFileSync(entry.absolute))
    this[MAKEFS](er, entry)
  }

  [FILE] (entry, done) {
    const mode = entry.mode & 0o7777 || this.fmode

    const oner = er => {
      let closeError
      try {
        fs.closeSync(fd)
      } catch (e) {
        closeError = e
      }
      if (er || closeError) {
        this[ONERROR](er || closeError, entry)
      }
      done()
    }

    let fd
    try {
      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)
    } catch (er) {
      return oner(er)
    }
    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => this[ONERROR](er, entry))
      entry.pipe(tx)
    }

    tx.on('data', chunk => {
      try {
        fs.writeSync(fd, chunk, 0, chunk.length)
      } catch (er) {
        oner(er)
      }
    })

    tx.on('end', _ => {
      let er = null
      // try both, falling futimes back to utimes
      // if either fails, handle the first error
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        try {
          fs.futimesSync(fd, atime, mtime)
        } catch (futimeser) {
          try {
            fs.utimesSync(entry.absolute, atime, mtime)
          } catch (utimeser) {
            er = futimeser
          }
        }
      }

      if (this[DOCHOWN](entry)) {
        const uid = this[UID](entry)
        const gid = this[GID](entry)

        try {
          fs.fchownSync(fd, uid, gid)
        } catch (fchowner) {
          try {
            fs.chownSync(entry.absolute, uid, gid)
          } catch (chowner) {
            er = er || fchowner
          }
        }
      }

      oner(er)
    })
  }

  [DIRECTORY] (entry, done) {
    const mode = entry.mode & 0o7777 || this.dmode
    const er = this[MKDIR](entry.absolute, mode)
    if (er) {
      this[ONERROR](er, entry)
      done()
      return
    }
    if (entry.mtime && !this.noMtime) {
      try {
        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)
      } catch (er) {}
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))
      } catch (er) {}
    }
    done()
    entry.resume()
  }

  [MKDIR] (dir, mode) {
    try {
      return mkdir.sync(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode,
      })
    } catch (er) {
      return er
    }
  }

  [LINK] (entry, linkpath, link, done) {
    try {
      fs[link + 'Sync'](linkpath, entry.absolute)
      done()
      entry.resume()
    } catch (er) {
      return this[ONERROR](er, entry)
    }
  }
}

Unpack.Sync = UnpackSync
module.exports = Unpack


/***/ }),

/***/ 8725:
/***/ ((module) => {

// warning: extremely hot code path.
// This has been meticulously optimized for use
// within npm install on large package trees.
// Do not edit without careful benchmarking.
module.exports = str => {
  let i = str.length - 1
  let slashesStart = -1
  while (i > -1 && str.charAt(i) === '/') {
    slashesStart = i
    i--
  }
  return slashesStart === -1 ? str : str.slice(0, slashesStart)
}


/***/ }),

/***/ 8790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const platform = {}.__TESTING_MKDIRP_PLATFORM__ || process.platform
const { resolve, parse } = __webpack_require__(6928)
const pathArg = path => {
  if (/\0/.test(path)) {
    // simulate same failure that node raises
    throw Object.assign(
      new TypeError('path must be a string without null bytes'),
      {
        path,
        code: 'ERR_INVALID_ARG_VALUE',
      }
    )
  }

  path = resolve(path)
  if (platform === 'win32') {
    const badWinChars = /[*|"<>?:]/
    const {root} = parse(path)
    if (badWinChars.test(path.substr(root.length))) {
      throw Object.assign(new Error('Illegal characters in path.'), {
        path,
        code: 'EINVAL',
      })
    }
  }

  return path
}
module.exports = pathArg


/***/ }),

/***/ 9023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9122:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = '';

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (arg) {
				classes = appendClass(classes, parseValue(arg));
			}
		}

		return classes;
	}

	function parseValue (arg) {
		if (typeof arg === 'string' || typeof arg === 'number') {
			return arg;
		}

		if (typeof arg !== 'object') {
			return '';
		}

		if (Array.isArray(arg)) {
			return classNames.apply(null, arg);
		}

		if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
			return arg.toString();
		}

		var classes = '';

		for (var key in arg) {
			if (hasOwn.call(arg, key) && arg[key]) {
				classes = appendClass(classes, key);
			}
		}

		return classes;
	}

	function appendClass (value, newClass) {
		if (!newClass) {
			return value;
		}
	
		if (value) {
			return value + ' ' + newClass;
		}
	
		return value + newClass;
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ 9149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = __webpack_require__(2034)
const fs = __webpack_require__(9896)
const path = __webpack_require__(6928)
const chownr = __webpack_require__(1697)
const normPath = __webpack_require__(3373)

class SymlinkError extends Error {
  constructor (symlink, path) {
    super('Cannot extract through symbolic link')
    this.path = path
    this.symlink = symlink
  }

  get name () {
    return 'SylinkError'
  }
}

class CwdError extends Error {
  constructor (path, code) {
    super(code + ': Cannot cd into \'' + path + '\'')
    this.path = path
    this.code = code
  }

  get name () {
    return 'CwdError'
  }
}

const cGet = (cache, key) => cache.get(normPath(key))
const cSet = (cache, key, val) => cache.set(normPath(key), val)

const checkCwd = (dir, cb) => {
  fs.stat(dir, (er, st) => {
    if (er || !st.isDirectory()) {
      er = new CwdError(dir, er && er.code || 'ENOTDIR')
    }
    cb(er)
  })
}

module.exports = (dir, opt, cb) => {
  dir = normPath(dir)

  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    (uid !== opt.processUid || gid !== opt.processGid)

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = normPath(opt.cwd)

  const done = (er, created) => {
    if (er) {
      cb(er)
    } else {
      cSet(cache, dir, true)
      if (created && doChown) {
        chownr(created, uid, gid, er => done(er))
      } else if (needChmod) {
        fs.chmod(dir, mode, cb)
      } else {
        cb()
      }
    }
  }

  if (cache && cGet(cache, dir) === true) {
    return done()
  }

  if (dir === cwd) {
    return checkCwd(dir, done)
  }

  if (preserve) {
    return mkdirp(dir, { mode }).then(made => done(null, made), done)
  }

  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
}

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length) {
    return cb(null, created)
  }
  const p = parts.shift()
  const part = normPath(path.resolve(base + '/' + p))
  if (cGet(cache, part)) {
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
}

const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
  if (er) {
    fs.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normPath(statEr.path)
        cb(statEr)
      } else if (st.isDirectory()) {
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
      } else if (unlink) {
        fs.unlink(part, er => {
          if (er) {
            return cb(er)
          }
          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
        })
      } else if (st.isSymbolicLink()) {
        return cb(new SymlinkError(part, part + '/' + parts.join('/')))
      } else {
        cb(er)
      }
    })
  } else {
    created = created || part
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
}

const checkCwdSync = dir => {
  let ok = false
  let code = 'ENOTDIR'
  try {
    ok = fs.statSync(dir).isDirectory()
  } catch (er) {
    code = er.code
  } finally {
    if (!ok) {
      throw new CwdError(dir, code)
    }
  }
}

module.exports.sync = (dir, opt) => {
  dir = normPath(dir)
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    (uid !== opt.processUid || gid !== opt.processGid)

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = normPath(opt.cwd)

  const done = (created) => {
    cSet(cache, dir, true)
    if (created && doChown) {
      chownr.sync(created, uid, gid)
    }
    if (needChmod) {
      fs.chmodSync(dir, mode)
    }
  }

  if (cache && cGet(cache, dir) === true) {
    return done()
  }

  if (dir === cwd) {
    checkCwdSync(cwd)
    return done()
  }

  if (preserve) {
    return done(mkdirp.sync(dir, mode))
  }

  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
  let created = null
  for (let p = parts.shift(), part = cwd;
    p && (part += '/' + p);
    p = parts.shift()) {
    part = normPath(path.resolve(part))
    if (cGet(cache, part)) {
      continue
    }

    try {
      fs.mkdirSync(part, mode)
      created = created || part
      cSet(cache, part, true)
    } catch (er) {
      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cSet(cache, part, true)
        continue
      } else if (unlink) {
        fs.unlinkSync(part)
        fs.mkdirSync(part, mode)
        created = created || part
        cSet(cache, part, true)
        continue
      } else if (st.isSymbolicLink()) {
        return new SymlinkError(part, part + '/' + parts.join('/'))
      }
    }
  }

  return done(created)
}


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ 9874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* Determine browser vs node environment by testing the default top level context. Solution courtesy of: https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser */
const isBrowserEnvironment = (function() {
    // eslint-disable-next-line no-undef
    return (typeof window !== "undefined") && (this === window);
}).call();

if (isBrowserEnvironment) {
  // Web version of reading a wasm file into an array buffer.

  let mappingsWasm = null;

  module.exports = function readWasm() {
    if (typeof mappingsWasm === "string") {
      return fetch(mappingsWasm)
        .then(response => response.arrayBuffer());
    }
    if (mappingsWasm instanceof ArrayBuffer) {
      return Promise.resolve(mappingsWasm);
    }
    throw new Error("You must provide the string URL or ArrayBuffer contents " +
                    "of lib/mappings.wasm by calling " +
                    "SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) " +
                    "before using SourceMapConsumer");
  };

  module.exports.initialize = input => mappingsWasm = input;
} else {
  // Node version of reading a wasm file into an array buffer.
  const fs = __webpack_require__(9896);
  const path = __webpack_require__(6928);

  module.exports = function readWasm() {
    return new Promise((resolve, reject) => {
      const wasmPath = path.join(__dirname, "mappings.wasm");
      fs.readFile(wasmPath, null, (error, data) => {
        if (error) {
          reject(error);
          return;
        }

        resolve(data.buffer);
      });
    });
  };

  module.exports.initialize = _ => {
    console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
  };
}


/***/ }),

/***/ 9896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + {"231":"blueprint-icons-split-paths-by-size-loader","672":"blueprint-icons-16px-paths","783":"blueprint-icons-20px-paths","824":"blueprint-icons-all-paths-loader","860":"blueprint-icons-all-paths"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "pritunl:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "./static/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			524: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = global["webpackChunkpritunl"] = global["webpackChunkpritunl"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/source-map/source-map.js
var source_map = __webpack_require__(219);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(7810);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(2483);
;// ./node_modules/@blueprintjs/core/lib/esm/common/alignment.js
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Alignment along the horizontal axis. */
var Alignment = {
    CENTER: "center",
    END: "end",
    /**
     * @deprecated use `Alignment.START` instead.
     */
    LEFT: "left",
    /**
     * @deprecated use `Alignment.END` instead.
     */
    RIGHT: "right",
    START: "start",
};
var TextAlignment = {
    CENTER: "center",
    END: "end",
    START: "start",
};

;// ./node_modules/@blueprintjs/core/lib/esm/common/elevation.js
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable sort-keys */
var Elevation = {
    ZERO: 0,
    ONE: 1,
    TWO: 2,
    THREE: 3,
    FOUR: 4,
};

;// ./node_modules/@blueprintjs/core/lib/esm/common/intent.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable sort-keys */
/**
 * The four basic intents.
 */
var Intent = {
    NONE: "none",
    PRIMARY: "primary",
    SUCCESS: "success",
    WARNING: "warning",
    DANGER: "danger",
};

;// ./node_modules/@blueprintjs/core/lib/esm/common/position.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Position = {
    BOTTOM: "bottom",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    LEFT: "left",
    LEFT_BOTTOM: "left-bottom",
    LEFT_TOP: "left-top",
    RIGHT: "right",
    RIGHT_BOTTOM: "right-bottom",
    RIGHT_TOP: "right-top",
    TOP: "top",
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right",
};
function isPositionHorizontal(position) {
    /* istanbul ignore next */
    return (position === Position.TOP ||
        position === Position.TOP_LEFT ||
        position === Position.TOP_RIGHT ||
        position === Position.BOTTOM ||
        position === Position.BOTTOM_LEFT ||
        position === Position.BOTTOM_RIGHT);
}
function isPositionVertical(position) {
    /* istanbul ignore next */
    return (position === Position.LEFT ||
        position === Position.LEFT_TOP ||
        position === Position.LEFT_BOTTOM ||
        position === Position.RIGHT ||
        position === Position.RIGHT_TOP ||
        position === Position.RIGHT_BOTTOM);
}
function getPositionIgnoreAngles(position) {
    if (position === Position.TOP || position === Position.TOP_LEFT || position === Position.TOP_RIGHT) {
        return Position.TOP;
    }
    else if (position === Position.BOTTOM ||
        position === Position.BOTTOM_LEFT ||
        position === Position.BOTTOM_RIGHT) {
        return Position.BOTTOM;
    }
    else if (position === Position.LEFT || position === Position.LEFT_TOP || position === Position.LEFT_BOTTOM) {
        return Position.LEFT;
    }
    else {
        return Position.RIGHT;
    }
}

;// ./node_modules/@blueprintjs/core/lib/esm/common/classes.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var NS = "bp5";
if (typeof BLUEPRINT_NAMESPACE !== "undefined") {
    NS = BLUEPRINT_NAMESPACE;
}
else if (typeof REACT_APP_BLUEPRINT_NAMESPACE !== "undefined") {
    NS = REACT_APP_BLUEPRINT_NAMESPACE;
}
// modifiers
var ACTIVE = "".concat(NS, "-active");
var ALIGN_LEFT = "".concat(NS, "-align-left");
var ALIGN_RIGHT = "".concat(NS, "-align-right");
var COMPACT = "".concat(NS, "-compact");
var DARK = "".concat(NS, "-dark");
var DISABLED = "".concat(NS, "-disabled");
var FILL = "".concat(NS, "-fill");
var FIXED = "".concat(NS, "-fixed");
var FIXED_TOP = "".concat(NS, "-fixed-top");
var INLINE = "".concat(NS, "-inline");
var INTERACTIVE = "".concat(NS, "-interactive");
var LARGE = "".concat(NS, "-large");
var LOADING = "".concat(NS, "-loading");
var MINIMAL = "".concat(NS, "-minimal");
var OUTLINED = "".concat(NS, "-outlined");
var PADDED = "".concat(NS, "-padded");
var MULTILINE = "".concat(NS, "-multiline");
var READ_ONLY = "".concat(NS, "-read-only");
var ROUND = "".concat(NS, "-round");
var SELECTED = "".concat(NS, "-selected");
var SMALL = "".concat(NS, "-small");
var VERTICAL = "".concat(NS, "-vertical");
var POSITION_TOP = positionClass(Position.TOP);
var POSITION_BOTTOM = positionClass(Position.BOTTOM);
var POSITION_LEFT = positionClass(Position.LEFT);
var POSITION_RIGHT = positionClass(Position.RIGHT);
var ELEVATION_0 = elevationClass(Elevation.ZERO);
var ELEVATION_1 = elevationClass(Elevation.ONE);
var ELEVATION_2 = elevationClass(Elevation.TWO);
var ELEVATION_3 = elevationClass(Elevation.THREE);
var ELEVATION_4 = elevationClass(Elevation.FOUR);
var INTENT_PRIMARY = classes_intentClass(Intent.PRIMARY);
var INTENT_SUCCESS = classes_intentClass(Intent.SUCCESS);
var INTENT_WARNING = classes_intentClass(Intent.WARNING);
var INTENT_DANGER = classes_intentClass(Intent.DANGER);
var FOCUS_DISABLED = "".concat(NS, "-focus-disabled");
var FOCUS_STYLE_MANAGER_IGNORE = "".concat(NS, "-focus-style-manager-ignore");
// text utilities
var UI_TEXT = "".concat(NS, "-ui-text");
var RUNNING_TEXT = "".concat(NS, "-running-text");
var MONOSPACE_TEXT = "".concat(NS, "-monospace-text");
var TEXT_LARGE = "".concat(NS, "-text-large");
var TEXT_SMALL = "".concat(NS, "-text-small");
var TEXT_MUTED = "".concat(NS, "-text-muted");
var TEXT_DISABLED = "".concat(NS, "-text-disabled");
var TEXT_OVERFLOW_ELLIPSIS = "".concat(NS, "-text-overflow-ellipsis");
// textual elements
var BLOCKQUOTE = "".concat(NS, "-blockquote");
var CODE = "".concat(NS, "-code");
var CODE_BLOCK = "".concat(NS, "-code-block");
var HEADING = "".concat(NS, "-heading");
var LIST = "".concat(NS, "-list");
var LIST_UNSTYLED = "".concat(NS, "-list-unstyled");
var RTL = "".concat(NS, "-rtl");
// components
var ALERT = "".concat(NS, "-alert");
var ALERT_BODY = "".concat(ALERT, "-body");
var ALERT_CONTENTS = "".concat(ALERT, "-contents");
var ALERT_FOOTER = "".concat(ALERT, "-footer");
var BREADCRUMB = "".concat(NS, "-breadcrumb");
var BREADCRUMB_CURRENT = "".concat(BREADCRUMB, "-current");
var BREADCRUMBS = "".concat(BREADCRUMB, "s");
var BREADCRUMBS_COLLAPSED = "".concat(BREADCRUMB, "s-collapsed");
var BUTTON = "".concat(NS, "-button");
var BUTTON_GROUP = "".concat(BUTTON, "-group");
var BUTTON_SPINNER = "".concat(BUTTON, "-spinner");
var BUTTON_TEXT = "".concat(BUTTON, "-text");
var CALLOUT = "".concat(NS, "-callout");
var CALLOUT_HAS_BODY_CONTENT = "".concat(CALLOUT, "-has-body-content");
var CALLOUT_ICON = "".concat(CALLOUT, "-icon");
var CARD = "".concat(NS, "-card");
var CONTROL_CARD = "".concat(NS, "-control-card");
var CONTROL_CARD_LABEL = "".concat(CONTROL_CARD, "-label");
var SWITCH_CONTROL_CARD = "".concat(NS, "-switch-control-card");
var CHECKBOX_CONTROL_CARD = "".concat(NS, "-checkbox-control-card");
var RADIO_CONTROL_CARD = "".concat(NS, "-radio-control-card");
var CARD_LIST = "".concat(NS, "-card-list");
var CARD_LIST_BORDERED = "".concat(CARD_LIST, "-bordered");
var COLLAPSE = "".concat(NS, "-collapse");
var COLLAPSE_BODY = "".concat(COLLAPSE, "-body");
var CONTEXT_MENU = "".concat(NS, "-context-menu");
var CONTEXT_MENU_VIRTUAL_TARGET = "".concat(CONTEXT_MENU, "-virtual-target");
var CONTEXT_MENU_POPOVER = "".concat(CONTEXT_MENU, "-popover");
var CONTEXT_MENU_BACKDROP = "".concat(CONTEXT_MENU, "-backdrop");
var CONTROL_GROUP = "".concat(NS, "-control-group");
var DIALOG = "".concat(NS, "-dialog");
var DIALOG_CONTAINER = "".concat(DIALOG, "-container");
var DIALOG_HEADER = "".concat(DIALOG, "-header");
var DIALOG_BODY = "".concat(DIALOG, "-body");
var DIALOG_BODY_SCROLL_CONTAINER = "".concat(DIALOG, "-body-scroll-container");
var DIALOG_CLOSE_BUTTON = "".concat(DIALOG, "-close-button");
var DIALOG_FOOTER = "".concat(DIALOG, "-footer");
var DIALOG_FOOTER_FIXED = "".concat(DIALOG, "-footer-fixed");
var DIALOG_FOOTER_MAIN_SECTION = "".concat(DIALOG, "-footer-main-section");
var DIALOG_FOOTER_ACTIONS = "".concat(DIALOG, "-footer-actions");
var DIALOG_STEP = "".concat(NS, "-dialog-step");
var DIALOG_STEP_CONTAINER = "".concat(DIALOG_STEP, "-container");
var DIALOG_STEP_TITLE = "".concat(DIALOG_STEP, "-title");
var DIALOG_STEP_ICON = "".concat(DIALOG_STEP, "-icon");
var DIALOG_STEP_VIEWED = "".concat(DIALOG_STEP, "-viewed");
var DIVIDER = "".concat(NS, "-divider");
var DRAWER = "".concat(NS, "-drawer");
var DRAWER_BODY = "".concat(DRAWER, "-body");
var DRAWER_FOOTER = "".concat(DRAWER, "-footer");
var DRAWER_HEADER = "".concat(DRAWER, "-header");
var EDITABLE_TEXT = "".concat(NS, "-editable-text");
var EDITABLE_TEXT_CONTENT = "".concat(EDITABLE_TEXT, "-content");
var EDITABLE_TEXT_EDITING = "".concat(EDITABLE_TEXT, "-editing");
var EDITABLE_TEXT_INPUT = "".concat(EDITABLE_TEXT, "-input");
var EDITABLE_TEXT_PLACEHOLDER = "".concat(EDITABLE_TEXT, "-placeholder");
var ENTITY_TITLE = "".concat(NS, "-entity-title");
var ENTITY_TITLE_ELLIPSIZE = "".concat(NS, "-entity-title-ellipsize");
var ENTITY_TITLE_HAS_SUBTITLE = "".concat(ENTITY_TITLE, "-has-subtitle");
var ENTITY_TITLE_ICON_CONTAINER = "".concat(ENTITY_TITLE, "-icon-container");
var ENTITY_TITLE_SUBTITLE = "".concat(ENTITY_TITLE, "-subtitle");
var ENTITY_TITLE_TAGS_CONTAINER = "".concat(ENTITY_TITLE, "-tags-container");
var ENTITY_TITLE_TEXT = "".concat(ENTITY_TITLE, "-text");
var ENTITY_TITLE_TITLE = "".concat(ENTITY_TITLE, "-title");
var ENTITY_TITLE_TITLE_AND_TAGS = "".concat(ENTITY_TITLE, "-title-and-tags");
var FLEX_EXPANDER = "".concat(NS, "-flex-expander");
var HTML_SELECT = "".concat(NS, "-html-select");
/** @deprecated use `<HTMLSelect>` component or `Classes.HTML_SELECT` instead */
var SELECT = "".concat(NS, "-select");
var HTML_TABLE = "".concat(NS, "-html-table");
var HTML_TABLE_BORDERED = "".concat(HTML_TABLE, "-bordered");
var HTML_TABLE_STRIPED = "".concat(HTML_TABLE, "-striped");
var INPUT = "".concat(NS, "-input");
var INPUT_GHOST = "".concat(INPUT, "-ghost");
var INPUT_GROUP = "".concat(INPUT, "-group");
var INPUT_LEFT_CONTAINER = "".concat(INPUT, "-left-container");
var INPUT_ACTION = "".concat(INPUT, "-action");
var RESIZABLE_INPUT_SPAN = "".concat(NS, "-resizable-input-span");
var TEXT_AREA = "".concat(NS, "-text-area");
var TEXT_AREA_AUTO_RESIZE = "".concat(TEXT_AREA, "-auto-resize");
var CONTROL = "".concat(NS, "-control");
var CONTROL_INDICATOR = "".concat(CONTROL, "-indicator");
var CONTROL_INDICATOR_CHILD = "".concat(CONTROL_INDICATOR, "-child");
var CHECKBOX = "".concat(NS, "-checkbox");
var RADIO = "".concat(NS, "-radio");
var RADIO_GROUP = "".concat(NS, "-radio-group");
var SWITCH = "".concat(NS, "-switch");
var SWITCH_INNER_TEXT = "".concat(SWITCH, "-inner-text");
var FILE_INPUT = "".concat(NS, "-file-input");
var FILE_INPUT_HAS_SELECTION = "".concat(NS, "-file-input-has-selection");
var FILE_UPLOAD_INPUT = "".concat(NS, "-file-upload-input");
var FILE_UPLOAD_INPUT_CUSTOM_TEXT = "".concat(NS, "-file-upload-input-custom-text");
var KEY = "".concat(NS, "-key");
var KEY_COMBO = "".concat(KEY, "-combo");
var MODIFIER_KEY = "".concat(NS, "-modifier-key");
var HOTKEY = "".concat(NS, "-hotkey");
var HOTKEY_LABEL = "".concat(HOTKEY, "-label");
var HOTKEY_COLUMN = "".concat(HOTKEY, "-column");
var HOTKEY_DIALOG = "".concat(HOTKEY, "-dialog");
var LABEL = "".concat(NS, "-label");
var FORM_GROUP = "".concat(NS, "-form-group");
var FORM_CONTENT = "".concat(NS, "-form-content");
var FORM_HELPER_TEXT = "".concat(NS, "-form-helper-text");
var FORM_GROUP_SUB_LABEL = "".concat(NS, "-form-group-sub-label");
var MENU = "".concat(NS, "-menu");
var MENU_ITEM = "".concat(MENU, "-item");
var MENU_ITEM_IS_SELECTABLE = "".concat(MENU_ITEM, "-is-selectable");
var MENU_ITEM_SELECTED_ICON = "".concat(MENU_ITEM, "-selected-icon");
var MENU_ITEM_ICON = "".concat(MENU_ITEM, "-icon");
var MENU_ITEM_LABEL = "".concat(MENU_ITEM, "-label");
var MENU_SUBMENU = "".concat(NS, "-submenu");
var MENU_SUBMENU_ICON = "".concat(MENU_SUBMENU, "-icon");
var MENU_DIVIDER = "".concat(MENU, "-divider");
var MENU_HEADER = "".concat(MENU, "-header");
var MULTISTEP_DIALOG = "".concat(NS, "-multistep-dialog");
var MULTISTEP_DIALOG_PANELS = "".concat(MULTISTEP_DIALOG, "-panels");
var MULTISTEP_DIALOG_LEFT_PANEL = "".concat(MULTISTEP_DIALOG, "-left-panel");
var MULTISTEP_DIALOG_RIGHT_PANEL = "".concat(MULTISTEP_DIALOG, "-right-panel");
var MULTISTEP_DIALOG_NAV_TOP = "".concat(MULTISTEP_DIALOG, "-nav-top");
var MULTISTEP_DIALOG_NAV_RIGHT = "".concat(MULTISTEP_DIALOG, "-nav-right");
var SECTION = "".concat(NS, "-section");
var SECTION_COLLAPSED = "".concat(SECTION, "-collapsed");
var SECTION_HEADER = "".concat(SECTION, "-header");
var SECTION_HEADER_LEFT = "".concat(SECTION_HEADER, "-left");
var SECTION_HEADER_TITLE = "".concat(SECTION_HEADER, "-title");
var SECTION_HEADER_SUB_TITLE = "".concat(SECTION_HEADER, "-sub-title");
var SECTION_HEADER_DIVIDER = "".concat(SECTION_HEADER, "-divider");
var SECTION_HEADER_TABS = "".concat(SECTION_HEADER, "-tabs");
var SECTION_HEADER_RIGHT = "".concat(SECTION_HEADER, "-right");
var SECTION_HEADER_COLLAPSE_CARET = "".concat(SECTION_HEADER, "-collapse-caret");
var SECTION_CARD = "".concat(SECTION, "-card");
var NAVBAR = "".concat(NS, "-navbar");
var NAVBAR_GROUP = "".concat(NAVBAR, "-group");
var NAVBAR_HEADING = "".concat(NAVBAR, "-heading");
var NAVBAR_DIVIDER = "".concat(NAVBAR, "-divider");
var NON_IDEAL_STATE = "".concat(NS, "-non-ideal-state");
var NON_IDEAL_STATE_VISUAL = "".concat(NON_IDEAL_STATE, "-visual");
var NON_IDEAL_STATE_TEXT = "".concat(NON_IDEAL_STATE, "-text");
var NUMERIC_INPUT = "".concat(NS, "-numeric-input");
var OVERFLOW_LIST = "".concat(NS, "-overflow-list");
var OVERFLOW_LIST_SPACER = "".concat(OVERFLOW_LIST, "-spacer");
var OVERLAY = "".concat(NS, "-overlay");
var OVERLAY_BACKDROP = "".concat(OVERLAY, "-backdrop");
var OVERLAY_CONTAINER = "".concat(OVERLAY, "-container");
var OVERLAY_CONTENT = "".concat(OVERLAY, "-content");
var OVERLAY_INLINE = "".concat(OVERLAY, "-inline");
var OVERLAY_OPEN = "".concat(OVERLAY, "-open");
var OVERLAY_SCROLL_CONTAINER = "".concat(OVERLAY, "-scroll-container");
var OVERLAY_START_FOCUS_TRAP = "".concat(OVERLAY, "-start-focus-trap");
var OVERLAY_END_FOCUS_TRAP = "".concat(OVERLAY, "-end-focus-trap");
var PANEL_STACK = "".concat(NS, "-panel-stack");
var PANEL_STACK_HEADER = "".concat(PANEL_STACK, "-header");
var PANEL_STACK_HEADER_BACK = "".concat(PANEL_STACK, "-header-back");
var PANEL_STACK_VIEW = "".concat(PANEL_STACK, "-view");
var PANEL_STACK2 = "".concat(NS, "-panel-stack2");
var PANEL_STACK2_HEADER = "".concat(PANEL_STACK2, "-header");
var PANEL_STACK2_HEADER_BACK = "".concat(PANEL_STACK2, "-header-back");
var PANEL_STACK2_VIEW = "".concat(PANEL_STACK2, "-view");
var POPOVER = "".concat(NS, "-popover");
var POPOVER_ARROW = "".concat(POPOVER, "-arrow");
var POPOVER_BACKDROP = "".concat(POPOVER, "-backdrop");
var POPOVER_CAPTURING_DISMISS = "".concat(POPOVER, "-capturing-dismiss");
var POPOVER_CONTENT = "".concat(POPOVER, "-content");
var POPOVER_CONTENT_PLACEMENT = "".concat(POPOVER, "-placement");
var POPOVER_CONTENT_SIZING = "".concat(POPOVER_CONTENT, "-sizing");
var POPOVER_DISMISS = "".concat(POPOVER, "-dismiss");
var POPOVER_DISMISS_OVERRIDE = "".concat(POPOVER_DISMISS, "-override");
var POPOVER_MATCH_TARGET_WIDTH = "".concat(POPOVER, "-match-target-width");
var POPOVER_OPEN = "".concat(POPOVER, "-open");
var POPOVER_POPPER_ESCAPED = "".concat(POPOVER, "-popper-escaped");
var POPOVER_REFERENCE_HIDDEN = "".concat(POPOVER, "-reference-hidden");
var POPOVER_TARGET = "".concat(POPOVER, "-target");
var POPOVER_TRANSITION_CONTAINER = "".concat(POPOVER, "-transition-container");
/** @deprecated, no longer used in Blueprint v5.x */
var POPOVER_WRAPPER = "".concat(POPOVER, "-wrapper");
var PROGRESS_BAR = "".concat(NS, "-progress-bar");
var PROGRESS_METER = "".concat(NS, "-progress-meter");
var PROGRESS_NO_STRIPES = "".concat(NS, "-no-stripes");
var PROGRESS_NO_ANIMATION = "".concat(NS, "-no-animation");
var PORTAL = "".concat(NS, "-portal");
var SKELETON = "".concat(NS, "-skeleton");
var SLIDER = "".concat(NS, "-slider");
var SLIDER_AXIS = "".concat(SLIDER, "-axis");
var SLIDER_HANDLE = "".concat(SLIDER, "-handle");
var SLIDER_LABEL = "".concat(SLIDER, "-label");
var SLIDER_TRACK = "".concat(SLIDER, "-track");
var SLIDER_PROGRESS = "".concat(SLIDER, "-progress");
var START = "".concat(NS, "-start");
var END = "".concat(NS, "-end");
var SPINNER = "".concat(NS, "-spinner");
var SPINNER_ANIMATION = "".concat(SPINNER, "-animation");
var SPINNER_HEAD = "".concat(SPINNER, "-head");
var SPINNER_NO_SPIN = "".concat(NS, "-no-spin");
var SPINNER_TRACK = "".concat(SPINNER, "-track");
var SEGMENTED_CONTROL = "".concat(NS, "-segmented-control");
var TAB = "".concat(NS, "-tab");
var TAB_ICON = "".concat(TAB, "-icon");
var TAB_TAG = "".concat(TAB, "-tag");
var TAB_INDICATOR = "".concat(TAB, "-indicator");
var TAB_INDICATOR_WRAPPER = "".concat(TAB_INDICATOR, "-wrapper");
var TAB_LIST = "".concat(TAB, "-list");
var TAB_PANEL = "".concat(TAB, "-panel");
var TABS = "".concat(TAB, "s");
var TAG = "".concat(NS, "-tag");
var TAG_REMOVE = "".concat(TAG, "-remove");
var COMPOUND_TAG = "".concat(NS, "-compound-tag");
var COMPOUND_TAG_LEFT = "".concat(COMPOUND_TAG, "-left");
var COMPOUND_TAG_LEFT_CONTENT = "".concat(COMPOUND_TAG, "-left-content");
var COMPOUND_TAG_RIGHT = "".concat(COMPOUND_TAG, "-right");
var COMPOUND_TAG_RIGHT_CONTENT = "".concat(COMPOUND_TAG, "-right-content");
var TAG_INPUT = "".concat(NS, "-tag-input");
var TAG_INPUT_ICON = "".concat(TAG_INPUT, "-icon");
var TAG_INPUT_VALUES = "".concat(TAG_INPUT, "-values");
var TOAST = "".concat(NS, "-toast");
var TOAST_CONTAINER = "".concat(TOAST, "-container");
var TOAST_MESSAGE = "".concat(TOAST, "-message");
var TOOLTIP = "".concat(NS, "-tooltip");
var TOOLTIP_INDICATOR = "".concat(TOOLTIP, "-indicator");
var TREE = "".concat(NS, "-tree");
var TREE_NODE = "".concat(NS, "-tree-node");
var TREE_NODE_CARET = "".concat(TREE_NODE, "-caret");
var TREE_NODE_CARET_CLOSED = "".concat(TREE_NODE_CARET, "-closed");
var TREE_NODE_CARET_NONE = "".concat(TREE_NODE_CARET, "-none");
var TREE_NODE_CARET_OPEN = "".concat(TREE_NODE_CARET, "-open");
var TREE_NODE_CONTENT = "".concat(TREE_NODE, "-content");
var TREE_NODE_EXPANDED = "".concat(TREE_NODE, "-expanded");
var TREE_NODE_ICON = "".concat(TREE_NODE, "-icon");
var TREE_NODE_LABEL = "".concat(TREE_NODE, "-label");
var TREE_NODE_LIST = "".concat(TREE_NODE, "-list");
var TREE_NODE_SECONDARY_LABEL = "".concat(TREE_NODE, "-secondary-label");
var TREE_NODE_SELECTED = "".concat(TREE_NODE, "-selected");
var TREE_ROOT = "".concat(NS, "-tree-root");
var ICON = "".concat(NS, "-icon");
var ICON_STANDARD = "".concat(ICON, "-standard");
var ICON_LARGE = "".concat(ICON, "-large");
var ICON_MUTED = "".concat(ICON, "-muted");
/**
 * Returns the namespace prefix for all Blueprint CSS classes.
 * Customize this namespace at build time by defining it with `webpack.DefinePlugin`.
 */
function getClassNamespace() {
    return NS;
}
/** Return CSS class for alignment. */
function alignmentClass(alignment) {
    switch (alignment) {
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        case Alignment.LEFT:
        case Alignment.START:
            return ALIGN_LEFT;
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        case Alignment.RIGHT:
        case Alignment.END:
            return ALIGN_RIGHT;
        default:
            return undefined;
    }
}
function elevationClass(elevation) {
    if (elevation === undefined) {
        return undefined;
    }
    return "".concat(NS, "-elevation-").concat(elevation);
}
function iconClass(iconName) {
    if (iconName == null) {
        return undefined;
    }
    return iconName.indexOf("".concat(NS, "-icon-")) === 0 ? iconName : "".concat(NS, "-icon-").concat(iconName);
}
function classes_intentClass(intent) {
    if (intent == null || intent === Intent.NONE) {
        return undefined;
    }
    return "".concat(NS, "-intent-").concat(intent.toLowerCase());
}
function positionClass(position) {
    if (position === undefined) {
        return undefined;
    }
    return "".concat(NS, "-position-").concat(position);
}
function sizeClass(size, legacyProps) {
    var _a;
    if (size === "small") {
        return SMALL;
    }
    if (size === "large") {
        return LARGE;
    }
    var _b = legacyProps.large, large = _b === void 0 ? false : _b, _c = legacyProps.small, small = _c === void 0 ? false : _c;
    return _a = {},
        _a[LARGE] = large,
        _a[SMALL] = small,
        _a;
}
function variantClass(variant, legacyProps) {
    var _a;
    // variant takes precedence over minimal and outlined
    if (variant === "outlined") {
        return OUTLINED;
    }
    if (variant === "minimal") {
        return MINIMAL;
    }
    var _b = legacyProps.minimal, minimal = _b === void 0 ? false : _b, _c = legacyProps.outlined, outlined = _c === void 0 ? false : _c;
    return _a = {},
        _a[MINIMAL] = minimal,
        _a[OUTLINED] = outlined,
        _a;
}

;// ./node_modules/@blueprintjs/core/lib/esm/common/interactionMode.js
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* istanbul ignore next */
/**
 * A nifty little class that maintains event handlers to add a class to the container element
 * when entering "mouse mode" (on a `mousedown` event) and remove it when entering "keyboard mode"
 * (on a `tab` key `keydown` event).
 */
var InteractionModeEngine = /** @class */ (function () {
    function InteractionModeEngine(container, className) {
        var _this = this;
        this.container = container;
        this.className = className;
        this.isRunning = false;
        this.handleKeyDown = function (e) {
            if (e.key === "Tab") {
                _this.reset();
                _this.container.addEventListener("mousedown", _this.handleMouseDown);
            }
        };
        this.handleMouseDown = function () {
            _this.reset();
            _this.container.classList.add(_this.className);
            _this.container.addEventListener("keydown", _this.handleKeyDown);
        };
    }
    /** Returns whether the engine is currently running. */
    InteractionModeEngine.prototype.isActive = function () {
        return this.isRunning;
    };
    /** Enable behavior which applies the given className when in mouse mode. */
    InteractionModeEngine.prototype.start = function () {
        this.container.addEventListener("mousedown", this.handleMouseDown);
        this.isRunning = true;
    };
    /** Disable interaction mode behavior and remove className from container. */
    InteractionModeEngine.prototype.stop = function () {
        this.reset();
        this.isRunning = false;
    };
    InteractionModeEngine.prototype.reset = function () {
        this.container.classList.remove(this.className);
        this.container.removeEventListener("keydown", this.handleKeyDown);
        this.container.removeEventListener("mousedown", this.handleMouseDown);
    };
    return InteractionModeEngine;
}());


;// ./node_modules/@blueprintjs/core/lib/esm/accessibility/focusStyleManager.js
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var fakeFocusEngine = {
    isActive: function () { return true; },
    start: function () { return true; },
    stop: function () { return true; },
};
var focusEngine = typeof document !== "undefined"
    ? new InteractionModeEngine(document.documentElement, FOCUS_DISABLED)
    : fakeFocusEngine;
var FocusStyleManager = {
    alwaysShowFocus: function () { return focusEngine.stop(); },
    isActive: function () { return focusEngine.isActive(); },
    onlyShowFocusOnTabs: function () { return focusEngine.start(); },
};

;// external "electron"
const external_electron_namespaceObject = require("electron");
var external_electron_default = /*#__PURE__*/__webpack_require__.n(external_electron_namespaceObject);
;// ./app/Errors.js
class BaseError extends Error {
    constructor(name, wrapErr, message, args) {
        super();
        if (args) {
            for (let key in args) {
                message += " " + key + "=" + args[key];
            }
        }
        if (wrapErr) {
            message += '\n' + wrapErr;
        }
        this.name = name;
        this.message = message;
        if (wrapErr) {
            this.stack = wrapErr.stack;
        }
    }
}
class ReadError extends BaseError {
    constructor(wrapErr, message, args) {
        super("ReadError", wrapErr, message, args);
    }
}
class WriteError extends BaseError {
    constructor(wrapErr, message, args) {
        super("WriteError", wrapErr, message, args);
    }
}
class ParseError extends BaseError {
    constructor(wrapErr, message, args) {
        super("ParseError", wrapErr, message, args);
    }
}
class RequestError extends BaseError {
    constructor(wrapErr, message, args) {
        super("RequestError", wrapErr, message, args);
    }
}
class ExecError extends BaseError {
    constructor(wrapErr, message, args) {
        super("ExecError", wrapErr, message, args);
    }
}
class UnknownError extends BaseError {
    constructor(wrapErr, message, args) {
        super("UnknownError", wrapErr, message, args);
    }
}
class UnhandledError extends BaseError {
    constructor(wrapErr, message, origMessage, origStack) {
        super("UnhandledError", wrapErr, message, {
            message: origMessage,
            stack: origStack,
        });
        this.stack = origStack;
    }
}

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(1635);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(9122);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// ./node_modules/@blueprintjs/core/lib/esm/common/errors.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ns = "[Blueprint]";
var CLAMP_MIN_MAX = ns + " clamp: max cannot be less than min";
var ALERT_WARN_CANCEL_PROPS = ns + " <Alert> cancelButtonText and onCancel should be set together.";
var ALERT_WARN_CANCEL_ESCAPE_KEY = ns + " <Alert> canEscapeKeyCancel enabled without onCancel or onClose handler.";
var ALERT_WARN_CANCEL_OUTSIDE_CLICK = ns + " <Alert> canOutsideClickCancel enabled without onCancel or onClose handler.";
var ALIGN_INDICATOR_LEFT = ns + " alignIndicator=\"left\" is deprecated. Please use alignIndicator=\"start\" instead.";
var ALIGN_INDICATOR_RIGHT = ns + " alignIndicator=\"right\" is deprecated. Please use alignIndicator=\"end\" instead.";
var ALIGN_INDICATOR_CENTER = ns + "alignIndicator=\"center\" is not supported on control components and will be ignored.";
var ALIGN_TEXT_LEFT = ns + " alignText=\"left\" is deprecated. Please use alignText=\"start\" instead.";
var ALIGN_TEXT_RIGHT = ns + " alignText=\"right\" is deprecated. Please use alignText=\"end\" instead.";
var BUTTON_WARN_MINIMAL = ns + " <Button> minimal is deprecated. Please use variant=\"minimal\".";
var BUTTON_GROUP_WARN_MINIMAL = ns + " <ButtonGroup> minimal is deprecated. Please use variant=\"minimal\".";
var BUTTON_WARN_OUTLINED = ns + " <Button> outlined is deprecated. Please use variant=\"outlined\".";
var BUTTON_GROUP_WARN_OUTLINED = ns + " <ButtonGroup> outlined is deprecated. Please use variant=\"outlined\".";
var HOTKEYS_HOTKEY_CHILDREN = ns + " <Hotkeys> only accepts <Hotkey> children.";
var HOTKEYS_PROVIDER_NOT_FOUND = ns +
    " useHotkeys() was used outside of a <HotkeysProvider> context. These hotkeys will not be shown in the hotkeys help dialog.";
var HOTKEYS_TARGET_CHILDREN_LOCAL_HOTKEYS = ns +
    " <HotkeysTarget2> was configured with local hotkeys, but you did not use the generated event handlers to bind their event handlers. Try using a render function as the child of this component.";
var INPUT_WARN_LEFT_ELEMENT_LEFT_ICON_MUTEX = ns + " <InputGroup> leftElement and leftIcon prop are mutually exclusive, with leftElement taking priority.";
var NAVBAR_GROUP_ALIGN_CENTER = ns +
    " <NavbarGroup> does not support align=\"center\". Only \"left\" or \"right\" alignment is allowed, and align=\"center\" will be ignored.";
var NUMERIC_INPUT_MIN_MAX = ns + " <NumericInput> requires min to be no greater than max if both are defined.";
var NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND = ns + " <NumericInput> requires minorStepSize to be no greater than stepSize.";
var NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND = ns + " <NumericInput> requires stepSize to be no greater than majorStepSize.";
var NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE = ns + " <NumericInput> requires minorStepSize to be strictly greater than zero.";
var NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE = ns + " <NumericInput> requires majorStepSize to be strictly greater than zero.";
var NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE = ns + " <NumericInput> requires stepSize to be strictly greater than zero.";
var NUMERIC_INPUT_CONTROLLED_VALUE_INVALID = ns + " <NumericInput> controlled value prop does not adhere to stepSize, min, and/or max constraints.";
var PANEL_STACK_INITIAL_PANEL_STACK_MUTEX = ns + " <PanelStack> requires exactly one of initialPanel and stack prop";
var PANEL_STACK_REQUIRES_PANEL = ns + " <PanelStack> requires at least one panel in the stack";
var OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED = ns + " <OverflowList> does not support changing observeParents after mounting.";
var POPOVER_REQUIRES_TARGET = "".concat(ns, " <Popover> requires renderTarget prop or a child element.");
var POPOVER_HAS_BACKDROP_INTERACTION = "".concat(ns, " <Popover hasBackdrop={true}> requires interactionKind=\"click\".");
var POPOVER_WARN_TOO_MANY_CHILDREN = "".concat(ns, " <Popover> supports only one child which is rendered as its target; additional children are ignored.");
var POPOVER_WARN_DOUBLE_TARGET = ns + " <Popover> with children ignores renderTarget prop; use either prop or children.";
var POPOVER_WARN_EMPTY_CONTENT = ns + " Disabling <Popover> with empty/whitespace content...";
var POPOVER_WARN_HAS_BACKDROP_INLINE = ns + " <Popover usePortal={false}> ignores hasBackdrop";
var POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX = ns + " <Popover> supports either placement or position prop, not both.";
var POPOVER_WARN_UNCONTROLLED_ONINTERACTION = ns + " <Popover> onInteraction is ignored when uncontrolled.";
var POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET = ns + " <Popover> targetProps value is ignored when renderTarget API is used.";
var PORTAL_CONTEXT_CLASS_NAME_STRING = ns + " <Portal> context blueprintPortalClassName must be string";
var PORTAL_LEGACY_CONTEXT_API = ns + " setting blueprintPortalClassName via legacy React context API is deprecated, use <PortalProvider> instead.";
var RADIOGROUP_WARN_CHILDREN_OPTIONS_MUTEX = ns + " <RadioGroup> children and options prop are mutually exclusive, with options taking priority.";
var SLIDER_ZERO_STEP = ns + " <Slider> stepSize must be greater than zero.";
var SLIDER_ZERO_LABEL_STEP = ns + " <Slider> labelStepSize must be greater than zero.";
var SLIDER_MIN = ns + " <Slider> min prop must be a finite number.";
var SLIDER_MAX = ns + " <Slider> max prop must be a finite number.";
var RANGESLIDER_NULL_VALUE = ns + " <RangeSlider> value prop must be an array of two non-null numbers.";
var MULTISLIDER_INVALID_CHILD = ns + " <MultiSlider> children must be <SliderHandle>s or <SliderTrackStop>s";
var MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX = ns +
    " <MultiSlider> labelStepSize and labelValues prop are mutually exclusive, with labelStepSize taking priority.";
var SPINNER_WARN_CLASSES_SIZE = ns + " <Spinner> Classes.SMALL/LARGE are ignored if size prop is set.";
var TOASTER_CREATE_NULL = ns +
    " OverlayToaster.create() is not supported inside React lifecycle methods in React 16." +
    " See usage example on the docs site. https://blueprintjs.com/docs/#core/components/toast.example";
var TOASTER_CREATE_ASYNC_NULL = ns +
    " OverlayToaster.createAsync() received a null component ref. This can happen if called inside React lifecycle " +
    "methods in React 16. See usage example on the docs site. " +
    "https://blueprintjs.com/docs/#core/components/toast.example";
var TOASTER_MAX_TOASTS_INVALID = ns + " <OverlayToaster> maxToasts is set to an invalid number, must be greater than 0";
var TOASTER_WARN_INLINE = ns + " OverlayToaster.create() ignores inline prop as it always creates a new element.";
var DIALOG_WARN_NO_HEADER_ICON = ns + " <Dialog> iconName is ignored if title is omitted.";
var DIALOG_WARN_NO_HEADER_CLOSE_BUTTON = ns + " <Dialog> isCloseButtonShown prop is ignored if title is omitted.";
var DRAWER_ANGLE_POSITIONS_ARE_CASTED = ns + " <Drawer> all angle positions are casted into pure position (TOP, BOTTOM, LEFT or RIGHT)";
var OVERLAY2_REQUIRES_OVERLAY_PROVDER = ns +
    " <Overlay2> was used outside of a <OverlaysProvider> context. This will no longer be supported in " +
    "Blueprint v6. See https://github.com/palantir/blueprint/wiki/Overlay2-migration";
var OVERLAY_CHILD_REF_AND_REFS_MUTEX = ns + " <Overlay2> cannot use childRef and childRefs props simultaneously";
var OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS = ns + " <Overlay2> requires childRefs prop when rendering multiple child elements";
var OVERLAY_CHILD_REQUIRES_KEY = ns + " <Overlay2> requires each child element to have a unique key prop when childRefs is used";
function logDeprecatedSizeWarning(component, props) {
    var large = props.large, small = props.small;
    if (large && small) {
        console.warn(ns +
            " <".concat(component, "> large and small props are mutually exclusive. Please use size=\"large\" or size=\"small\" instead."));
    }
    else if (large) {
        console.warn(ns + " <".concat(component, "> large is deprecated. Please use size=\"large\" instead."));
    }
    else if (small) {
        console.warn(ns + " <".concat(component, "> small is deprecated. Please use size=\"small\" instead."));
    }
}

;// ./node_modules/@blueprintjs/core/lib/esm/common/utils/jsUtils.js
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Returns whether bundler-injected variable `NODE_ENV` equals `env`. */
function isNodeEnv(env) {
    return typeof NODE_ENV !== "undefined" && NODE_ENV === env;
}
/**
 * Returns the difference in length between two arrays. A `null` argument is
 * considered an empty list. The return value will be positive if `a` is longer
 * than `b`, negative if the opposite is true, and zero if their lengths are
 * equal.
 */
function arrayLengthCompare(a, b) {
    if (a === void 0) { a = []; }
    if (b === void 0) { b = []; }
    return a.length - b.length;
}
/**
 * Returns true if the two numbers are within the given tolerance of each other.
 * This is useful to correct for floating point precision issues, less useful
 * for integers.
 */
function approxEqual(a, b, tolerance) {
    if (tolerance === void 0) { tolerance = 0.00001; }
    return Math.abs(a - b) <= tolerance;
}
/**
 * Clamps the given number between min and max values. Returns value if within
 * range, or closest bound.
 */
function clamp(val, min, max) {
    if (val == null) {
        return val;
    }
    if (max < min) {
        throw new Error(CLAMP_MIN_MAX);
    }
    return Math.min(Math.max(val, min), max);
}
/** Returns the number of decimal places in the given number. */
function countDecimalPlaces(num) {
    if (!isFinite(num)) {
        return 0;
    }
    var e = 1;
    var p = 0;
    while (Math.round(num * e) / e !== num) {
        e *= 10;
        p++;
    }
    return p;
}
var uniqueCountForNamespace = new Map();
/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */
function uniqueId(namespace) {
    var _a;
    var curCount = (_a = uniqueCountForNamespace.get(namespace)) !== null && _a !== void 0 ? _a : 0;
    uniqueCountForNamespace.set(namespace, curCount + 1);
    return "".concat(namespace, "-").concat(curCount);
}
/**
 * @returns `true` if the value is an empty string after trimming whitespace
 */
function isEmptyString(val) {
    return typeof val === "string" && val.trim().length === 0;
}

;// ./node_modules/@blueprintjs/core/lib/esm/common/abstractPureComponent.js
/*
 * Copyright 2019 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * An abstract component that Blueprint components can extend
 * in order to add some common functionality like runtime props validation.
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
var AbstractPureComponent = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(AbstractPureComponent, _super);
    function AbstractPureComponent(props) {
        var _this = _super.call(this, props) || this;
        // Not bothering to remove entries when their timeouts finish because clearing invalid ID is a no-op
        _this.timeoutIds = [];
        _this.requestIds = [];
        /**
         * Clear all known timeouts.
         */
        _this.clearTimeouts = function () {
            if (_this.timeoutIds.length > 0) {
                for (var _i = 0, _a = _this.timeoutIds; _i < _a.length; _i++) {
                    var timeoutId = _a[_i];
                    window.clearTimeout(timeoutId);
                }
                _this.timeoutIds = [];
            }
        };
        /**
         * Clear all known animation frame requests.
         */
        _this.cancelAnimationFrames = function () {
            if (_this.requestIds.length > 0) {
                for (var _i = 0, _a = _this.requestIds; _i < _a.length; _i++) {
                    var requestId = _a[_i];
                    window.cancelAnimationFrame(requestId);
                }
                _this.requestIds = [];
            }
        };
        if (!isNodeEnv("production")) {
            _this.validateProps(_this.props);
        }
        return _this;
    }
    AbstractPureComponent.prototype.componentDidUpdate = function (_prevProps, _prevState, _snapshot) {
        if (!isNodeEnv("production")) {
            this.validateProps(this.props);
        }
    };
    AbstractPureComponent.prototype.componentWillUnmount = function () {
        this.clearTimeouts();
        this.cancelAnimationFrames();
    };
    /**
     * Request an animation frame and remember its ID.
     * All pending requests will be canceled when component unmounts.
     *
     * @returns a "cancel" function that will cancel the request when invoked.
     */
    AbstractPureComponent.prototype.requestAnimationFrame = function (callback) {
        var handle = window.requestAnimationFrame(callback);
        this.requestIds.push(handle);
        return function () { return window.cancelAnimationFrame(handle); };
    };
    /**
     * Set a timeout and remember its ID.
     * All pending timeouts will be cleared when component unmounts.
     *
     * @returns a "cancel" function that will clear timeout when invoked.
     */
    AbstractPureComponent.prototype.setTimeout = function (callback, timeout) {
        var handle = window.setTimeout(callback, timeout);
        this.timeoutIds.push(handle);
        return function () { return window.clearTimeout(handle); };
    };
    /**
     * Ensures that the props specified for a component are valid.
     * Implementations should check that props are valid and usually throw an Error if they are not.
     * Implementations should not duplicate checks that the type system already guarantees.
     *
     * This method should be used instead of React's
     * [propTypes](https://facebook.github.io/react/docs/reusable-components.html#prop-validation) feature.
     * Like propTypes, these runtime checks run only in development mode.
     */
    AbstractPureComponent.prototype.validateProps = function (_props) {
        // implement in subclass
    };
    return AbstractPureComponent;
}(react.PureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/common/props.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DISPLAYNAME_PREFIX = "Blueprint5";
/** A collection of curated prop keys used across our Components which are not valid HTMLElement props. */
var INVALID_PROPS = [
    "active",
    "alignText",
    "asyncControl", // InputGroupProps
    "containerRef",
    "current",
    "elementRef", // not used anymore in Blueprint v5.x, but kept for backcompat if consumers use this naming pattern
    "ellipsizeText", // ButtonProps
    "endIcon",
    "fill",
    "icon",
    "iconSize",
    "inputClassName",
    "inputRef",
    "intent",
    "inline",
    "large",
    "loading",
    "leftElement",
    "leftIcon",
    "minimal",
    "onRemove", // TagProps, TagInputProps
    "outlined", // ButtonProps
    "panel", // TabProps
    "panelClassName", // TabProps
    "popoverProps",
    "rightElement",
    "rightIcon",
    "round",
    "selectedValue",
    "size",
    "small",
    "tagName",
    "text",
    "textClassName", // ButtonProps
    "variant",
];
/**
 * Typically applied to HTMLElements to filter out disallowed props. When applied to a Component,
 * can filter props from being passed down to the children. Can also filter by a combined list of
 * supplied prop keys and the denylist (only appropriate for HTMLElements).
 *
 * @param props The original props object to filter down.
 * @param {string[]} invalidProps If supplied, overwrites the default denylist.
 * @param {boolean} shouldMerge If true, will merge supplied invalidProps and denylist together.
 */
function removeNonHTMLProps(props, invalidProps, shouldMerge) {
    if (invalidProps === void 0) { invalidProps = INVALID_PROPS; }
    if (shouldMerge === void 0) { shouldMerge = false; }
    if (shouldMerge) {
        invalidProps = invalidProps.concat(INVALID_PROPS);
    }
    return invalidProps.reduce(function (prev, curr) {
        // Props with hyphens (e.g. data-*) are always considered html props
        if (curr.indexOf("-") !== -1) {
            return prev;
        }
        if (prev.hasOwnProperty(curr)) {
            delete prev[curr];
        }
        return prev;
    }, (0,tslib_es6/* __assign */.Cl)({}, props));
}

;// ./node_modules/@blueprintjs/core/lib/esm/common/utils/reactUtils.js
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns true if `node` is null/undefined, false, empty string, or an array
 * composed of those. If `node` is an array, only one level of the array is
 * checked, for performance reasons.
 */
function isReactNodeEmpty(node, skipArray) {
    if (skipArray === void 0) { skipArray = false; }
    return (node == null ||
        node === "" ||
        node === false ||
        (!skipArray &&
            Array.isArray(node) &&
            // only recurse one level through arrays, for performance
            (node.length === 0 || node.every(function (n) { return isReactNodeEmpty(n, true); }))));
}
/**
 * Returns true if children are a mappable children array
 *
 * @internal
 */
function isReactChildrenElementOrElements(children) {
    return !isReactNodeEmpty(children, true) && children !== true;
}
/**
 * Converts a React node to an element. Non-empty strings, numbers, and Fragments will be wrapped in given tag name;
 * empty strings and booleans will be discarded.
 *
 * @param child     the React node to convert
 * @param tagName   the HTML tag name to use when a wrapper element is needed
 * @param props     additional props to spread onto the element, if any. If the child is a React element and this argument
 *                  is defined, the child will be cloned and these props will be merged in.
 */
function ensureElement(child, tagName, props) {
    if (tagName === void 0) { tagName = "span"; }
    if (props === void 0) { props = {}; }
    if (child == null || typeof child === "boolean" || isEmptyString(child)) {
        return undefined;
    }
    else if (typeof child === "string" ||
        typeof child === "number" ||
        isReactFragment(child) ||
        isReactNodeArray(child)) {
        // wrap the child element
        return react.createElement(tagName, props, child);
    }
    else if (isReactElement(child)) {
        if (Object.keys(props).length > 0) {
            // clone the element and merge props
            return react.cloneElement(child, props);
        }
        else {
            // nothing to do, it's a valid ReactElement
            return child;
        }
    }
    else {
        // child is inferred as {}
        return undefined;
    }
}
function isReactElement(child) {
    return (typeof child === "object" &&
        typeof child.type !== "undefined" &&
        typeof child.props !== "undefined");
}
function isReactFragment(child) {
    // bit hacky, but generally works
    return typeof child.type === "symbol";
}
function isReactNodeArray(child) {
    return Array.isArray(child);
}
/**
 * Returns true if the given JSX element matches the given component type.
 *
 * NOTE: This function only checks equality of `displayName` for performance and
 * to tolerate multiple minor versions of a component being included in one
 * application bundle.
 *
 * @param element JSX element in question
 * @param ComponentType desired component type of element
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
function isElementOfType(element, ComponentType) {
    return (element != null &&
        element.type != null &&
        element.type.displayName != null &&
        element.type.displayName === ComponentType.displayName);
}
function isReact18OrHigher() {
    var majorVersion = parseInt(react.version.split(".")[0], 10);
    return majorVersion >= 18;
}

;// ./node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}

;// ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

;// ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

;// ./node_modules/dom-helpers/esm/hasClass.js
/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
;// ./node_modules/dom-helpers/esm/addClass.js

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass_addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}
;// ./node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass_removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}
;// ./node_modules/react-transition-group/esm/config.js
/* harmony default export */ const config = ({
  disabled: false
});
;// ./node_modules/react-transition-group/esm/TransitionGroupContext.js

/* harmony default export */ const TransitionGroupContext = (react.createContext(null));
;// ./node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow(node) {
  return node.scrollTop;
};
;// ./node_modules/react-transition-group/esm/Transition.js









var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

          if (node) forceReflow(node);
        }

        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : react_dom.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        _in = _this$props.in,
        _mountOnEnter = _this$props.mountOnEnter,
        _unmountOnExit = _this$props.unmountOnExit,
        _appear = _this$props.appear,
        _enter = _this$props.enter,
        _exit = _this$props.exit,
        _timeout = _this$props.timeout,
        _addEndListener = _this$props.addEndListener,
        _onEnter = _this$props.onEnter,
        _onEntering = _this$props.onEntering,
        _onEntered = _this$props.onEntered,
        _onExit = _this$props.onExit,
        _onExiting = _this$props.onExiting,
        _onExited = _this$props.onExited,
        _nodeRef = _this$props.nodeRef,
        childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      react.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : react.cloneElement(react.Children.only(children), childProps))
    );
  };

  return Transition;
}(react.Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes =  false ? 0 : {}; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
/* harmony default export */ const esm_Transition = (Transition);
;// ./node_modules/react-transition-group/esm/CSSTransition.js











var _addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass_addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass_removeClass(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      if (node) forceReflow(node);
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        _ = _this$props.classNames,
        props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

    return /*#__PURE__*/react.createElement(esm_Transition, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(react.Component);

CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition.propTypes =  false ? 0 : {};
/* harmony default export */ const esm_CSSTransition = (CSSTransition);
;// ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

;// ./node_modules/react-transition-group/esm/utils/ChildMapping.js

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && (0,react.isValidElement)(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) react.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return (0,react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!(0,react.isValidElement)(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = (0,react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = (0,react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = (0,react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0,react.isValidElement)(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = (0,react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}
;// ./node_modules/react-transition-group/esm/TransitionGroup.js









var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/react.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/react.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/react.createElement(Component, props, children));
  };

  return TransitionGroup;
}(react.Component);

TransitionGroup.propTypes =  false ? 0 : {};
TransitionGroup.defaultProps = defaultProps;
/* harmony default export */ const esm_TransitionGroup = (TransitionGroup);
;// ./node_modules/react-uid/dist/es2015/uid.js
/**
 * generates a UID factory
 * @internal
 * @example
 * const uid = generateUID();
 * uid(object) = 1;
 * uid(object) = 1;
 * uid(anotherObject) = 2;
 */
var generateUID = function () {
    var counter = 1;
    var map = new WeakMap();
    /**
     * @borrows {uid}
     */
    var uid = function (item, index) {
        if (typeof item === 'number' || typeof item === 'string') {
            return index ? "idx-".concat(index) : "val-".concat(item);
        }
        if (!map.has(item)) {
            map.set(item, counter++);
            return uid(item);
        }
        return 'uid' + map.get(item);
    };
    return uid;
};
/**
 * @name uid
 * returns an UID associated with {item}
 * @param {Object} item - object to generate UID for
 * @param {Number} index, a fallback index
 * @example
 * uid(object) == 1;
 * uid(object) == 1;
 * uid(anotherObject) == 2;
 * uid("not object", 42) == 42
 *
 * @see {@link useUID}
 */
var uid = generateUID();

;// ./node_modules/react-uid/dist/es2015/context.js


var createSource = function (prefix) {
    if (prefix === void 0) { prefix = ''; }
    return ({
        value: 1,
        prefix: prefix,
        uid: generateUID(),
    });
};
var counter = createSource();
var source = react.createContext(createSource());
var getId = function (source) { return source.value++; };
var getPrefix = function (source) { return (source ? source.prefix : ''); };

;// ./node_modules/react-uid/dist/es2015/hooks.js



var hooks_generateUID = function (context) {
    var quartz = context || counter;
    var prefix = getPrefix(quartz);
    var id = getId(quartz);
    var uid = prefix + id;
    var gen = function (item) { return uid + quartz.uid(item); };
    return { uid: uid, gen: gen };
};
var useUIDState = function () {
    if (false) {}
    var context = (0,react.useContext)(source);
    var uid = (0,react.useState)(function () { return hooks_generateUID(context); })[0];
    return uid;
};
/**
 * returns and unique id. SSR friendly
 * returns {String}
 * @see {@link UIDConsumer}
 * @see https://github.com/thearnica/react-uid#hooks-168
 * @example
 * const id = useUID();
 * id == 1; // for example
 */
var useUID = function () {
    var uid = useUIDState().uid;
    return uid;
};
/**
 * returns an uid generator
 * @see {@link UIDConsumer}
 * @see https://github.com/thearnica/react-uid#hooks-168
 * @example
 * const uid = useUIDSeed();
 * return (
 *  <>
 *    <label for={seed('email')}>Email: </label>
 *    <input id={seed('email')} name="email" />
 *    {data.map(item => <div key={seed(item)}>...</div>
 *  </>
 * )
 */
var useUIDSeed = function () {
    var gen = useUIDState().gen;
    return gen;
};

;// ./node_modules/@blueprintjs/core/lib/esm/common/refs.js
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isRefObject(value) {
    return value != null && typeof value !== "function";
}
function isRefCallback(value) {
    return typeof value === "function";
}
/**
 * Assign the given ref to a target, either a React ref object or a callback which takes the ref as its first argument.
 */
function setRef(refTarget, ref) {
    if (isRefObject(refTarget)) {
        // HACKHACK: .current property is readonly
        refTarget.current = ref;
    }
    else if (isRefCallback(refTarget)) {
        refTarget(ref);
    }
}
/**
 * Utility for merging refs into one singular callback ref.
 * If using in a functional component, would recomend using `useMemo` to preserve function identity.
 */
function mergeRefs() {
    var refs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
    }
    return function (value) {
        refs.forEach(function (ref) {
            setRef(ref, value);
        });
    };
}
function getRef(ref) {
    if (ref === null) {
        return null;
    }
    if (typeof ref.current === "undefined") {
        return ref;
    }
    return ref.current;
}
/**
 * Creates a ref handler which assigns the ref returned by React for a mounted component to a field on the target object.
 * The target object is usually a component class.
 *
 * If provided, it will also update the given `refProp` with the value of the ref.
 */
function refHandler(refTargetParent, refTargetKey, refProp) {
    return function (ref) {
        refTargetParent[refTargetKey] = ref;
        setRef(refProp, ref);
    };
}

;// ./node_modules/@blueprintjs/core/lib/esm/common/utils/domUtils.js
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @returns true if React is running in a client environment, and false if it's in a server */
function hasDOMEnvironment() {
    return typeof window !== "undefined" && window.document != null;
}
function elementIsOrContains(element, testElement) {
    return element === testElement || element.contains(testElement);
}
/**
 * Checks whether the given element is inside something that looks like a text input.
 * This is particularly useful to determine if a keyboard event inside this element should take priority over hotkey
 * bindings / keyboard shortcut handlers.
 *
 * @returns true if the element is inside a text input
 */
function elementIsTextInput(elem) {
    // we check these cases for unit testing, but this should not happen
    // during normal operation
    if (elem == null || elem.closest == null) {
        return false;
    }
    var editable = elem.closest("input, textarea, [contenteditable=true]");
    if (editable == null) {
        return false;
    }
    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior
    if (editable.tagName.toLowerCase() === "input") {
        var inputType = editable.type;
        if (inputType === "checkbox" || inputType === "radio") {
            return false;
        }
    }
    // don't let read-only fields prevent hotkey behavior
    if (editable.readOnly) {
        return false;
    }
    return true;
}
/**
 * Gets the active element in the document or shadow root (if an element is provided, and it's in the shadow DOM).
 */
function getActiveElement(element, options) {
    var _a;
    var rootNode = ((_a = element === null || element === void 0 ? void 0 : element.getRootNode(options)) !== null && _a !== void 0 ? _a : document);
    var activeElement = rootNode.activeElement;
    return activeElement instanceof HTMLElement ? activeElement : null;
}
/**
 * Throttle an event on an EventTarget by wrapping it in a
 * `requestAnimationFrame` call. Returns the event handler that was bound to
 * given eventName so you can clean up after yourself.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Events/scroll
 */
/* istanbul ignore next */
function throttleEvent(target, eventName, newEventName) {
    var throttledFunc = throttleImpl(function (event) {
        target.dispatchEvent(new CustomEvent(newEventName, event));
    });
    target.addEventListener(eventName, throttledFunc);
    return throttledFunc;
}
/**
 * Throttle a callback by wrapping it in a `requestAnimationFrame` call. Returns
 * the throttled function.
 *
 * @see https://www.html5rocks.com/en/tutorials/speed/animations/
 */
function throttleReactEventCallback(callback, options) {
    if (options === void 0) { options = {}; }
    var throttledFunc = throttleImpl(callback, function (event2) {
        if (options.preventDefault) {
            event2.preventDefault();
        }
    }, 
    // prevent React from reclaiming the event object before we reference it
    function (event2) { return event2.persist(); });
    return throttledFunc;
}
/**
 * Throttle a method by wrapping it in a `requestAnimationFrame` call. Returns
 * the throttled function.
 */
/* istanbul ignore next */
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
function throttle(method) {
    return throttleImpl(method);
}
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
function throttleImpl(onAnimationFrameRequested, onBeforeIsRunningCheck, onAfterIsRunningCheck) {
    var isRunning = false;
    var func = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        onBeforeIsRunningCheck === null || onBeforeIsRunningCheck === void 0 ? void 0 : onBeforeIsRunningCheck.apply(void 0, args);
        if (isRunning) {
            return;
        }
        isRunning = true;
        onAfterIsRunningCheck === null || onAfterIsRunningCheck === void 0 ? void 0 : onAfterIsRunningCheck.apply(void 0, args);
        requestAnimationFrame(function () {
            onAnimationFrameRequested.apply(void 0, args);
            isRunning = false;
        });
    };
    return func;
}
function clickElementOnKeyPress(keys) {
    return function (e) {
        if (keys.some(function (key) { return e.key === key; })) {
            // Prevent spacebar from scrolling the page unless we're in a text field
            if (!elementIsTextInput(e.target)) {
                e.preventDefault();
            }
            e.target.dispatchEvent(new MouseEvent("click", (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, e), { view: undefined })));
        }
    };
}
/**
 * Selector for all possible focusable items.
 *
 * Derived from this SO question: {@link https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus}
 *
 * Note: Order may not be correct if children elements use tabindex values > 0.
 */
var SELECTOR_FOCUSABLE = [
    'a[href]:not([tabindex="-1"])',
    'button:not([disabled]):not([tabindex="-1"])',
    'details:not([tabindex="-1"])',
    'input:not([disabled]):not([tabindex="-1"])',
    'select:not([disabled]):not([tabindex="-1"])',
    'textarea:not([disabled]):not([tabindex="-1"])',
    '[tabindex]:not([tabindex="-1"])',
].join(",");
/**
 * Gets all focusable elements within the given element.
 *
 * Selector derived from this SO question: {@link https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus}
 *
 * Note: Order may not be correct if children elements use tabindex values > 0.
 *
 * @param {HTMLElement} element - The element to search within.
 * @returns {HTMLElement[]} An array of focusable elements.
 */
function getFocusableElements(element) {
    return Array.from(element.querySelectorAll(SELECTOR_FOCUSABLE));
}

;// ./node_modules/@blueprintjs/core/lib/esm/context/overlays/overlaysProvider.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A React context used to interact with the overlay stack in an application.
 * Users should take care to make sure that only _one_ of these is instantiated and used within an
 * application.
 *
 * You will likely not be using this OverlaysContext directly, it's mostly used internally by the
 * Overlay2 component.
 *
 * For more information, see the [OverlaysProvider documentation](https://blueprintjs.com/docs/#core/context/overlays-provider).
 */
var OverlaysContext = react.createContext({
    hasProvider: false,
    stack: { current: [] },
});
/**
 * Overlays context provider, necessary for the `useOverlayStack` hook.
 *
 * @see https://blueprintjs.com/docs/#core/context/overlays-provider
 */
var OverlaysProvider = function (_a) {
    var children = _a.children;
    var stack = React.useRef([]);
    var contextValue = React.useMemo(function () { return ({ hasProvider: true, stack: stack }); }, [stack]);
    return React.createElement(OverlaysContext.Provider, { value: contextValue }, children);
};

// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/index.js
var shim = __webpack_require__(422);
;// ./node_modules/@blueprintjs/core/lib/esm/hooks/overlays/useLegacyOverlayStack.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var globalStack = [];
var globalStackListeners = [];
/**
 * Modify the global stack in-place and notify all listeners of the updated value.
 *
 * @public for testing
 */
var modifyGlobalStack = function (fn) {
    fn(globalStack);
    globalStackListeners.forEach(function (listener) { return listener(); });
};
var legacyGlobalOverlayStackStore = {
    getSnapshot: function () { return globalStack; },
    subscribe: function (listener) {
        globalStackListeners.push(listener);
        return function () {
            var index = globalStackListeners.indexOf(listener);
            globalStackListeners.splice(index, 1);
        };
    },
};
/**
 * Legacy implementation of a global overlay stack which maintains state in a global variable.
 * This is used for backwards-compatibility with overlay-based components in Blueprint v5.
 * It will be removed in Blueprint v6 once `<OverlaysProvider>` is required.
 *
 * @see https://github.com/palantir/blueprint/wiki/Overlay2-migration
 */
function useLegacyOverlayStack() {
    var stack = (0,shim.useSyncExternalStore)(legacyGlobalOverlayStackStore.subscribe, legacyGlobalOverlayStackStore.getSnapshot, 
    // server snapshot is the same as client snapshot
    legacyGlobalOverlayStackStore.getSnapshot);
    var getLastOpened = react.useCallback(function () { return stack[stack.length - 1]; }, [stack]);
    var getThisOverlayAndDescendants = react.useCallback(function (id) {
        var stackIndex = stack.findIndex(function (o) { return o.id === id; });
        return stack.slice(stackIndex);
    }, [stack]);
    var resetStack = react.useCallback(function () {
        modifyGlobalStack(function (s) { return s.splice(0, s.length); });
    }, []);
    var openOverlay = react.useCallback(function (overlay) {
        globalStack.push(overlay);
        if (overlay.props.usePortal && overlay.props.hasBackdrop) {
            // add a class to the body to prevent scrolling of content below the overlay
            document.body.classList.add(OVERLAY_OPEN);
        }
    }, []);
    var closeOverlay = react.useCallback(function (id) {
        var otherOverlaysWithBackdrop = stack.filter(function (o) { return o.props.usePortal && o.props.hasBackdrop && o.id !== id; });
        var index = globalStack.findIndex(function (o) { return o.id === id; });
        if (index > -1) {
            globalStack.splice(index, 1);
        }
        if (otherOverlaysWithBackdrop.length === 0) {
            // remove body class which prevents scrolling of content below overlay
            document.body.classList.remove(OVERLAY_OPEN);
        }
    }, [stack]);
    return {
        closeOverlay: closeOverlay,
        getLastOpened: getLastOpened,
        getThisOverlayAndDescendants: getThisOverlayAndDescendants,
        openOverlay: openOverlay,
        resetStack: resetStack,
    };
}

;// ./node_modules/@blueprintjs/core/lib/esm/hooks/overlays/useOverlayStack.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * React hook to interact with the global overlay stack.
 *
 * @see https://blueprintjs.com/docs/#core/hooks/use-overlay-stack
 */
function useOverlayStack() {
    // get the overlay stack from application-wide React context
    var _a = react.useContext(OverlaysContext), stack = _a.stack, hasProvider = _a.hasProvider;
    var legacyOverlayStack = useLegacyOverlayStack();
    var getLastOpened = react.useCallback(function () {
        return stack.current[stack.current.length - 1];
    }, [stack]);
    var getThisOverlayAndDescendants = react.useCallback(function (id) {
        var index = stack.current.findIndex(function (o) { return o.id === id; });
        if (index === -1) {
            return [];
        }
        return stack.current.slice(index);
    }, [stack]);
    var resetStack = react.useCallback(function () {
        stack.current = [];
    }, [stack]);
    var openOverlay = react.useCallback(function (overlay) {
        stack.current.push(overlay);
        if (overlay.props.usePortal && overlay.props.hasBackdrop) {
            // add a class to the body to prevent scrolling of content below the overlay
            document.body.classList.add(OVERLAY_OPEN);
        }
    }, [stack]);
    var closeOverlay = react.useCallback(function (id) {
        var otherOverlaysWithBackdrop = stack.current.filter(function (o) { return o.props.usePortal && o.props.hasBackdrop && o.id !== id; });
        var index = stack.current.findIndex(function (o) { return o.id === id; });
        if (index > -1) {
            stack.current.splice(index, 1);
        }
        if (otherOverlaysWithBackdrop.length === 0) {
            // remove body class which prevents scrolling of content below overlay
            document.body.classList.remove(OVERLAY_OPEN);
        }
    }, [stack]);
    if (!hasProvider) {
        if (isNodeEnv("development")) {
            console.error(OVERLAY2_REQUIRES_OVERLAY_PROVDER);
        }
        return legacyOverlayStack;
    }
    return {
        closeOverlay: closeOverlay,
        getLastOpened: getLastOpened,
        getThisOverlayAndDescendants: getThisOverlayAndDescendants,
        openOverlay: openOverlay,
        resetStack: resetStack,
    };
}

;// ./node_modules/@blueprintjs/core/lib/esm/hooks/usePrevious.js
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** React hook which tracks the previous state of a given value. */
function usePrevious(value) {
    // create a new reference
    var ref = react.useRef();
    // store current value in ref
    react.useEffect(function () {
        ref.current = value;
    }, [value]);
    // return previous value (happens before update in useEffect above)
    return ref.current;
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/overlay/overlayUtils.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns the keyboard-focusable elements inside a given container element, ignoring focus traps
 * rendered by Overlay/Overlay2.
 */
function getKeyboardFocusableElements(container) {
    var containerElement = getRef(container);
    var focusableElements = containerElement != null
        ? // Note: Order may not be correct if children elements use tabindex values > 0.
            getFocusableElements(containerElement)
        : [];
    return focusableElements.filter(function (el) { return !el.classList.contains(OVERLAY_START_FOCUS_TRAP) && !el.classList.contains(OVERLAY_END_FOCUS_TRAP); });
}

;// ./node_modules/@blueprintjs/core/lib/esm/context/portal/portalProvider.js
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A React context to set options for all portals in a given subtree.
 * Do not use this PortalContext directly, instead use PortalProvider to set the options.
 */
var PortalContext = react.createContext({});
/**
 * Portal context provider.
 *
 * @see https://blueprintjs.com/docs/#core/context/portal-provider
 */
var PortalProvider = function (_a) {
    var children = _a.children, portalClassName = _a.portalClassName, portalContainer = _a.portalContainer;
    var contextOptions = React.useMemo(function () { return ({
        portalClassName: portalClassName,
        portalContainer: portalContainer,
    }); }, [portalClassName, portalContainer]);
    return React.createElement(PortalContext.Provider, { value: contextOptions }, children);
};

;// ./node_modules/@blueprintjs/core/lib/esm/components/portal/portal.js
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/** @deprecated will be removed in Blueprint v6.0 */
var PORTAL_LEGACY_CONTEXT_TYPES = {
    blueprintPortalClassName: function (obj, key) {
        if (obj[key] != null && typeof obj[key] !== "string") {
            return new Error(PORTAL_CONTEXT_CLASS_NAME_STRING);
        }
        return undefined;
    },
};
/**
 * Portal component.
 *
 * This component detaches its contents and re-attaches them to document.body.
 * Use it when you need to circumvent DOM z-stacking (for dialogs, popovers, etc.).
 * Any class names passed to this element will be propagated to the new container element on document.body.
 *
 * Portal supports both the newer React context API and the legacy context API.
 * Support for the legacy context API will be removed in Blueprint v6.0.
 *
 * @see https://blueprintjs.com/docs/#core/components/portal
 */
function Portal(
// eslint-disable-next-line @typescript-eslint/no-deprecated
_a, legacyContext) {
    var _b;
    var className = _a.className, stopPropagationEvents = _a.stopPropagationEvents, container = _a.container, onChildrenMount = _a.onChildrenMount, children = _a.children;
    if (legacyContext === void 0) { legacyContext = {}; }
    var context = react.useContext(PortalContext);
    var portalContainer = (_b = container !== null && container !== void 0 ? container : context.portalContainer) !== null && _b !== void 0 ? _b : (typeof document !== "undefined" ? document.body : undefined);
    var _c = react.useState(), portalElement = _c[0], setPortalElement = _c[1];
    var createPortalElement = react.useCallback(function () {
        var newPortalElement = document.createElement("div");
        newPortalElement.classList.add(PORTAL);
        maybeAddClass(newPortalElement.classList, className); // directly added to this portal element
        maybeAddClass(newPortalElement.classList, context.portalClassName); // added via PortalProvider context
        addStopPropagationListeners(newPortalElement, stopPropagationEvents);
        // TODO: remove legacy context support in Blueprint v6.0
        var blueprintPortalClassName = legacyContext.blueprintPortalClassName;
        if (blueprintPortalClassName != null && blueprintPortalClassName !== "") {
            console.error(PORTAL_LEGACY_CONTEXT_API);
            maybeAddClass(newPortalElement.classList, blueprintPortalClassName); // added via legacy context
        }
        return newPortalElement;
    }, [className, context.portalClassName, legacyContext.blueprintPortalClassName, stopPropagationEvents]);
    // create the container element & attach it to the DOM
    react.useEffect(function () {
        if (portalContainer == null) {
            return;
        }
        var newPortalElement = createPortalElement();
        portalContainer.appendChild(newPortalElement);
        setPortalElement(newPortalElement);
        return function () {
            removeStopPropagationListeners(newPortalElement, stopPropagationEvents);
            newPortalElement.remove();
            setPortalElement(undefined);
        };
    }, [portalContainer, createPortalElement, stopPropagationEvents]);
    // wait until next successful render to invoke onChildrenMount callback
    react.useEffect(function () {
        if (portalElement != null) {
            onChildrenMount === null || onChildrenMount === void 0 ? void 0 : onChildrenMount();
        }
    }, [portalElement, onChildrenMount]);
    react.useEffect(function () {
        if (portalElement != null) {
            maybeAddClass(portalElement.classList, className);
            return function () { return maybeRemoveClass(portalElement.classList, className); };
        }
        return undefined;
    }, [className, portalElement]);
    react.useEffect(function () {
        if (portalElement != null) {
            addStopPropagationListeners(portalElement, stopPropagationEvents);
            return function () { return removeStopPropagationListeners(portalElement, stopPropagationEvents); };
        }
        return undefined;
    }, [portalElement, stopPropagationEvents]);
    // Only render `children` once this component has mounted in a browser environment, so they are
    // immediately attached to the DOM tree and can do DOM things like measuring or `autoFocus`.
    // See long comment on componentDidMount in https://reactjs.org/docs/portals.html#event-bubbling-through-portals
    if (typeof document === "undefined" || portalElement == null) {
        return null;
    }
    else {
        return react_dom.createPortal(children, portalElement);
    }
}
Portal.displayName = "".concat(DISPLAYNAME_PREFIX, ".Portal");
// only use legacy context in React 16 or 17
if (!isReact18OrHigher()) {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    Portal.contextTypes = PORTAL_LEGACY_CONTEXT_TYPES;
}
function maybeRemoveClass(classList, className) {
    if (className != null && className !== "") {
        classList.remove.apply(classList, className.split(" "));
    }
}
function maybeAddClass(classList, className) {
    if (className != null && className !== "") {
        classList.add.apply(classList, className.split(" "));
    }
}
function addStopPropagationListeners(portalElement, eventNames) {
    eventNames === null || eventNames === void 0 ? void 0 : eventNames.forEach(function (event) { return portalElement.addEventListener(event, handleStopProgation); });
}
function removeStopPropagationListeners(portalElement, events) {
    events === null || events === void 0 ? void 0 : events.forEach(function (event) { return portalElement.removeEventListener(event, handleStopProgation); });
}
function handleStopProgation(e) {
    e.stopPropagation();
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/overlay2/overlay2.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














var OVERLAY2_DEFAULT_PROPS = {
    autoFocus: true,
    backdropProps: {},
    canEscapeKeyClose: true,
    canOutsideClickClose: true,
    enforceFocus: true,
    hasBackdrop: true,
    isOpen: false,
    lazy: hasDOMEnvironment(),
    shouldReturnFocusOnClose: true,
    transitionDuration: 300,
    transitionName: OVERLAY,
    usePortal: true,
};
/**
 * Overlay2 component.
 *
 * @see https://blueprintjs.com/docs/#core/components/overlay2
 */
var Overlay2 = react.forwardRef(function (props, forwardedRef) {
    var _a;
    var _b, _c;
    var autoFocus = props.autoFocus, backdropClassName = props.backdropClassName, backdropProps = props.backdropProps, canEscapeKeyClose = props.canEscapeKeyClose, canOutsideClickClose = props.canOutsideClickClose, childRef = props.childRef, childRefs = props.childRefs, children = props.children, className = props.className, enforceFocus = props.enforceFocus, hasBackdrop = props.hasBackdrop, isOpen = props.isOpen, lazy = props.lazy, onClose = props.onClose, onClosed = props.onClosed, onClosing = props.onClosing, onOpened = props.onOpened, onOpening = props.onOpening, portalClassName = props.portalClassName, portalContainer = props.portalContainer, shouldReturnFocusOnClose = props.shouldReturnFocusOnClose, transitionDuration = props.transitionDuration, transitionName = props.transitionName, usePortal = props.usePortal;
    useOverlay2Validation(props);
    var _d = useOverlayStack(), closeOverlay = _d.closeOverlay, getLastOpened = _d.getLastOpened, getThisOverlayAndDescendants = _d.getThisOverlayAndDescendants, openOverlay = _d.openOverlay;
    var _e = react.useState(false), isAutoFocusing = _e[0], setIsAutoFocusing = _e[1];
    var _f = react.useState(false), hasEverOpened = _f[0], setHasEverOpened = _f[1];
    var lastActiveElementBeforeOpened = react.useRef(null);
    /** Ref for container element, containing all children and the backdrop */
    var containerElement = react.useRef(null);
    /** Ref for backdrop element */
    var backdropElement = react.useRef(null);
    /* An empty, keyboard-focusable div at the beginning of the Overlay content */
    var startFocusTrapElement = react.useRef(null);
    /* An empty, keyboard-focusable div at the end of the Overlay content */
    var endFocusTrapElement = react.useRef(null);
    /**
     * Locally-generated DOM ref for a singleton child element.
     * This is only used iff the user does not specify the `childRef` or `childRefs` props.
     */
    var localChildRef = react.useRef(null);
    var bringFocusInsideOverlay = react.useCallback(function () {
        // always delay focus manipulation to just before repaint to prevent scroll jumping
        return requestAnimationFrame(function () {
            var _a;
            // container element may be undefined between component mounting and Portal rendering
            // activeElement may be undefined in some rare cases in IE
            var container = getRef(containerElement);
            var activeElement = getActiveElement(container);
            if (container == null || activeElement == null) {
                return;
            }
            // Overlay2 is guaranteed to be mounted here
            var isFocusOutsideModal = !container.contains(activeElement);
            if (isFocusOutsideModal) {
                (_a = getRef(startFocusTrapElement)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
                setIsAutoFocusing(false);
            }
        });
    }, []);
    /** Unique ID for this overlay in the global stack */
    var id = useOverlay2ID();
    // N.B. use `null` here and not simply `undefined` because `useImperativeHandle` will set `null` on unmount,
    // and we need the following code to be resilient to that value.
    var instance = react.useRef(null);
    /**
     * When multiple `enforceFocus` Overlays are open, this event handler is only active for the most
     * recently opened one to avoid Overlays competing with each other for focus.
     */
    var handleDocumentFocus = react.useCallback(function (e) {
        // get the actual target even in the Shadow DOM
        // see https://github.com/palantir/blueprint/issues/4220
        var eventTarget = e.composed ? e.composedPath()[0] : e.target;
        var container = getRef(containerElement);
        if (container != null && eventTarget instanceof Node && !container.contains(eventTarget)) {
            // prevent default focus behavior (sometimes auto-scrolls the page)
            e.preventDefault();
            e.stopImmediatePropagation();
            bringFocusInsideOverlay();
        }
    }, [bringFocusInsideOverlay]);
    // N.B. this listener is only kept attached when `isOpen={true}` and `canOutsideClickClose={true}`
    var handleDocumentMousedown = react.useCallback(function (e) {
        // get the actual target even in the Shadow DOM
        // see https://github.com/palantir/blueprint/issues/4220
        var eventTarget = (e.composed ? e.composedPath()[0] : e.target);
        var thisOverlayAndDescendants = getThisOverlayAndDescendants(id);
        var isClickInThisOverlayOrDescendant = thisOverlayAndDescendants.some(function (_a) {
            var containerRef = _a.containerElement;
            // `elem` is the container of backdrop & content, so clicking directly on that container
            // should not count as being "inside" the overlay.
            var elem = getRef(containerRef);
            return (elem === null || elem === void 0 ? void 0 : elem.contains(eventTarget)) && !elem.isSameNode(eventTarget);
        });
        if (!isClickInThisOverlayOrDescendant) {
            // casting to any because this is a native event
            onClose === null || onClose === void 0 ? void 0 : onClose(e);
        }
    }, [getThisOverlayAndDescendants, id, onClose]);
    // send this instance's imperative handle to the the forwarded ref as well as our local ref
    var ref = react.useMemo(function () { return mergeRefs(forwardedRef, instance); }, [forwardedRef]);
    react.useImperativeHandle(ref, function () { return ({
        bringFocusInsideOverlay: bringFocusInsideOverlay,
        containerElement: containerElement,
        handleDocumentFocus: handleDocumentFocus,
        handleDocumentMousedown: handleDocumentMousedown,
        id: id,
        props: {
            autoFocus: autoFocus,
            enforceFocus: enforceFocus,
            hasBackdrop: hasBackdrop,
            usePortal: usePortal,
        },
    }); }, [
        autoFocus,
        bringFocusInsideOverlay,
        enforceFocus,
        handleDocumentFocus,
        handleDocumentMousedown,
        hasBackdrop,
        id,
        usePortal,
    ]);
    var handleContainerKeyDown = react.useCallback(function (e) {
        if (e.key === "Escape" && canEscapeKeyClose) {
            onClose === null || onClose === void 0 ? void 0 : onClose(e);
            // prevent other overlays from closing
            e.stopPropagation();
            // prevent browser-specific escape key behavior (Safari exits fullscreen)
            e.preventDefault();
        }
    }, [canEscapeKeyClose, onClose]);
    var overlayWillOpen = react.useCallback(function () {
        if (instance.current == null) {
            return;
        }
        var lastOpenedOverlay = getLastOpened();
        if ((lastOpenedOverlay === null || lastOpenedOverlay === void 0 ? void 0 : lastOpenedOverlay.handleDocumentFocus) !== undefined) {
            document.removeEventListener("focus", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);
        }
        openOverlay(instance.current);
        if (autoFocus) {
            setIsAutoFocusing(true);
            bringFocusInsideOverlay();
        }
        setRef(lastActiveElementBeforeOpened, getActiveElement(getRef(containerElement)));
    }, [autoFocus, bringFocusInsideOverlay, getLastOpened, openOverlay]);
    var overlayWillClose = react.useCallback(function () {
        var _a;
        document.removeEventListener("focus", handleDocumentFocus, /* useCapture */ true);
        document.removeEventListener("mousedown", handleDocumentMousedown);
        // N.B. `instance.current` may be null at this point if we are cleaning up an open overlay during the unmount phase
        // (this is common, for example, with context menu's singleton `showContextMenu` / `hideContextMenu` imperative APIs).
        closeOverlay(id);
        var lastOpenedOverlay = getLastOpened();
        if (lastOpenedOverlay !== undefined) {
            // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.
            // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,
            // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921
            if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {
                (_a = lastOpenedOverlay.bringFocusInsideOverlay) === null || _a === void 0 ? void 0 : _a.call(lastOpenedOverlay);
                if (lastOpenedOverlay.handleDocumentFocus !== undefined) {
                    document.addEventListener("focus", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);
                }
            }
        }
    }, [closeOverlay, getLastOpened, handleDocumentFocus, handleDocumentMousedown, id]);
    var prevIsOpen = (_b = usePrevious(isOpen)) !== null && _b !== void 0 ? _b : false;
    react.useEffect(function () {
        if (isOpen) {
            setHasEverOpened(true);
        }
        if (!prevIsOpen && isOpen) {
            // just opened
            overlayWillOpen();
        }
        if (prevIsOpen && !isOpen) {
            // just closed
            overlayWillClose();
        }
    }, [isOpen, overlayWillOpen, overlayWillClose, prevIsOpen]);
    // Important: clean up old document-level event listeners if their memoized values change (this is rare, but
    // may happen, for example, if a user forgets to use `React.useCallback` in the `props.onClose` value).
    // Otherwise, we will lose the reference to those values and create a memory leak since we won't be able
    // to successfully detach them inside overlayWillClose.
    react.useEffect(function () {
        if (!isOpen || !(canOutsideClickClose && !hasBackdrop)) {
            return;
        }
        document.addEventListener("mousedown", handleDocumentMousedown);
        return function () {
            document.removeEventListener("mousedown", handleDocumentMousedown);
        };
    }, [handleDocumentMousedown, isOpen, canOutsideClickClose, hasBackdrop]);
    react.useEffect(function () {
        if (!isOpen || !enforceFocus) {
            return;
        }
        // Focus events do not bubble, but setting useCapture allows us to listen in and execute
        // our handler before all others
        document.addEventListener("focus", handleDocumentFocus, /* useCapture */ true);
        return function () {
            document.removeEventListener("focus", handleDocumentFocus, /* useCapture */ true);
        };
    }, [handleDocumentFocus, enforceFocus, isOpen]);
    var overlayWillCloseRef = react.useRef(overlayWillClose);
    overlayWillCloseRef.current = overlayWillClose;
    react.useEffect(function () {
        // run cleanup code once on unmount, ensuring we call the most recent overlayWillClose callback
        // by storing in a ref and keeping up to date
        return function () {
            overlayWillCloseRef.current();
        };
    }, []);
    var handleTransitionExited = react.useCallback(function (node) {
        var lastActiveElement = getRef(lastActiveElementBeforeOpened);
        if (shouldReturnFocusOnClose && lastActiveElement instanceof HTMLElement) {
            lastActiveElement.focus();
        }
        onClosed === null || onClosed === void 0 ? void 0 : onClosed(node);
    }, [onClosed, shouldReturnFocusOnClose]);
    // N.B. CSSTransition requires this callback to be defined, even if it's unused.
    var handleTransitionAddEnd = react.useCallback(function () {
        // no-op
    }, []);
    /**
     * Gets the relevant DOM ref for a child element using the `childRef` or `childRefs` props (if possible).
     * This ref is necessary for `CSSTransition` to work in React 18 without relying on `ReactDOM.findDOMNode`.
     *
     * Returns `undefined` if the user did not specify either of those props. In those cases, we use the ref we
     * have locally generated and expect that the user _did not_ specify their own `ref` on the child element
     * (it will get clobbered / overriden).
     *
     * @see https://reactcommunity.org/react-transition-group/css-transition
     */
    var getUserChildRef = react.useCallback(function (child) {
        if (childRef != null) {
            return childRef;
        }
        else if (childRefs != null) {
            var key = child.key;
            if (key == null) {
                if (!isNodeEnv("production")) {
                    console.error(OVERLAY_CHILD_REQUIRES_KEY);
                }
                return undefined;
            }
            return childRefs[key];
        }
        return undefined;
    }, [childRef, childRefs]);
    var maybeRenderChild = react.useCallback(function (child) {
        if (child == null || isEmptyString(child)) {
            return null;
        }
        // decorate the child with a few injected props
        var userChildRef = getUserChildRef(child);
        var childProps = isReactElement(child) ? child.props : {};
        // if the child is a string, number, or fragment, it will be wrapped in a <span> element
        var decoratedChild = ensureElement(child, "span", {
            className: classnames_default()(childProps.className, OVERLAY_CONTENT),
            // IMPORTANT: only inject our ref if the user didn't specify childRef or childRefs already. Otherwise,
            // we risk clobbering the user's ref (which we cannot inspect here while cloning/decorating the child).
            ref: userChildRef === undefined ? localChildRef : undefined,
            tabIndex: enforceFocus || autoFocus ? 0 : undefined,
        });
        var resolvedChildRef = userChildRef !== null && userChildRef !== void 0 ? userChildRef : localChildRef;
        return (react.createElement(esm_CSSTransition, { addEndListener: handleTransitionAddEnd, classNames: transitionName, 
            // HACKHACK: CSSTransition types are slightly incompatible with React types here.
            // React prefers `| null` but not `| undefined` for the ref value, while
            // CSSTransition _demands_ that `| undefined` be part of the element type.
            nodeRef: resolvedChildRef, onEntered: getLifecycleCallbackWithChildRef(onOpened, resolvedChildRef), onEntering: getLifecycleCallbackWithChildRef(onOpening, resolvedChildRef), onExited: getLifecycleCallbackWithChildRef(handleTransitionExited, resolvedChildRef), onExiting: getLifecycleCallbackWithChildRef(onClosing, resolvedChildRef), timeout: transitionDuration }, decoratedChild));
    }, [
        autoFocus,
        enforceFocus,
        getUserChildRef,
        handleTransitionAddEnd,
        handleTransitionExited,
        onClosing,
        onOpened,
        onOpening,
        transitionDuration,
        transitionName,
    ]);
    var handleBackdropMouseDown = react.useCallback(function (e) {
        var _a;
        if (canOutsideClickClose) {
            onClose === null || onClose === void 0 ? void 0 : onClose(e);
        }
        if (enforceFocus) {
            bringFocusInsideOverlay();
        }
        (_a = backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(backdropProps, e);
    }, [backdropProps, bringFocusInsideOverlay, canOutsideClickClose, enforceFocus, onClose]);
    var renderDummyElement = react.useCallback(function (key, dummyElementProps) { return (react.createElement(esm_CSSTransition, { addEndListener: handleTransitionAddEnd, classNames: transitionName, key: key, nodeRef: dummyElementProps.ref, timeout: transitionDuration, unmountOnExit: true },
        react.createElement("div", (0,tslib_es6/* __assign */.Cl)({ tabIndex: 0 }, dummyElementProps)))); }, [handleTransitionAddEnd, transitionDuration, transitionName]);
    /**
     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to
     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding
     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the
     * Overlay.
     */
    var handleStartFocusTrapElementFocus = react.useCallback(function (e) {
        if (!enforceFocus || isAutoFocusing) {
            return;
        }
        // e.relatedTarget will not be defined if this was a programmatic focus event, as is the
        // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.
        // Otherwise, we're handling a user interaction, and we should wrap around to the last
        // element in this transition group.
        var container = getRef(containerElement);
        var endFocusTrap = getRef(endFocusTrapElement);
        if (e.relatedTarget != null &&
            (container === null || container === void 0 ? void 0 : container.contains(e.relatedTarget)) &&
            e.relatedTarget !== endFocusTrap) {
            endFocusTrap === null || endFocusTrap === void 0 ? void 0 : endFocusTrap.focus({ preventScroll: true });
        }
    }, [enforceFocus, isAutoFocusing]);
    /**
     * Wrap around to the end of the dialog if `enforceFocus` is enabled.
     */
    var handleStartFocusTrapElementKeyDown = react.useCallback(function (e) {
        var _a;
        if (!enforceFocus) {
            return;
        }
        if (e.shiftKey && e.key === "Tab") {
            var lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();
            if (lastFocusableElement != null) {
                lastFocusableElement.focus();
            }
            else {
                (_a = getRef(endFocusTrapElement)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            }
        }
    }, [enforceFocus]);
    /**
     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the
     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the
     * `startFocusTrapElement`), depending on whether the element losing focus is inside the
     * Overlay.
     */
    var handleEndFocusTrapElementFocus = react.useCallback(function (e) {
        var _a;
        // No need for this.props.enforceFocus check here because this element is only rendered
        // when that prop is true.
        // During user interactions, e.relatedTarget will be defined, and we should wrap around to the
        // "start focus trap" element.
        // Otherwise, we're handling a programmatic focus event, which can only happen after a user
        // presses shift+tab from the first focusable element in the overlay.
        var startFocusTrap = getRef(startFocusTrapElement);
        if (e.relatedTarget != null &&
            ((_a = getRef(containerElement)) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) &&
            e.relatedTarget !== startFocusTrap) {
            var firstFocusableElement = getKeyboardFocusableElements(containerElement).shift();
            // ensure we don't re-focus an already active element by comparing against e.relatedTarget
            if (!isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {
                firstFocusableElement.focus();
            }
            else {
                startFocusTrap === null || startFocusTrap === void 0 ? void 0 : startFocusTrap.focus({ preventScroll: true });
            }
        }
        else {
            var lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();
            if (lastFocusableElement != null) {
                lastFocusableElement.focus();
            }
            else {
                // Keeps focus within Overlay even if there are no keyboard-focusable children
                startFocusTrap === null || startFocusTrap === void 0 ? void 0 : startFocusTrap.focus({ preventScroll: true });
            }
        }
    }, [isAutoFocusing]);
    var maybeBackdrop = react.useMemo(function () {
        return hasBackdrop && isOpen ? (react.createElement(esm_CSSTransition, { classNames: transitionName, key: "__backdrop", nodeRef: backdropElement, timeout: transitionDuration, addEndListener: handleTransitionAddEnd },
            react.createElement("div", (0,tslib_es6/* __assign */.Cl)({}, backdropProps, { className: classnames_default()(OVERLAY_BACKDROP, backdropClassName, backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.className), onMouseDown: handleBackdropMouseDown, ref: backdropElement })))) : null;
    }, [
        backdropClassName,
        backdropProps,
        handleBackdropMouseDown,
        handleTransitionAddEnd,
        hasBackdrop,
        isOpen,
        transitionDuration,
        transitionName,
    ]);
    // no reason to render anything at all if we're being truly lazy
    if (lazy && !hasEverOpened) {
        return null;
    }
    // TransitionGroup types require single array of children; does not support nested arrays.
    // So we must collapse backdrop and children into one array, and every item must be wrapped in a
    // Transition element (no ReactText allowed).
    var childrenWithTransitions = isOpen ? (_c = react.Children.map(children, maybeRenderChild)) !== null && _c !== void 0 ? _c : [] : [];
    // const maybeBackdrop = maybeRenderBackdrop();
    if (maybeBackdrop !== null) {
        childrenWithTransitions.unshift(maybeBackdrop);
    }
    if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {
        childrenWithTransitions.unshift(renderDummyElement("__start", {
            className: OVERLAY_START_FOCUS_TRAP,
            onFocus: handleStartFocusTrapElementFocus,
            onKeyDown: handleStartFocusTrapElementKeyDown,
            ref: startFocusTrapElement,
        }));
        if (enforceFocus) {
            childrenWithTransitions.push(renderDummyElement("__end", {
                className: OVERLAY_END_FOCUS_TRAP,
                onFocus: handleEndFocusTrapElementFocus,
                ref: endFocusTrapElement,
            }));
        }
    }
    var transitionGroup = (react.createElement("div", { "aria-live": "polite", className: classnames_default()(OVERLAY, (_a = {},
            _a[OVERLAY_OPEN] = isOpen,
            _a[OVERLAY_INLINE] = !usePortal,
            _a), className), onKeyDown: handleContainerKeyDown, ref: containerElement },
        react.createElement(esm_TransitionGroup, { appear: true, component: null }, childrenWithTransitions)));
    if (usePortal) {
        return (react.createElement(Portal, { className: portalClassName, container: portalContainer }, transitionGroup));
    }
    else {
        return transitionGroup;
    }
});
// eslint-disable-next-line @typescript-eslint/no-deprecated
Overlay2.defaultProps = OVERLAY2_DEFAULT_PROPS;
Overlay2.displayName = "".concat(DISPLAYNAME_PREFIX, ".Overlay2");
function useOverlay2Validation(_a) {
    var childRef = _a.childRef, childRefs = _a.childRefs, children = _a.children;
    var numChildren = react.Children.count(children);
    react.useEffect(function () {
        if (isNodeEnv("production")) {
            return;
        }
        if (childRef != null && childRefs != null) {
            console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX);
        }
        if (numChildren > 1 && childRefs == null) {
            console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS);
        }
    }, [childRef, childRefs, numChildren]);
}
/**
 * Generates a unique ID for a given Overlay which persists across the component's lifecycle.
 */
function useOverlay2ID() {
    // TODO: migrate to React.useId() in React 18
    var id = useUID();
    return "".concat(Overlay2.displayName, "-").concat(id);
}
// N.B. the `onExiting` callback is not provided with the `node` argument as suggested in CSSTransition types since
// we are using the `nodeRef` prop, so we must inject it dynamically.
function getLifecycleCallbackWithChildRef(callback, childRef) {
    return function () {
        if ((childRef === null || childRef === void 0 ? void 0 : childRef.current) != null) {
            callback === null || callback === void 0 ? void 0 : callback(childRef.current);
        }
    };
}

// EXTERNAL MODULE: ./node_modules/@blueprintjs/icons/lib/esm/iconTypes.js
var iconTypes = __webpack_require__(772);
;// ./node_modules/@blueprintjs/icons/lib/esm/classes.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var classes_NS = "bp5";
var classes_ICON = "".concat(classes_NS, "-icon");

;// ./node_modules/@blueprintjs/icons/lib/esm/jsUtils.js
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var jsUtils_uniqueCountForNamespace = new Map();
/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */
function jsUtils_uniqueId(namespace) {
    var _a;
    var curCount = (_a = jsUtils_uniqueCountForNamespace.get(namespace)) !== null && _a !== void 0 ? _a : 0;
    jsUtils_uniqueCountForNamespace.set(namespace, curCount + 1);
    return "".concat(namespace, "-").concat(curCount);
}

;// ./node_modules/@blueprintjs/icons/lib/esm/svgIconContainer.js
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






// eslint-disable-next-line prefer-arrow-callback
var SVGIconContainer = react.forwardRef(function (props, ref) {
    var children = props.children, className = props.className, color = props.color, htmlTitle = props.htmlTitle, iconName = props.iconName, _a = props.size, size = _a === void 0 ? iconTypes/* IconSize */.l.STANDARD : _a, svgProps = props.svgProps, _b = props.tagName, tagName = _b === void 0 ? "span" : _b, title = props.title, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["children", "className", "color", "htmlTitle", "iconName", "size", "svgProps", "tagName", "title"]);
    var isLarge = size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var viewBox = "0 0 ".concat(pixelGridSize, " ").concat(pixelGridSize);
    var titleId = jsUtils_uniqueId("iconTitle");
    var sharedSvgProps = (0,tslib_es6/* __assign */.Cl)({ fill: color, height: size, role: "img", viewBox: viewBox, width: size }, svgProps);
    if (tagName === null) {
        return (react.createElement("svg", (0,tslib_es6/* __assign */.Cl)({ "aria-labelledby": title ? titleId : undefined, "data-icon": iconName, ref: ref }, sharedSvgProps, htmlProps, { className: classnames_default()(className, svgProps === null || svgProps === void 0 ? void 0 : svgProps.className) }),
            title && react.createElement("title", { id: titleId }, title),
            children));
    }
    else {
        // N.B. styles for `Classes.ICON` are defined in @blueprintjs/core in `_icon.scss`
        return react.createElement(tagName, (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ "aria-hidden": title ? undefined : true }, htmlProps), { className: classnames_default()(classes_ICON, "".concat(classes_ICON, "-").concat(iconName), className), ref: ref, title: htmlTitle }), react.createElement("svg", (0,tslib_es6/* __assign */.Cl)({ "data-icon": iconName }, sharedSvgProps, { className: svgProps === null || svgProps === void 0 ? void 0 : svgProps.className }),
            title && react.createElement("title", null, title),
            children));
    }
});
SVGIconContainer.displayName = "Blueprint5.SVGIconContainer";

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/components/cross.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var Cross = react.forwardRef(function (props, ref) {
    var isLarge = props.size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var translation = "".concat(-1 * pixelGridSize / 0.05 / 2);
    var style = { transformOrigin: "center" };
    return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ iconName: "cross", ref: ref }, props),
        react.createElement("path", { d: isLarge ? "M228.2 200L314 285.8C317.8 289.4 320 294.4 320 300C320 311 311 320 300 320C294.4000000000001 320 289.4000000000001 317.8 285.8 314.2L200 228.2L114.2 314.2C110.6 317.8 105.6 320 100 320C89 320 80 311 80 300C80 294.4 82.2 289.4 85.8 285.8L171.8 200L86 114.2000000000001C82.2 110.6 80 105.6 80 100C80 89 89 80 100 80C105.6 80 110.6 82.2 114.2 85.8L200 171.8L285.8 86C289.4000000000001 82.2 294.4000000000001 80 300 80C311 80 320 89 320 100C320 105.6 317.8 110.6 314.2000000000001 114.2000000000001L228.2 200z" : "M188.2 160L254 225.8C257.8 229.4 260 234.4 260 240C260 251 251 260 240 260C234.4 260 229.4 257.8 225.8 254.2L160 188.2L94.2 254.2C90.6 257.8 85.6 260 80 260C69 260 60 251 60 240C60 234.4 62.2 229.4 65.8 225.8L131.8 160L66 94.2C62.2 90.6 60 85.6 60 80C60 69 69 60 80 60C85.6 60 90.6 62.2 94.2 65.8L160 131.8L225.8 66C229.4 62.2 234.4 60 240 60C251 60 260 69 260 80C260 85.6 257.8 90.6 254.2 94.2L188.2 160z", fillRule: "evenodd", transform: "scale(0.05, -0.05) translate(".concat(translation, ", ").concat(translation, ")"), style: style })));
});
Cross.defaultProps = {
    size: iconTypes/* IconSize */.l.STANDARD,
};
Cross.displayName = "Blueprint5.Icon.Cross";
/* harmony default export */ const cross = ((/* unused pure expression or super */ null && (Cross)));

;// ./node_modules/@blueprintjs/core/lib/esm/components/button/buttonGroup.js
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * Button group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/button-group
 */
var ButtonGroup = react.forwardRef(function (props, ref) {
    var _a;
    var alignText = props.alignText, className = props.className, fill = props.fill, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    minimal = props.minimal, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    outlined = props.outlined, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    large = props.large, _b = props.size, size = _b === void 0 ? "medium" : _b, _c = props.variant, variant = _c === void 0 ? "solid" : _c, vertical = props.vertical, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["alignText", "className", "fill", "minimal", "outlined", "large", "size", "variant", "vertical"]);
    var buttonGroupClasses = classnames_default()(BUTTON_GROUP, (_a = {},
        _a[FILL] = fill,
        _a[VERTICAL] = vertical,
        _a), alignmentClass(alignText), sizeClass(size, { large: large }), variantClass(variant, { minimal: minimal, outlined: outlined }), className);
    return (react.createElement("div", (0,tslib_es6/* __assign */.Cl)({}, htmlProps, { ref: ref, className: buttonGroupClasses }), props.children));
});
ButtonGroup.displayName = "".concat(DISPLAYNAME_PREFIX, ".ButtonGroup");

;// ./node_modules/@blueprintjs/core/lib/esm/common/utils/keyboardUtils.js
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns whether the keyboard event was triggered by Enter or Space, the two keys that are expected to trigger
 * interactive elements like buttons.
 */
function keyboardUtils_isKeyboardClick(event) {
    return event.key === "Enter" || event.key === " ";
}
var ARROW_KEYS = (/* unused pure expression or super */ null && (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]));
function isArrowKey(event) {
    return ARROW_KEYS.includes(event.key);
}
/** Direction multiplier */
function getArrowKeyDirection(event, 
/** Keys that result in a return of -1 */
negativeKeys, 
/** Keys that result in a return of 1 */
positiveKeys) {
    if (negativeKeys.includes(event.key)) {
        return -1;
    }
    else if (positiveKeys.includes(event.key)) {
        return 1;
    }
    return undefined;
}

;// ./node_modules/@blueprintjs/core/lib/esm/accessibility/useInteractiveAttributes.js
/* !
 * (c) Copyright 2024 Palantir Technologies Inc. All rights reserved.
 */


var DEFAULT_OPTIONS = { defaultTabIndex: undefined, disabledTabIndex: -1 };
function useInteractiveAttributes(interactive, props, ref, options) {
    if (options === void 0) { options = DEFAULT_OPTIONS; }
    var defaultTabIndex = options.defaultTabIndex, disabledTabIndex = options.disabledTabIndex;
    var active = props.active, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onBlur = props.onBlur, _a = props.tabIndex, tabIndex = _a === void 0 ? defaultTabIndex : _a;
    // the current key being pressed
    var _b = react.useState(), currentKeyPressed = _b[0], setCurrentKeyPressed = _b[1];
    // whether the button is in "active" state
    var _c = react.useState(false), isActive = _c[0], setIsActive = _c[1];
    // our local ref for the interactive element, merged with the consumer's own ref in this hook's return value
    var elementRef = react.useRef(null);
    var handleBlur = react.useCallback(function (e) {
        if (isActive) {
            setIsActive(false);
        }
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    }, [isActive, onBlur]);
    var handleKeyDown = react.useCallback(function (e) {
        if (keyboardUtils_isKeyboardClick(e)) {
            e.preventDefault();
            if (e.key !== currentKeyPressed) {
                setIsActive(true);
            }
        }
        setCurrentKeyPressed(e.key);
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
    }, [currentKeyPressed, onKeyDown]);
    var handleKeyUp = react.useCallback(function (e) {
        var _a;
        if (keyboardUtils_isKeyboardClick(e)) {
            setIsActive(false);
            (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.click();
        }
        setCurrentKeyPressed(undefined);
        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(e);
    }, [onKeyUp, elementRef]);
    var resolvedActive = interactive && (active || isActive);
    return [
        resolvedActive,
        {
            onBlur: handleBlur,
            onClick: interactive ? onClick : undefined,
            onFocus: interactive ? onFocus : undefined,
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp,
            ref: mergeRefs(elementRef, ref),
            tabIndex: interactive ? tabIndex : disabledTabIndex,
        },
    ];
}

// EXTERNAL MODULE: ./node_modules/pascal-case/dist.es2015/index.js
var dist_es2015 = __webpack_require__(287);
// EXTERNAL MODULE: ./node_modules/no-case/dist.es2015/index.js + 1 modules
var no_case_dist_es2015 = __webpack_require__(3780);
;// ./node_modules/dot-case/dist.es2015/index.js


function dotCase(input, options) {
    if (options === void 0) { options = {}; }
    return (0,no_case_dist_es2015/* noCase */.W)(input, (0,tslib_es6/* __assign */.Cl)({ delimiter: "." }, options));
}

;// ./node_modules/snake-case/dist.es2015/index.js


function snakeCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, (0,tslib_es6/* __assign */.Cl)({ delimiter: "_" }, options));
}

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/16px/blueprint-icons-16.js
var _a;
var BlueprintIcons_16;
(function (BlueprintIcons_16) {
    BlueprintIcons_16["AddChild"] = "add-child";
    BlueprintIcons_16["AddClip"] = "add-clip";
    BlueprintIcons_16["AddColumnLeft"] = "add-column-left";
    BlueprintIcons_16["AddColumnRight"] = "add-column-right";
    BlueprintIcons_16["AddLocation"] = "add-location";
    BlueprintIcons_16["AddParent"] = "add-parent";
    BlueprintIcons_16["AddRowBottom"] = "add-row-bottom";
    BlueprintIcons_16["AddRowTop"] = "add-row-top";
    BlueprintIcons_16["AddToArtifact"] = "add-to-artifact";
    BlueprintIcons_16["AddToFolder"] = "add-to-folder";
    BlueprintIcons_16["Add"] = "add";
    BlueprintIcons_16["AimpointsTarget"] = "aimpoints-target";
    BlueprintIcons_16["Airplane"] = "airplane";
    BlueprintIcons_16["AlignCenter"] = "align-center";
    BlueprintIcons_16["AlignJustify"] = "align-justify";
    BlueprintIcons_16["AlignLeft"] = "align-left";
    BlueprintIcons_16["AlignRight"] = "align-right";
    BlueprintIcons_16["AlignmentBottom"] = "alignment-bottom";
    BlueprintIcons_16["AlignmentHorizontalCenter"] = "alignment-horizontal-center";
    BlueprintIcons_16["AlignmentLeft"] = "alignment-left";
    BlueprintIcons_16["AlignmentRight"] = "alignment-right";
    BlueprintIcons_16["AlignmentTop"] = "alignment-top";
    BlueprintIcons_16["AlignmentVerticalCenter"] = "alignment-vertical-center";
    BlueprintIcons_16["Ammunition"] = "ammunition";
    BlueprintIcons_16["Anchor"] = "anchor";
    BlueprintIcons_16["Annotation"] = "annotation";
    BlueprintIcons_16["Announcement"] = "announcement";
    BlueprintIcons_16["Antenna"] = "antenna";
    BlueprintIcons_16["AppHeader"] = "app-header";
    BlueprintIcons_16["Application"] = "application";
    BlueprintIcons_16["Applications"] = "applications";
    BlueprintIcons_16["Archive"] = "archive";
    BlueprintIcons_16["AreaOfInterest"] = "area-of-interest";
    BlueprintIcons_16["ArrayBoolean"] = "array-boolean";
    BlueprintIcons_16["ArrayDate"] = "array-date";
    BlueprintIcons_16["ArrayFloatingPoint"] = "array-floating-point";
    BlueprintIcons_16["ArrayNumeric"] = "array-numeric";
    BlueprintIcons_16["ArrayObject"] = "array-object";
    BlueprintIcons_16["ArrayString"] = "array-string";
    BlueprintIcons_16["ArrayTimestamp"] = "array-timestamp";
    BlueprintIcons_16["Array"] = "array";
    BlueprintIcons_16["ArrowBottomLeft"] = "arrow-bottom-left";
    BlueprintIcons_16["ArrowBottomRight"] = "arrow-bottom-right";
    BlueprintIcons_16["ArrowDown"] = "arrow-down";
    BlueprintIcons_16["ArrowLeft"] = "arrow-left";
    BlueprintIcons_16["ArrowRight"] = "arrow-right";
    BlueprintIcons_16["ArrowTopLeft"] = "arrow-top-left";
    BlueprintIcons_16["ArrowTopRight"] = "arrow-top-right";
    BlueprintIcons_16["ArrowUp"] = "arrow-up";
    BlueprintIcons_16["ArrowsArc"] = "arrows-arc";
    BlueprintIcons_16["ArrowsHorizontal"] = "arrows-horizontal";
    BlueprintIcons_16["ArrowsVertical"] = "arrows-vertical";
    BlueprintIcons_16["Asterisk"] = "asterisk";
    BlueprintIcons_16["At"] = "at";
    BlueprintIcons_16["AutomaticUpdates"] = "automatic-updates";
    BlueprintIcons_16["Axle"] = "axle";
    BlueprintIcons_16["Backlink"] = "backlink";
    BlueprintIcons_16["BackwardTen"] = "backward-ten";
    BlueprintIcons_16["Badge"] = "badge";
    BlueprintIcons_16["BanCircle"] = "ban-circle";
    BlueprintIcons_16["BankAccount"] = "bank-account";
    BlueprintIcons_16["Barcode"] = "barcode";
    BlueprintIcons_16["BinaryNumber"] = "binary-number";
    BlueprintIcons_16["Blank"] = "blank";
    BlueprintIcons_16["BlockPromote"] = "block-promote";
    BlueprintIcons_16["BlockedPerson"] = "blocked-person";
    BlueprintIcons_16["Bold"] = "bold";
    BlueprintIcons_16["Book"] = "book";
    BlueprintIcons_16["Bookmark"] = "bookmark";
    BlueprintIcons_16["Box"] = "box";
    BlueprintIcons_16["Briefcase"] = "briefcase";
    BlueprintIcons_16["BringData"] = "bring-data";
    BlueprintIcons_16["BringForward"] = "bring-forward";
    BlueprintIcons_16["BritishPound"] = "british-pound";
    BlueprintIcons_16["Bug"] = "bug";
    BlueprintIcons_16["Buggy"] = "buggy";
    BlueprintIcons_16["Build"] = "build";
    BlueprintIcons_16["Bullseye"] = "bullseye";
    BlueprintIcons_16["Calculator"] = "calculator";
    BlueprintIcons_16["Calendar"] = "calendar";
    BlueprintIcons_16["Camera"] = "camera";
    BlueprintIcons_16["CaretDown"] = "caret-down";
    BlueprintIcons_16["CaretLeft"] = "caret-left";
    BlueprintIcons_16["CaretRight"] = "caret-right";
    BlueprintIcons_16["CaretUp"] = "caret-up";
    BlueprintIcons_16["CargoShip"] = "cargo-ship";
    BlueprintIcons_16["CellTower"] = "cell-tower";
    BlueprintIcons_16["Changes"] = "changes";
    BlueprintIcons_16["Chart"] = "chart";
    BlueprintIcons_16["Chat"] = "chat";
    BlueprintIcons_16["ChevronBackward"] = "chevron-backward";
    BlueprintIcons_16["ChevronDown"] = "chevron-down";
    BlueprintIcons_16["ChevronForward"] = "chevron-forward";
    BlueprintIcons_16["ChevronLeft"] = "chevron-left";
    BlueprintIcons_16["ChevronRight"] = "chevron-right";
    BlueprintIcons_16["ChevronUp"] = "chevron-up";
    BlueprintIcons_16["CircleArrowDown"] = "circle-arrow-down";
    BlueprintIcons_16["CircleArrowLeft"] = "circle-arrow-left";
    BlueprintIcons_16["CircleArrowRight"] = "circle-arrow-right";
    BlueprintIcons_16["CircleArrowUp"] = "circle-arrow-up";
    BlueprintIcons_16["Circle"] = "circle";
    BlueprintIcons_16["Citation"] = "citation";
    BlueprintIcons_16["Clean"] = "clean";
    BlueprintIcons_16["Clip"] = "clip";
    BlueprintIcons_16["ClipboardFile"] = "clipboard-file";
    BlueprintIcons_16["Clipboard"] = "clipboard";
    BlueprintIcons_16["CloudDownload"] = "cloud-download";
    BlueprintIcons_16["CloudServer"] = "cloud-server";
    BlueprintIcons_16["CloudTick"] = "cloud-tick";
    BlueprintIcons_16["CloudUpload"] = "cloud-upload";
    BlueprintIcons_16["Cloud"] = "cloud";
    BlueprintIcons_16["CodeBlock"] = "code-block";
    BlueprintIcons_16["Code"] = "code";
    BlueprintIcons_16["Cog"] = "cog";
    BlueprintIcons_16["CollapseAll"] = "collapse-all";
    BlueprintIcons_16["ColorFill"] = "color-fill";
    BlueprintIcons_16["ColumnLayout"] = "column-layout";
    BlueprintIcons_16["Comment"] = "comment";
    BlueprintIcons_16["Comparison"] = "comparison";
    BlueprintIcons_16["Compass"] = "compass";
    BlueprintIcons_16["Compressed"] = "compressed";
    BlueprintIcons_16["Confirm"] = "confirm";
    BlueprintIcons_16["Console"] = "console";
    BlueprintIcons_16["Construction"] = "construction";
    BlueprintIcons_16["Contrast"] = "contrast";
    BlueprintIcons_16["Control"] = "control";
    BlueprintIcons_16["CreditCard"] = "credit-card";
    BlueprintIcons_16["Crop"] = "crop";
    BlueprintIcons_16["CrossCircle"] = "cross-circle";
    BlueprintIcons_16["Cross"] = "cross";
    BlueprintIcons_16["Crown"] = "crown";
    BlueprintIcons_16["CssStyle"] = "css-style";
    BlueprintIcons_16["CubeAdd"] = "cube-add";
    BlueprintIcons_16["CubeEdit"] = "cube-edit";
    BlueprintIcons_16["CubeRemove"] = "cube-remove";
    BlueprintIcons_16["Cube"] = "cube";
    BlueprintIcons_16["Cubes"] = "cubes";
    BlueprintIcons_16["CurlyBraces"] = "curly-braces";
    BlueprintIcons_16["CurvedRangeChart"] = "curved-range-chart";
    BlueprintIcons_16["Cut"] = "cut";
    BlueprintIcons_16["Cycle"] = "cycle";
    BlueprintIcons_16["Dashboard"] = "dashboard";
    BlueprintIcons_16["DataCloud"] = "data-cloud";
    BlueprintIcons_16["DataConnection"] = "data-connection";
    BlueprintIcons_16["DataLineage"] = "data-lineage";
    BlueprintIcons_16["DataSearch"] = "data-search";
    BlueprintIcons_16["DataSync"] = "data-sync";
    BlueprintIcons_16["Database"] = "database";
    BlueprintIcons_16["DeleteClip"] = "delete-clip";
    BlueprintIcons_16["Delete"] = "delete";
    BlueprintIcons_16["Delta"] = "delta";
    BlueprintIcons_16["DeriveColumn"] = "derive-column";
    BlueprintIcons_16["Desktop"] = "desktop";
    BlueprintIcons_16["Detection"] = "detection";
    BlueprintIcons_16["Diagnosis"] = "diagnosis";
    BlueprintIcons_16["DiagramTree"] = "diagram-tree";
    BlueprintIcons_16["DirectionLeft"] = "direction-left";
    BlueprintIcons_16["DirectionRight"] = "direction-right";
    BlueprintIcons_16["Disable"] = "disable";
    BlueprintIcons_16["Divide"] = "divide";
    BlueprintIcons_16["DocumentCode"] = "document-code";
    BlueprintIcons_16["DocumentLocked"] = "document-locked";
    BlueprintIcons_16["DocumentOpen"] = "document-open";
    BlueprintIcons_16["DocumentShare"] = "document-share";
    BlueprintIcons_16["Document"] = "document";
    BlueprintIcons_16["Dollar"] = "dollar";
    BlueprintIcons_16["Dot"] = "dot";
    BlueprintIcons_16["DoubleCaretHorizontal"] = "double-caret-horizontal";
    BlueprintIcons_16["DoubleCaretVertical"] = "double-caret-vertical";
    BlueprintIcons_16["DoubleChevronDown"] = "double-chevron-down";
    BlueprintIcons_16["DoubleChevronLeft"] = "double-chevron-left";
    BlueprintIcons_16["DoubleChevronRight"] = "double-chevron-right";
    BlueprintIcons_16["DoubleChevronUp"] = "double-chevron-up";
    BlueprintIcons_16["DoughnutChart"] = "doughnut-chart";
    BlueprintIcons_16["Download"] = "download";
    BlueprintIcons_16["DragHandleHorizontal"] = "drag-handle-horizontal";
    BlueprintIcons_16["DragHandleVertical"] = "drag-handle-vertical";
    BlueprintIcons_16["Draw"] = "draw";
    BlueprintIcons_16["DrawerLeftFilled"] = "drawer-left-filled";
    BlueprintIcons_16["DrawerLeft"] = "drawer-left";
    BlueprintIcons_16["DrawerRightFilled"] = "drawer-right-filled";
    BlueprintIcons_16["DrawerRight"] = "drawer-right";
    BlueprintIcons_16["DriveTime"] = "drive-time";
    BlueprintIcons_16["Duplicate"] = "duplicate";
    BlueprintIcons_16["Edit"] = "edit";
    BlueprintIcons_16["Eject"] = "eject";
    BlueprintIcons_16["Emoji"] = "emoji";
    BlueprintIcons_16["Endnote"] = "endnote";
    BlueprintIcons_16["Endorsed"] = "endorsed";
    BlueprintIcons_16["Envelope"] = "envelope";
    BlueprintIcons_16["Equals"] = "equals";
    BlueprintIcons_16["Eraser"] = "eraser";
    BlueprintIcons_16["Error"] = "error";
    BlueprintIcons_16["Euro"] = "euro";
    BlueprintIcons_16["Excavator"] = "excavator";
    BlueprintIcons_16["Exchange"] = "exchange";
    BlueprintIcons_16["ExcludeRow"] = "exclude-row";
    BlueprintIcons_16["ExpandAll"] = "expand-all";
    BlueprintIcons_16["Explain"] = "explain";
    BlueprintIcons_16["Export"] = "export";
    BlueprintIcons_16["EyeOff"] = "eye-off";
    BlueprintIcons_16["EyeOn"] = "eye-on";
    BlueprintIcons_16["EyeOpen"] = "eye-open";
    BlueprintIcons_16["FastBackward"] = "fast-backward";
    BlueprintIcons_16["FastForward"] = "fast-forward";
    BlueprintIcons_16["FeedSubscribed"] = "feed-subscribed";
    BlueprintIcons_16["Feed"] = "feed";
    BlueprintIcons_16["FighterJet"] = "fighter-jet";
    BlueprintIcons_16["Film"] = "film";
    BlueprintIcons_16["FilterKeep"] = "filter-keep";
    BlueprintIcons_16["FilterList"] = "filter-list";
    BlueprintIcons_16["FilterOpen"] = "filter-open";
    BlueprintIcons_16["FilterRemove"] = "filter-remove";
    BlueprintIcons_16["FilterSortAsc"] = "filter-sort-asc";
    BlueprintIcons_16["FilterSortDesc"] = "filter-sort-desc";
    BlueprintIcons_16["Filter"] = "filter";
    BlueprintIcons_16["Flag"] = "flag";
    BlueprintIcons_16["Flame"] = "flame";
    BlueprintIcons_16["Flash"] = "flash";
    BlueprintIcons_16["FloatingPoint"] = "floating-point";
    BlueprintIcons_16["FloppyDisk"] = "floppy-disk";
    BlueprintIcons_16["FlowBranch"] = "flow-branch";
    BlueprintIcons_16["FlowEnd"] = "flow-end";
    BlueprintIcons_16["FlowLinear"] = "flow-linear";
    BlueprintIcons_16["FlowReviewBranch"] = "flow-review-branch";
    BlueprintIcons_16["FlowReview"] = "flow-review";
    BlueprintIcons_16["Flows"] = "flows";
    BlueprintIcons_16["FolderClose"] = "folder-close";
    BlueprintIcons_16["FolderNew"] = "folder-new";
    BlueprintIcons_16["FolderOpen"] = "folder-open";
    BlueprintIcons_16["FolderSharedOpen"] = "folder-shared-open";
    BlueprintIcons_16["FolderShared"] = "folder-shared";
    BlueprintIcons_16["Follower"] = "follower";
    BlueprintIcons_16["Following"] = "following";
    BlueprintIcons_16["Font"] = "font";
    BlueprintIcons_16["Fork"] = "fork";
    BlueprintIcons_16["Form"] = "form";
    BlueprintIcons_16["ForwardTen"] = "forward-ten";
    BlueprintIcons_16["Fuel"] = "fuel";
    BlueprintIcons_16["FullCircle"] = "full-circle";
    BlueprintIcons_16["FullStackedChart"] = "full-stacked-chart";
    BlueprintIcons_16["Fullscreen"] = "fullscreen";
    BlueprintIcons_16["Function"] = "function";
    BlueprintIcons_16["GanttChart"] = "gantt-chart";
    BlueprintIcons_16["Generate"] = "generate";
    BlueprintIcons_16["Geofence"] = "geofence";
    BlueprintIcons_16["Geolocation"] = "geolocation";
    BlueprintIcons_16["Geosearch"] = "geosearch";
    BlueprintIcons_16["Geotime"] = "geotime";
    BlueprintIcons_16["GiftBox"] = "gift-box";
    BlueprintIcons_16["GitBranch"] = "git-branch";
    BlueprintIcons_16["GitCommit"] = "git-commit";
    BlueprintIcons_16["GitMerge"] = "git-merge";
    BlueprintIcons_16["GitNewBranch"] = "git-new-branch";
    BlueprintIcons_16["GitPull"] = "git-pull";
    BlueprintIcons_16["GitPush"] = "git-push";
    BlueprintIcons_16["GitRepo"] = "git-repo";
    BlueprintIcons_16["Glass"] = "glass";
    BlueprintIcons_16["GlobeNetworkAdd"] = "globe-network-add";
    BlueprintIcons_16["GlobeNetwork"] = "globe-network";
    BlueprintIcons_16["Globe"] = "globe";
    BlueprintIcons_16["GraphRemove"] = "graph-remove";
    BlueprintIcons_16["Graph"] = "graph";
    BlueprintIcons_16["GreaterThanOrEqualTo"] = "greater-than-or-equal-to";
    BlueprintIcons_16["GreaterThan"] = "greater-than";
    BlueprintIcons_16["GridView"] = "grid-view";
    BlueprintIcons_16["Grid"] = "grid";
    BlueprintIcons_16["GroupItem"] = "group-item";
    BlueprintIcons_16["GroupObjects"] = "group-objects";
    BlueprintIcons_16["GroupedBarChart"] = "grouped-bar-chart";
    BlueprintIcons_16["HandDown"] = "hand-down";
    BlueprintIcons_16["HandLeft"] = "hand-left";
    BlueprintIcons_16["HandRight"] = "hand-right";
    BlueprintIcons_16["HandUp"] = "hand-up";
    BlueprintIcons_16["Hand"] = "hand";
    BlueprintIcons_16["Hat"] = "hat";
    BlueprintIcons_16["HeaderOne"] = "header-one";
    BlueprintIcons_16["HeaderThree"] = "header-three";
    BlueprintIcons_16["HeaderTwo"] = "header-two";
    BlueprintIcons_16["Header"] = "header";
    BlueprintIcons_16["Headset"] = "headset";
    BlueprintIcons_16["HeartBroken"] = "heart-broken";
    BlueprintIcons_16["Heart"] = "heart";
    BlueprintIcons_16["HeatGrid"] = "heat-grid";
    BlueprintIcons_16["Heatmap"] = "heatmap";
    BlueprintIcons_16["Helicopter"] = "helicopter";
    BlueprintIcons_16["Help"] = "help";
    BlueprintIcons_16["HelperManagement"] = "helper-management";
    BlueprintIcons_16["Hexagon"] = "hexagon";
    BlueprintIcons_16["HighPriority"] = "high-priority";
    BlueprintIcons_16["HighVoltagePole"] = "high-voltage-pole";
    BlueprintIcons_16["Highlight"] = "highlight";
    BlueprintIcons_16["History"] = "history";
    BlueprintIcons_16["Home"] = "home";
    BlueprintIcons_16["HorizontalBarChartAsc"] = "horizontal-bar-chart-asc";
    BlueprintIcons_16["HorizontalBarChartDesc"] = "horizontal-bar-chart-desc";
    BlueprintIcons_16["HorizontalBarChart"] = "horizontal-bar-chart";
    BlueprintIcons_16["HorizontalDistribution"] = "horizontal-distribution";
    BlueprintIcons_16["HorizontalInbetween"] = "horizontal-inbetween";
    BlueprintIcons_16["Hurricane"] = "hurricane";
    BlueprintIcons_16["IdNumber"] = "id-number";
    BlueprintIcons_16["ImageRotateLeft"] = "image-rotate-left";
    BlueprintIcons_16["ImageRotateRight"] = "image-rotate-right";
    BlueprintIcons_16["Import"] = "import";
    BlueprintIcons_16["InboxFiltered"] = "inbox-filtered";
    BlueprintIcons_16["InboxGeo"] = "inbox-geo";
    BlueprintIcons_16["InboxSearch"] = "inbox-search";
    BlueprintIcons_16["InboxUpdate"] = "inbox-update";
    BlueprintIcons_16["Inbox"] = "inbox";
    BlueprintIcons_16["InfoSign"] = "info-sign";
    BlueprintIcons_16["Inheritance"] = "inheritance";
    BlueprintIcons_16["InheritedGroup"] = "inherited-group";
    BlueprintIcons_16["InnerJoin"] = "inner-join";
    BlueprintIcons_16["Input"] = "input";
    BlueprintIcons_16["Insert"] = "insert";
    BlueprintIcons_16["Intelligence"] = "intelligence";
    BlueprintIcons_16["Intersection"] = "intersection";
    BlueprintIcons_16["IpAddress"] = "ip-address";
    BlueprintIcons_16["IssueClosed"] = "issue-closed";
    BlueprintIcons_16["IssueNew"] = "issue-new";
    BlueprintIcons_16["Issue"] = "issue";
    BlueprintIcons_16["Italic"] = "italic";
    BlueprintIcons_16["JoinTable"] = "join-table";
    BlueprintIcons_16["KeyBackspace"] = "key-backspace";
    BlueprintIcons_16["KeyCommand"] = "key-command";
    BlueprintIcons_16["KeyControl"] = "key-control";
    BlueprintIcons_16["KeyDelete"] = "key-delete";
    BlueprintIcons_16["KeyEnter"] = "key-enter";
    BlueprintIcons_16["KeyEscape"] = "key-escape";
    BlueprintIcons_16["KeyOption"] = "key-option";
    BlueprintIcons_16["KeyShift"] = "key-shift";
    BlueprintIcons_16["KeyTab"] = "key-tab";
    BlueprintIcons_16["Key"] = "key";
    BlueprintIcons_16["KnownVehicle"] = "known-vehicle";
    BlueprintIcons_16["LabTest"] = "lab-test";
    BlueprintIcons_16["Label"] = "label";
    BlueprintIcons_16["LayerOutline"] = "layer-outline";
    BlueprintIcons_16["Layer"] = "layer";
    BlueprintIcons_16["Layers"] = "layers";
    BlueprintIcons_16["LayoutAuto"] = "layout-auto";
    BlueprintIcons_16["LayoutBalloon"] = "layout-balloon";
    BlueprintIcons_16["LayoutBottomRowThreeTiles"] = "layout-bottom-row-three-tiles";
    BlueprintIcons_16["LayoutBottomRowTwoTiles"] = "layout-bottom-row-two-tiles";
    BlueprintIcons_16["LayoutCircle"] = "layout-circle";
    BlueprintIcons_16["LayoutGrid"] = "layout-grid";
    BlueprintIcons_16["LayoutGroupBy"] = "layout-group-by";
    BlueprintIcons_16["LayoutHierarchy"] = "layout-hierarchy";
    BlueprintIcons_16["LayoutLeftColumnThreeTiles"] = "layout-left-column-three-tiles";
    BlueprintIcons_16["LayoutLeftColumnTwoTiles"] = "layout-left-column-two-tiles";
    BlueprintIcons_16["LayoutLinear"] = "layout-linear";
    BlueprintIcons_16["LayoutRightColumnThreeTiles"] = "layout-right-column-three-tiles";
    BlueprintIcons_16["LayoutRightColumnTwoTiles"] = "layout-right-column-two-tiles";
    BlueprintIcons_16["LayoutSkewGrid"] = "layout-skew-grid";
    BlueprintIcons_16["LayoutSortedClusters"] = "layout-sorted-clusters";
    BlueprintIcons_16["LayoutThreeColumns"] = "layout-three-columns";
    BlueprintIcons_16["LayoutThreeRows"] = "layout-three-rows";
    BlueprintIcons_16["LayoutTopRowThreeTiles"] = "layout-top-row-three-tiles";
    BlueprintIcons_16["LayoutTopRowTwoTiles"] = "layout-top-row-two-tiles";
    BlueprintIcons_16["LayoutTwoColumns"] = "layout-two-columns";
    BlueprintIcons_16["LayoutTwoRows"] = "layout-two-rows";
    BlueprintIcons_16["Layout"] = "layout";
    BlueprintIcons_16["Learning"] = "learning";
    BlueprintIcons_16["LeftJoin"] = "left-join";
    BlueprintIcons_16["LengthenText"] = "lengthen-text";
    BlueprintIcons_16["LessThanOrEqualTo"] = "less-than-or-equal-to";
    BlueprintIcons_16["LessThan"] = "less-than";
    BlueprintIcons_16["Lifesaver"] = "lifesaver";
    BlueprintIcons_16["Lightbulb"] = "lightbulb";
    BlueprintIcons_16["Lightning"] = "lightning";
    BlueprintIcons_16["Link"] = "link";
    BlueprintIcons_16["LinkedSquares"] = "linked-squares";
    BlueprintIcons_16["ListColumns"] = "list-columns";
    BlueprintIcons_16["ListDetailView"] = "list-detail-view";
    BlueprintIcons_16["List"] = "list";
    BlueprintIcons_16["Locate"] = "locate";
    BlueprintIcons_16["Lock"] = "lock";
    BlueprintIcons_16["Locomotive"] = "locomotive";
    BlueprintIcons_16["LogIn"] = "log-in";
    BlueprintIcons_16["LogOut"] = "log-out";
    BlueprintIcons_16["LowVoltagePole"] = "low-voltage-pole";
    BlueprintIcons_16["Manual"] = "manual";
    BlueprintIcons_16["ManuallyEnteredData"] = "manually-entered-data";
    BlueprintIcons_16["ManyToMany"] = "many-to-many";
    BlueprintIcons_16["ManyToOne"] = "many-to-one";
    BlueprintIcons_16["MapCreate"] = "map-create";
    BlueprintIcons_16["MapMarker"] = "map-marker";
    BlueprintIcons_16["Map"] = "map";
    BlueprintIcons_16["Maximize"] = "maximize";
    BlueprintIcons_16["Media"] = "media";
    BlueprintIcons_16["MenuClosed"] = "menu-closed";
    BlueprintIcons_16["MenuOpen"] = "menu-open";
    BlueprintIcons_16["Menu"] = "menu";
    BlueprintIcons_16["MergeColumns"] = "merge-columns";
    BlueprintIcons_16["MergeLinks"] = "merge-links";
    BlueprintIcons_16["Microphone"] = "microphone";
    BlueprintIcons_16["Minimize"] = "minimize";
    BlueprintIcons_16["Minus"] = "minus";
    BlueprintIcons_16["MobilePhone"] = "mobile-phone";
    BlueprintIcons_16["MobileVideo"] = "mobile-video";
    BlueprintIcons_16["ModalFilled"] = "modal-filled";
    BlueprintIcons_16["Modal"] = "modal";
    BlueprintIcons_16["Model"] = "model";
    BlueprintIcons_16["Moon"] = "moon";
    BlueprintIcons_16["More"] = "more";
    BlueprintIcons_16["Mountain"] = "mountain";
    BlueprintIcons_16["Move"] = "move";
    BlueprintIcons_16["Mugshot"] = "mugshot";
    BlueprintIcons_16["MultiSelect"] = "multi-select";
    BlueprintIcons_16["Music"] = "music";
    BlueprintIcons_16["Nest"] = "nest";
    BlueprintIcons_16["NewDrawing"] = "new-drawing";
    BlueprintIcons_16["NewGridItem"] = "new-grid-item";
    BlueprintIcons_16["NewLayer"] = "new-layer";
    BlueprintIcons_16["NewLayers"] = "new-layers";
    BlueprintIcons_16["NewLink"] = "new-link";
    BlueprintIcons_16["NewObject"] = "new-object";
    BlueprintIcons_16["NewPerson"] = "new-person";
    BlueprintIcons_16["NewPrescription"] = "new-prescription";
    BlueprintIcons_16["NewShield"] = "new-shield";
    BlueprintIcons_16["NewTextBox"] = "new-text-box";
    BlueprintIcons_16["Ninja"] = "ninja";
    BlueprintIcons_16["NotEqualTo"] = "not-equal-to";
    BlueprintIcons_16["NotificationsAdd"] = "notifications-add";
    BlueprintIcons_16["NotificationsSnooze"] = "notifications-snooze";
    BlueprintIcons_16["NotificationsUpdated"] = "notifications-updated";
    BlueprintIcons_16["Notifications"] = "notifications";
    BlueprintIcons_16["NumberedList"] = "numbered-list";
    BlueprintIcons_16["Numerical"] = "numerical";
    BlueprintIcons_16["ObjectView"] = "object-view";
    BlueprintIcons_16["Office"] = "office";
    BlueprintIcons_16["Offline"] = "offline";
    BlueprintIcons_16["OilField"] = "oil-field";
    BlueprintIcons_16["OneColumn"] = "one-column";
    BlueprintIcons_16["OneToMany"] = "one-to-many";
    BlueprintIcons_16["OneToOne"] = "one-to-one";
    BlueprintIcons_16["OpenApplication"] = "open-application";
    BlueprintIcons_16["Outdated"] = "outdated";
    BlueprintIcons_16["Output"] = "output";
    BlueprintIcons_16["Package"] = "package";
    BlueprintIcons_16["PageBreak"] = "page-break";
    BlueprintIcons_16["PageLayout"] = "page-layout";
    BlueprintIcons_16["PanelStats"] = "panel-stats";
    BlueprintIcons_16["PanelTable"] = "panel-table";
    BlueprintIcons_16["Panel"] = "panel";
    BlueprintIcons_16["Paperclip"] = "paperclip";
    BlueprintIcons_16["Paragraph"] = "paragraph";
    BlueprintIcons_16["PasteVariable"] = "paste-variable";
    BlueprintIcons_16["PathSearch"] = "path-search";
    BlueprintIcons_16["Path"] = "path";
    BlueprintIcons_16["Pause"] = "pause";
    BlueprintIcons_16["People"] = "people";
    BlueprintIcons_16["Percentage"] = "percentage";
    BlueprintIcons_16["Person"] = "person";
    BlueprintIcons_16["PhoneCall"] = "phone-call";
    BlueprintIcons_16["PhoneForward"] = "phone-forward";
    BlueprintIcons_16["PhoneSearch"] = "phone-search";
    BlueprintIcons_16["Phone"] = "phone";
    BlueprintIcons_16["PieChart"] = "pie-chart";
    BlueprintIcons_16["Pill"] = "pill";
    BlueprintIcons_16["Pin"] = "pin";
    BlueprintIcons_16["Pistol"] = "pistol";
    BlueprintIcons_16["PivotTable"] = "pivot-table";
    BlueprintIcons_16["Pivot"] = "pivot";
    BlueprintIcons_16["Play"] = "play";
    BlueprintIcons_16["Playbook"] = "playbook";
    BlueprintIcons_16["Plus"] = "plus";
    BlueprintIcons_16["PolygonFilter"] = "polygon-filter";
    BlueprintIcons_16["Power"] = "power";
    BlueprintIcons_16["PredictiveAnalysis"] = "predictive-analysis";
    BlueprintIcons_16["Prescription"] = "prescription";
    BlueprintIcons_16["Presentation"] = "presentation";
    BlueprintIcons_16["Print"] = "print";
    BlueprintIcons_16["Projects"] = "projects";
    BlueprintIcons_16["Properties"] = "properties";
    BlueprintIcons_16["Property"] = "property";
    BlueprintIcons_16["PublishFunction"] = "publish-function";
    BlueprintIcons_16["Pulse"] = "pulse";
    BlueprintIcons_16["Rain"] = "rain";
    BlueprintIcons_16["Random"] = "random";
    BlueprintIcons_16["RangeRing"] = "range-ring";
    BlueprintIcons_16["Record"] = "record";
    BlueprintIcons_16["RectHeight"] = "rect-height";
    BlueprintIcons_16["RectWidth"] = "rect-width";
    BlueprintIcons_16["Rectangle"] = "rectangle";
    BlueprintIcons_16["Redo"] = "redo";
    BlueprintIcons_16["Refresh"] = "refresh";
    BlueprintIcons_16["Regex"] = "regex";
    BlueprintIcons_16["RegressionChart"] = "regression-chart";
    BlueprintIcons_16["RemoveColumnLeft"] = "remove-column-left";
    BlueprintIcons_16["RemoveColumnRight"] = "remove-column-right";
    BlueprintIcons_16["RemoveColumn"] = "remove-column";
    BlueprintIcons_16["RemoveRowBottom"] = "remove-row-bottom";
    BlueprintIcons_16["RemoveRowTop"] = "remove-row-top";
    BlueprintIcons_16["Remove"] = "remove";
    BlueprintIcons_16["Repeat"] = "repeat";
    BlueprintIcons_16["Reset"] = "reset";
    BlueprintIcons_16["Resolve"] = "resolve";
    BlueprintIcons_16["Rig"] = "rig";
    BlueprintIcons_16["RightJoin"] = "right-join";
    BlueprintIcons_16["Ring"] = "ring";
    BlueprintIcons_16["RocketSlant"] = "rocket-slant";
    BlueprintIcons_16["Rocket"] = "rocket";
    BlueprintIcons_16["RootFolder"] = "root-folder";
    BlueprintIcons_16["RotateCcw"] = "rotate-ccw";
    BlueprintIcons_16["RotateCw"] = "rotate-cw";
    BlueprintIcons_16["RotateDocument"] = "rotate-document";
    BlueprintIcons_16["RotatePage"] = "rotate-page";
    BlueprintIcons_16["Route"] = "route";
    BlueprintIcons_16["RunHistory"] = "run-history";
    BlueprintIcons_16["Satellite"] = "satellite";
    BlueprintIcons_16["Saved"] = "saved";
    BlueprintIcons_16["ScatterPlot"] = "scatter-plot";
    BlueprintIcons_16["SearchAround"] = "search-around";
    BlueprintIcons_16["SearchTemplate"] = "search-template";
    BlueprintIcons_16["SearchText"] = "search-text";
    BlueprintIcons_16["Search"] = "search";
    BlueprintIcons_16["SegmentedControl"] = "segmented-control";
    BlueprintIcons_16["Select"] = "select";
    BlueprintIcons_16["SelectionBoxAdd"] = "selection-box-add";
    BlueprintIcons_16["SelectionBoxEdit"] = "selection-box-edit";
    BlueprintIcons_16["SelectionBox"] = "selection-box";
    BlueprintIcons_16["Selection"] = "selection";
    BlueprintIcons_16["SendBackward"] = "send-backward";
    BlueprintIcons_16["SendMessage"] = "send-message";
    BlueprintIcons_16["SendToGraph"] = "send-to-graph";
    BlueprintIcons_16["SendToMap"] = "send-to-map";
    BlueprintIcons_16["SendTo"] = "send-to";
    BlueprintIcons_16["Sensor"] = "sensor";
    BlueprintIcons_16["SeriesAdd"] = "series-add";
    BlueprintIcons_16["SeriesConfiguration"] = "series-configuration";
    BlueprintIcons_16["SeriesDerived"] = "series-derived";
    BlueprintIcons_16["SeriesFiltered"] = "series-filtered";
    BlueprintIcons_16["SeriesSearch"] = "series-search";
    BlueprintIcons_16["ServerInstall"] = "server-install";
    BlueprintIcons_16["Server"] = "server";
    BlueprintIcons_16["Settings"] = "settings";
    BlueprintIcons_16["Shapes"] = "shapes";
    BlueprintIcons_16["Share"] = "share";
    BlueprintIcons_16["SharedFilter"] = "shared-filter";
    BlueprintIcons_16["Shield"] = "shield";
    BlueprintIcons_16["Ship"] = "ship";
    BlueprintIcons_16["Shop"] = "shop";
    BlueprintIcons_16["ShoppingCart"] = "shopping-cart";
    BlueprintIcons_16["ShortenText"] = "shorten-text";
    BlueprintIcons_16["SignalSearch"] = "signal-search";
    BlueprintIcons_16["SimCard"] = "sim-card";
    BlueprintIcons_16["Slash"] = "slash";
    BlueprintIcons_16["SmallCross"] = "small-cross";
    BlueprintIcons_16["SmallInfoSign"] = "small-info-sign";
    BlueprintIcons_16["SmallMinus"] = "small-minus";
    BlueprintIcons_16["SmallPlus"] = "small-plus";
    BlueprintIcons_16["SmallSquare"] = "small-square";
    BlueprintIcons_16["SmallTick"] = "small-tick";
    BlueprintIcons_16["Snowflake"] = "snowflake";
    BlueprintIcons_16["SoccerBall"] = "soccer-ball";
    BlueprintIcons_16["SocialMedia"] = "social-media";
    BlueprintIcons_16["SortAlphabeticalDesc"] = "sort-alphabetical-desc";
    BlueprintIcons_16["SortAlphabetical"] = "sort-alphabetical";
    BlueprintIcons_16["SortAsc"] = "sort-asc";
    BlueprintIcons_16["SortDesc"] = "sort-desc";
    BlueprintIcons_16["SortNumericalDesc"] = "sort-numerical-desc";
    BlueprintIcons_16["SortNumerical"] = "sort-numerical";
    BlueprintIcons_16["Sort"] = "sort";
    BlueprintIcons_16["SpellCheck"] = "spell-check";
    BlueprintIcons_16["SplitColumns"] = "split-columns";
    BlueprintIcons_16["SportsStadium"] = "sports-stadium";
    BlueprintIcons_16["Square"] = "square";
    BlueprintIcons_16["StackedChart"] = "stacked-chart";
    BlueprintIcons_16["StadiumGeometry"] = "stadium-geometry";
    BlueprintIcons_16["StarEmpty"] = "star-empty";
    BlueprintIcons_16["Star"] = "star";
    BlueprintIcons_16["StepBackward"] = "step-backward";
    BlueprintIcons_16["StepChart"] = "step-chart";
    BlueprintIcons_16["StepForward"] = "step-forward";
    BlueprintIcons_16["Stop"] = "stop";
    BlueprintIcons_16["Stopwatch"] = "stopwatch";
    BlueprintIcons_16["Strikethrough"] = "strikethrough";
    BlueprintIcons_16["Style"] = "style";
    BlueprintIcons_16["Subscript"] = "subscript";
    BlueprintIcons_16["SubtractRightJoin"] = "subtract-right-join";
    BlueprintIcons_16["Superscript"] = "superscript";
    BlueprintIcons_16["SwapHorizontal"] = "swap-horizontal";
    BlueprintIcons_16["SwapVertical"] = "swap-vertical";
    BlueprintIcons_16["Sweep"] = "sweep";
    BlueprintIcons_16["Switch"] = "switch";
    BlueprintIcons_16["SymbolCircle"] = "symbol-circle";
    BlueprintIcons_16["SymbolCross"] = "symbol-cross";
    BlueprintIcons_16["SymbolDiamond"] = "symbol-diamond";
    BlueprintIcons_16["SymbolRectangle"] = "symbol-rectangle";
    BlueprintIcons_16["SymbolSquare"] = "symbol-square";
    BlueprintIcons_16["SymbolTriangleDown"] = "symbol-triangle-down";
    BlueprintIcons_16["SymbolTriangleUp"] = "symbol-triangle-up";
    BlueprintIcons_16["Syringe"] = "syringe";
    BlueprintIcons_16["TableSync"] = "table-sync";
    BlueprintIcons_16["TagAdd"] = "tag-add";
    BlueprintIcons_16["TagPromote"] = "tag-promote";
    BlueprintIcons_16["TagRefresh"] = "tag-refresh";
    BlueprintIcons_16["TagUndo"] = "tag-undo";
    BlueprintIcons_16["Tag"] = "tag";
    BlueprintIcons_16["Tags"] = "tags";
    BlueprintIcons_16["TakeAction"] = "take-action";
    BlueprintIcons_16["Tank"] = "tank";
    BlueprintIcons_16["Target"] = "target";
    BlueprintIcons_16["Taxi"] = "taxi";
    BlueprintIcons_16["Team"] = "team";
    BlueprintIcons_16["Temperature"] = "temperature";
    BlueprintIcons_16["TextHighlight"] = "text-highlight";
    BlueprintIcons_16["ThAdd"] = "th-add";
    BlueprintIcons_16["ThDerived"] = "th-derived";
    BlueprintIcons_16["ThDisconnect"] = "th-disconnect";
    BlueprintIcons_16["ThFiltered"] = "th-filtered";
    BlueprintIcons_16["ThListAdd"] = "th-list-add";
    BlueprintIcons_16["ThList"] = "th-list";
    BlueprintIcons_16["ThVirtualAdd"] = "th-virtual-add";
    BlueprintIcons_16["ThVirtual"] = "th-virtual";
    BlueprintIcons_16["Th"] = "th";
    BlueprintIcons_16["ThirdParty"] = "third-party";
    BlueprintIcons_16["ThumbsDown"] = "thumbs-down";
    BlueprintIcons_16["ThumbsUp"] = "thumbs-up";
    BlueprintIcons_16["TickCircle"] = "tick-circle";
    BlueprintIcons_16["Tick"] = "tick";
    BlueprintIcons_16["Time"] = "time";
    BlueprintIcons_16["TimelineAreaChart"] = "timeline-area-chart";
    BlueprintIcons_16["TimelineBarChart"] = "timeline-bar-chart";
    BlueprintIcons_16["TimelineEvents"] = "timeline-events";
    BlueprintIcons_16["TimelineLineChart"] = "timeline-line-chart";
    BlueprintIcons_16["Tint"] = "tint";
    BlueprintIcons_16["Torch"] = "torch";
    BlueprintIcons_16["Tractor"] = "tractor";
    BlueprintIcons_16["Train"] = "train";
    BlueprintIcons_16["Translate"] = "translate";
    BlueprintIcons_16["Trash"] = "trash";
    BlueprintIcons_16["Tree"] = "tree";
    BlueprintIcons_16["TrendingDown"] = "trending-down";
    BlueprintIcons_16["TrendingUp"] = "trending-up";
    BlueprintIcons_16["Trophy"] = "trophy";
    BlueprintIcons_16["Truck"] = "truck";
    BlueprintIcons_16["TwoColumns"] = "two-columns";
    BlueprintIcons_16["Unarchive"] = "unarchive";
    BlueprintIcons_16["Underline"] = "underline";
    BlueprintIcons_16["Undo"] = "undo";
    BlueprintIcons_16["UngroupObjects"] = "ungroup-objects";
    BlueprintIcons_16["UnknownVehicle"] = "unknown-vehicle";
    BlueprintIcons_16["Unlink"] = "unlink";
    BlueprintIcons_16["Unlock"] = "unlock";
    BlueprintIcons_16["Unpin"] = "unpin";
    BlueprintIcons_16["Unresolve"] = "unresolve";
    BlueprintIcons_16["Updated"] = "updated";
    BlueprintIcons_16["Upload"] = "upload";
    BlueprintIcons_16["User"] = "user";
    BlueprintIcons_16["Variable"] = "variable";
    BlueprintIcons_16["Vector"] = "vector";
    BlueprintIcons_16["VerticalBarChartAsc"] = "vertical-bar-chart-asc";
    BlueprintIcons_16["VerticalBarChartDesc"] = "vertical-bar-chart-desc";
    BlueprintIcons_16["VerticalDistribution"] = "vertical-distribution";
    BlueprintIcons_16["VerticalInbetween"] = "vertical-inbetween";
    BlueprintIcons_16["Video"] = "video";
    BlueprintIcons_16["Virus"] = "virus";
    BlueprintIcons_16["VolumeDown"] = "volume-down";
    BlueprintIcons_16["VolumeOff"] = "volume-off";
    BlueprintIcons_16["VolumeUp"] = "volume-up";
    BlueprintIcons_16["Walk"] = "walk";
    BlueprintIcons_16["WarningSign"] = "warning-sign";
    BlueprintIcons_16["WaterfallChart"] = "waterfall-chart";
    BlueprintIcons_16["Waves"] = "waves";
    BlueprintIcons_16["WidgetButton"] = "widget-button";
    BlueprintIcons_16["WidgetFooter"] = "widget-footer";
    BlueprintIcons_16["WidgetHeader"] = "widget-header";
    BlueprintIcons_16["Widget"] = "widget";
    BlueprintIcons_16["Wind"] = "wind";
    BlueprintIcons_16["WrenchRedo"] = "wrench-redo";
    BlueprintIcons_16["WrenchSnooze"] = "wrench-snooze";
    BlueprintIcons_16["WrenchTime"] = "wrench-time";
    BlueprintIcons_16["Wrench"] = "wrench";
    BlueprintIcons_16["ZoomIn"] = "zoom-in";
    BlueprintIcons_16["ZoomOut"] = "zoom-out";
    BlueprintIcons_16["ZoomToFit"] = "zoom-to-fit";
})(BlueprintIcons_16 || (BlueprintIcons_16 = {}));
var BLUEPRINT_ICONS_16_CODEPOINTS = (_a = {},
    _a[BlueprintIcons_16.AddChild] = "62365",
    _a[BlueprintIcons_16.AddClip] = "61697",
    _a[BlueprintIcons_16.AddColumnLeft] = "61698",
    _a[BlueprintIcons_16.AddColumnRight] = "61699",
    _a[BlueprintIcons_16.AddLocation] = "61700",
    _a[BlueprintIcons_16.AddParent] = "62366",
    _a[BlueprintIcons_16.AddRowBottom] = "61701",
    _a[BlueprintIcons_16.AddRowTop] = "61702",
    _a[BlueprintIcons_16.AddToArtifact] = "61703",
    _a[BlueprintIcons_16.AddToFolder] = "61704",
    _a[BlueprintIcons_16.Add] = "61705",
    _a[BlueprintIcons_16.AimpointsTarget] = "62261",
    _a[BlueprintIcons_16.Airplane] = "61706",
    _a[BlueprintIcons_16.AlignCenter] = "61707",
    _a[BlueprintIcons_16.AlignJustify] = "61708",
    _a[BlueprintIcons_16.AlignLeft] = "61709",
    _a[BlueprintIcons_16.AlignRight] = "61710",
    _a[BlueprintIcons_16.AlignmentBottom] = "61711",
    _a[BlueprintIcons_16.AlignmentHorizontalCenter] = "61712",
    _a[BlueprintIcons_16.AlignmentLeft] = "61713",
    _a[BlueprintIcons_16.AlignmentRight] = "61714",
    _a[BlueprintIcons_16.AlignmentTop] = "61715",
    _a[BlueprintIcons_16.AlignmentVerticalCenter] = "61716",
    _a[BlueprintIcons_16.Ammunition] = "62274",
    _a[BlueprintIcons_16.Anchor] = "62256",
    _a[BlueprintIcons_16.Annotation] = "61717",
    _a[BlueprintIcons_16.Announcement] = "62358",
    _a[BlueprintIcons_16.Antenna] = "61718",
    _a[BlueprintIcons_16.AppHeader] = "61719",
    _a[BlueprintIcons_16.Application] = "61720",
    _a[BlueprintIcons_16.Applications] = "61721",
    _a[BlueprintIcons_16.Archive] = "61722",
    _a[BlueprintIcons_16.AreaOfInterest] = "61723",
    _a[BlueprintIcons_16.ArrayBoolean] = "61724",
    _a[BlueprintIcons_16.ArrayDate] = "61725",
    _a[BlueprintIcons_16.ArrayFloatingPoint] = "62253",
    _a[BlueprintIcons_16.ArrayNumeric] = "61726",
    _a[BlueprintIcons_16.ArrayObject] = "62356",
    _a[BlueprintIcons_16.ArrayString] = "61727",
    _a[BlueprintIcons_16.ArrayTimestamp] = "61728",
    _a[BlueprintIcons_16.Array] = "61729",
    _a[BlueprintIcons_16.ArrowBottomLeft] = "61730",
    _a[BlueprintIcons_16.ArrowBottomRight] = "61731",
    _a[BlueprintIcons_16.ArrowDown] = "61732",
    _a[BlueprintIcons_16.ArrowLeft] = "61733",
    _a[BlueprintIcons_16.ArrowRight] = "61734",
    _a[BlueprintIcons_16.ArrowTopLeft] = "61735",
    _a[BlueprintIcons_16.ArrowTopRight] = "61736",
    _a[BlueprintIcons_16.ArrowUp] = "61737",
    _a[BlueprintIcons_16.ArrowsArc] = "62343",
    _a[BlueprintIcons_16.ArrowsHorizontal] = "61738",
    _a[BlueprintIcons_16.ArrowsVertical] = "61739",
    _a[BlueprintIcons_16.Asterisk] = "61740",
    _a[BlueprintIcons_16.At] = "62257",
    _a[BlueprintIcons_16.AutomaticUpdates] = "61741",
    _a[BlueprintIcons_16.Axle] = "62264",
    _a[BlueprintIcons_16.Backlink] = "61742",
    _a[BlueprintIcons_16.BackwardTen] = "62300",
    _a[BlueprintIcons_16.Badge] = "61743",
    _a[BlueprintIcons_16.BanCircle] = "61744",
    _a[BlueprintIcons_16.BankAccount] = "61745",
    _a[BlueprintIcons_16.Barcode] = "61746",
    _a[BlueprintIcons_16.BinaryNumber] = "62295",
    _a[BlueprintIcons_16.Blank] = "61747",
    _a[BlueprintIcons_16.BlockPromote] = "62322",
    _a[BlueprintIcons_16.BlockedPerson] = "61748",
    _a[BlueprintIcons_16.Bold] = "61749",
    _a[BlueprintIcons_16.Book] = "61750",
    _a[BlueprintIcons_16.Bookmark] = "61751",
    _a[BlueprintIcons_16.Box] = "61752",
    _a[BlueprintIcons_16.Briefcase] = "61753",
    _a[BlueprintIcons_16.BringData] = "61754",
    _a[BlueprintIcons_16.BringForward] = "62292",
    _a[BlueprintIcons_16.BritishPound] = "62342",
    _a[BlueprintIcons_16.Bug] = "62254",
    _a[BlueprintIcons_16.Buggy] = "61755",
    _a[BlueprintIcons_16.Build] = "61756",
    _a[BlueprintIcons_16.Bullseye] = "62297",
    _a[BlueprintIcons_16.Calculator] = "61757",
    _a[BlueprintIcons_16.Calendar] = "61758",
    _a[BlueprintIcons_16.Camera] = "61759",
    _a[BlueprintIcons_16.CaretDown] = "61760",
    _a[BlueprintIcons_16.CaretLeft] = "61761",
    _a[BlueprintIcons_16.CaretRight] = "61762",
    _a[BlueprintIcons_16.CaretUp] = "61763",
    _a[BlueprintIcons_16.CargoShip] = "61764",
    _a[BlueprintIcons_16.CellTower] = "61765",
    _a[BlueprintIcons_16.Changes] = "61766",
    _a[BlueprintIcons_16.Chart] = "61767",
    _a[BlueprintIcons_16.Chat] = "61768",
    _a[BlueprintIcons_16.ChevronBackward] = "61769",
    _a[BlueprintIcons_16.ChevronDown] = "61770",
    _a[BlueprintIcons_16.ChevronForward] = "61771",
    _a[BlueprintIcons_16.ChevronLeft] = "61772",
    _a[BlueprintIcons_16.ChevronRight] = "61773",
    _a[BlueprintIcons_16.ChevronUp] = "61774",
    _a[BlueprintIcons_16.CircleArrowDown] = "61775",
    _a[BlueprintIcons_16.CircleArrowLeft] = "61776",
    _a[BlueprintIcons_16.CircleArrowRight] = "61777",
    _a[BlueprintIcons_16.CircleArrowUp] = "61778",
    _a[BlueprintIcons_16.Circle] = "61779",
    _a[BlueprintIcons_16.Citation] = "61780",
    _a[BlueprintIcons_16.Clean] = "61781",
    _a[BlueprintIcons_16.Clip] = "61782",
    _a[BlueprintIcons_16.ClipboardFile] = "62299",
    _a[BlueprintIcons_16.Clipboard] = "61783",
    _a[BlueprintIcons_16.CloudDownload] = "61784",
    _a[BlueprintIcons_16.CloudServer] = "62298",
    _a[BlueprintIcons_16.CloudTick] = "62286",
    _a[BlueprintIcons_16.CloudUpload] = "61785",
    _a[BlueprintIcons_16.Cloud] = "61786",
    _a[BlueprintIcons_16.CodeBlock] = "61787",
    _a[BlueprintIcons_16.Code] = "61788",
    _a[BlueprintIcons_16.Cog] = "61789",
    _a[BlueprintIcons_16.CollapseAll] = "61790",
    _a[BlueprintIcons_16.ColorFill] = "62248",
    _a[BlueprintIcons_16.ColumnLayout] = "61791",
    _a[BlueprintIcons_16.Comment] = "61792",
    _a[BlueprintIcons_16.Comparison] = "61793",
    _a[BlueprintIcons_16.Compass] = "61794",
    _a[BlueprintIcons_16.Compressed] = "61795",
    _a[BlueprintIcons_16.Confirm] = "61796",
    _a[BlueprintIcons_16.Console] = "61797",
    _a[BlueprintIcons_16.Construction] = "62357",
    _a[BlueprintIcons_16.Contrast] = "61798",
    _a[BlueprintIcons_16.Control] = "61799",
    _a[BlueprintIcons_16.CreditCard] = "61800",
    _a[BlueprintIcons_16.Crop] = "62291",
    _a[BlueprintIcons_16.CrossCircle] = "62262",
    _a[BlueprintIcons_16.Cross] = "61801",
    _a[BlueprintIcons_16.Crown] = "61802",
    _a[BlueprintIcons_16.CssStyle] = "62315",
    _a[BlueprintIcons_16.CubeAdd] = "61803",
    _a[BlueprintIcons_16.CubeEdit] = "62339",
    _a[BlueprintIcons_16.CubeRemove] = "61804",
    _a[BlueprintIcons_16.Cube] = "61805",
    _a[BlueprintIcons_16.Cubes] = "62323",
    _a[BlueprintIcons_16.CurlyBraces] = "62296",
    _a[BlueprintIcons_16.CurvedRangeChart] = "61806",
    _a[BlueprintIcons_16.Cut] = "61807",
    _a[BlueprintIcons_16.Cycle] = "61808",
    _a[BlueprintIcons_16.Dashboard] = "61809",
    _a[BlueprintIcons_16.DataCloud] = "62353",
    _a[BlueprintIcons_16.DataConnection] = "61810",
    _a[BlueprintIcons_16.DataLineage] = "61811",
    _a[BlueprintIcons_16.DataSearch] = "62319",
    _a[BlueprintIcons_16.DataSync] = "62316",
    _a[BlueprintIcons_16.Database] = "61812",
    _a[BlueprintIcons_16.DeleteClip] = "62371",
    _a[BlueprintIcons_16.Delete] = "61813",
    _a[BlueprintIcons_16.Delta] = "61814",
    _a[BlueprintIcons_16.DeriveColumn] = "61815",
    _a[BlueprintIcons_16.Desktop] = "61816",
    _a[BlueprintIcons_16.Detection] = "62273",
    _a[BlueprintIcons_16.Diagnosis] = "61817",
    _a[BlueprintIcons_16.DiagramTree] = "61818",
    _a[BlueprintIcons_16.DirectionLeft] = "61819",
    _a[BlueprintIcons_16.DirectionRight] = "61820",
    _a[BlueprintIcons_16.Disable] = "61821",
    _a[BlueprintIcons_16.Divide] = "62247",
    _a[BlueprintIcons_16.DocumentCode] = "62368",
    _a[BlueprintIcons_16.DocumentLocked] = "62369",
    _a[BlueprintIcons_16.DocumentOpen] = "61822",
    _a[BlueprintIcons_16.DocumentShare] = "61823",
    _a[BlueprintIcons_16.Document] = "61824",
    _a[BlueprintIcons_16.Dollar] = "61825",
    _a[BlueprintIcons_16.Dot] = "61826",
    _a[BlueprintIcons_16.DoubleCaretHorizontal] = "61827",
    _a[BlueprintIcons_16.DoubleCaretVertical] = "61828",
    _a[BlueprintIcons_16.DoubleChevronDown] = "61829",
    _a[BlueprintIcons_16.DoubleChevronLeft] = "61830",
    _a[BlueprintIcons_16.DoubleChevronRight] = "61831",
    _a[BlueprintIcons_16.DoubleChevronUp] = "61832",
    _a[BlueprintIcons_16.DoughnutChart] = "61833",
    _a[BlueprintIcons_16.Download] = "61834",
    _a[BlueprintIcons_16.DragHandleHorizontal] = "61835",
    _a[BlueprintIcons_16.DragHandleVertical] = "61836",
    _a[BlueprintIcons_16.Draw] = "61837",
    _a[BlueprintIcons_16.DrawerLeftFilled] = "61838",
    _a[BlueprintIcons_16.DrawerLeft] = "61839",
    _a[BlueprintIcons_16.DrawerRightFilled] = "61840",
    _a[BlueprintIcons_16.DrawerRight] = "61841",
    _a[BlueprintIcons_16.DriveTime] = "61842",
    _a[BlueprintIcons_16.Duplicate] = "61843",
    _a[BlueprintIcons_16.Edit] = "61844",
    _a[BlueprintIcons_16.Eject] = "61845",
    _a[BlueprintIcons_16.Emoji] = "61846",
    _a[BlueprintIcons_16.Endnote] = "62294",
    _a[BlueprintIcons_16.Endorsed] = "61847",
    _a[BlueprintIcons_16.Envelope] = "61848",
    _a[BlueprintIcons_16.Equals] = "61849",
    _a[BlueprintIcons_16.Eraser] = "61850",
    _a[BlueprintIcons_16.Error] = "61851",
    _a[BlueprintIcons_16.Euro] = "61852",
    _a[BlueprintIcons_16.Excavator] = "62317",
    _a[BlueprintIcons_16.Exchange] = "61853",
    _a[BlueprintIcons_16.ExcludeRow] = "61854",
    _a[BlueprintIcons_16.ExpandAll] = "61855",
    _a[BlueprintIcons_16.Explain] = "62285",
    _a[BlueprintIcons_16.Export] = "61856",
    _a[BlueprintIcons_16.EyeOff] = "61857",
    _a[BlueprintIcons_16.EyeOn] = "61858",
    _a[BlueprintIcons_16.EyeOpen] = "61859",
    _a[BlueprintIcons_16.FastBackward] = "61860",
    _a[BlueprintIcons_16.FastForward] = "61861",
    _a[BlueprintIcons_16.FeedSubscribed] = "61862",
    _a[BlueprintIcons_16.Feed] = "61863",
    _a[BlueprintIcons_16.FighterJet] = "62340",
    _a[BlueprintIcons_16.Film] = "61864",
    _a[BlueprintIcons_16.FilterKeep] = "61865",
    _a[BlueprintIcons_16.FilterList] = "61866",
    _a[BlueprintIcons_16.FilterOpen] = "61867",
    _a[BlueprintIcons_16.FilterRemove] = "61868",
    _a[BlueprintIcons_16.FilterSortAsc] = "62350",
    _a[BlueprintIcons_16.FilterSortDesc] = "62351",
    _a[BlueprintIcons_16.Filter] = "61869",
    _a[BlueprintIcons_16.Flag] = "61870",
    _a[BlueprintIcons_16.Flame] = "61871",
    _a[BlueprintIcons_16.Flash] = "61872",
    _a[BlueprintIcons_16.FloatingPoint] = "62252",
    _a[BlueprintIcons_16.FloppyDisk] = "61873",
    _a[BlueprintIcons_16.FlowBranch] = "61874",
    _a[BlueprintIcons_16.FlowEnd] = "61875",
    _a[BlueprintIcons_16.FlowLinear] = "61876",
    _a[BlueprintIcons_16.FlowReviewBranch] = "61877",
    _a[BlueprintIcons_16.FlowReview] = "61878",
    _a[BlueprintIcons_16.Flows] = "61879",
    _a[BlueprintIcons_16.FolderClose] = "61880",
    _a[BlueprintIcons_16.FolderNew] = "61881",
    _a[BlueprintIcons_16.FolderOpen] = "61882",
    _a[BlueprintIcons_16.FolderSharedOpen] = "61883",
    _a[BlueprintIcons_16.FolderShared] = "61884",
    _a[BlueprintIcons_16.Follower] = "61885",
    _a[BlueprintIcons_16.Following] = "61886",
    _a[BlueprintIcons_16.Font] = "61887",
    _a[BlueprintIcons_16.Fork] = "61888",
    _a[BlueprintIcons_16.Form] = "61889",
    _a[BlueprintIcons_16.ForwardTen] = "62301",
    _a[BlueprintIcons_16.Fuel] = "62243",
    _a[BlueprintIcons_16.FullCircle] = "61890",
    _a[BlueprintIcons_16.FullStackedChart] = "61891",
    _a[BlueprintIcons_16.Fullscreen] = "61892",
    _a[BlueprintIcons_16.Function] = "61893",
    _a[BlueprintIcons_16.GanttChart] = "61894",
    _a[BlueprintIcons_16.Generate] = "62284",
    _a[BlueprintIcons_16.Geofence] = "61895",
    _a[BlueprintIcons_16.Geolocation] = "61896",
    _a[BlueprintIcons_16.Geosearch] = "61897",
    _a[BlueprintIcons_16.Geotime] = "62276",
    _a[BlueprintIcons_16.GiftBox] = "62370",
    _a[BlueprintIcons_16.GitBranch] = "61898",
    _a[BlueprintIcons_16.GitCommit] = "61899",
    _a[BlueprintIcons_16.GitMerge] = "61900",
    _a[BlueprintIcons_16.GitNewBranch] = "61901",
    _a[BlueprintIcons_16.GitPull] = "61902",
    _a[BlueprintIcons_16.GitPush] = "61903",
    _a[BlueprintIcons_16.GitRepo] = "61904",
    _a[BlueprintIcons_16.Glass] = "61905",
    _a[BlueprintIcons_16.GlobeNetworkAdd] = "62338",
    _a[BlueprintIcons_16.GlobeNetwork] = "61906",
    _a[BlueprintIcons_16.Globe] = "61907",
    _a[BlueprintIcons_16.GraphRemove] = "61908",
    _a[BlueprintIcons_16.Graph] = "61909",
    _a[BlueprintIcons_16.GreaterThanOrEqualTo] = "61910",
    _a[BlueprintIcons_16.GreaterThan] = "61911",
    _a[BlueprintIcons_16.GridView] = "61912",
    _a[BlueprintIcons_16.Grid] = "61913",
    _a[BlueprintIcons_16.GroupItem] = "62282",
    _a[BlueprintIcons_16.GroupObjects] = "61914",
    _a[BlueprintIcons_16.GroupedBarChart] = "61915",
    _a[BlueprintIcons_16.HandDown] = "61916",
    _a[BlueprintIcons_16.HandLeft] = "61917",
    _a[BlueprintIcons_16.HandRight] = "61918",
    _a[BlueprintIcons_16.HandUp] = "61919",
    _a[BlueprintIcons_16.Hand] = "61920",
    _a[BlueprintIcons_16.Hat] = "61921",
    _a[BlueprintIcons_16.HeaderOne] = "61922",
    _a[BlueprintIcons_16.HeaderThree] = "61923",
    _a[BlueprintIcons_16.HeaderTwo] = "61924",
    _a[BlueprintIcons_16.Header] = "61925",
    _a[BlueprintIcons_16.Headset] = "61926",
    _a[BlueprintIcons_16.HeartBroken] = "61927",
    _a[BlueprintIcons_16.Heart] = "61928",
    _a[BlueprintIcons_16.HeatGrid] = "61929",
    _a[BlueprintIcons_16.Heatmap] = "61930",
    _a[BlueprintIcons_16.Helicopter] = "61931",
    _a[BlueprintIcons_16.Help] = "61932",
    _a[BlueprintIcons_16.HelperManagement] = "61933",
    _a[BlueprintIcons_16.Hexagon] = "62324",
    _a[BlueprintIcons_16.HighPriority] = "61934",
    _a[BlueprintIcons_16.HighVoltagePole] = "62259",
    _a[BlueprintIcons_16.Highlight] = "61935",
    _a[BlueprintIcons_16.History] = "61936",
    _a[BlueprintIcons_16.Home] = "61937",
    _a[BlueprintIcons_16.HorizontalBarChartAsc] = "61938",
    _a[BlueprintIcons_16.HorizontalBarChartDesc] = "61939",
    _a[BlueprintIcons_16.HorizontalBarChart] = "61940",
    _a[BlueprintIcons_16.HorizontalDistribution] = "61941",
    _a[BlueprintIcons_16.HorizontalInbetween] = "62249",
    _a[BlueprintIcons_16.Hurricane] = "61942",
    _a[BlueprintIcons_16.IdNumber] = "61943",
    _a[BlueprintIcons_16.ImageRotateLeft] = "61944",
    _a[BlueprintIcons_16.ImageRotateRight] = "61945",
    _a[BlueprintIcons_16.Import] = "61946",
    _a[BlueprintIcons_16.InboxFiltered] = "61947",
    _a[BlueprintIcons_16.InboxGeo] = "61948",
    _a[BlueprintIcons_16.InboxSearch] = "61949",
    _a[BlueprintIcons_16.InboxUpdate] = "61950",
    _a[BlueprintIcons_16.Inbox] = "61951",
    _a[BlueprintIcons_16.InfoSign] = "61952",
    _a[BlueprintIcons_16.Inheritance] = "61953",
    _a[BlueprintIcons_16.InheritedGroup] = "61954",
    _a[BlueprintIcons_16.InnerJoin] = "61955",
    _a[BlueprintIcons_16.Input] = "62283",
    _a[BlueprintIcons_16.Insert] = "61956",
    _a[BlueprintIcons_16.Intelligence] = "62263",
    _a[BlueprintIcons_16.Intersection] = "61957",
    _a[BlueprintIcons_16.IpAddress] = "61958",
    _a[BlueprintIcons_16.IssueClosed] = "61959",
    _a[BlueprintIcons_16.IssueNew] = "61960",
    _a[BlueprintIcons_16.Issue] = "61961",
    _a[BlueprintIcons_16.Italic] = "61962",
    _a[BlueprintIcons_16.JoinTable] = "61963",
    _a[BlueprintIcons_16.KeyBackspace] = "61964",
    _a[BlueprintIcons_16.KeyCommand] = "61965",
    _a[BlueprintIcons_16.KeyControl] = "61966",
    _a[BlueprintIcons_16.KeyDelete] = "61967",
    _a[BlueprintIcons_16.KeyEnter] = "61968",
    _a[BlueprintIcons_16.KeyEscape] = "61969",
    _a[BlueprintIcons_16.KeyOption] = "61970",
    _a[BlueprintIcons_16.KeyShift] = "61971",
    _a[BlueprintIcons_16.KeyTab] = "61972",
    _a[BlueprintIcons_16.Key] = "61973",
    _a[BlueprintIcons_16.KnownVehicle] = "61974",
    _a[BlueprintIcons_16.LabTest] = "61975",
    _a[BlueprintIcons_16.Label] = "61976",
    _a[BlueprintIcons_16.LayerOutline] = "61977",
    _a[BlueprintIcons_16.Layer] = "61978",
    _a[BlueprintIcons_16.Layers] = "61979",
    _a[BlueprintIcons_16.LayoutAuto] = "61980",
    _a[BlueprintIcons_16.LayoutBalloon] = "61981",
    _a[BlueprintIcons_16.LayoutBottomRowThreeTiles] = "62308",
    _a[BlueprintIcons_16.LayoutBottomRowTwoTiles] = "62307",
    _a[BlueprintIcons_16.LayoutCircle] = "61982",
    _a[BlueprintIcons_16.LayoutGrid] = "61983",
    _a[BlueprintIcons_16.LayoutGroupBy] = "61984",
    _a[BlueprintIcons_16.LayoutHierarchy] = "61985",
    _a[BlueprintIcons_16.LayoutLeftColumnThreeTiles] = "62310",
    _a[BlueprintIcons_16.LayoutLeftColumnTwoTiles] = "62309",
    _a[BlueprintIcons_16.LayoutLinear] = "61986",
    _a[BlueprintIcons_16.LayoutRightColumnThreeTiles] = "62312",
    _a[BlueprintIcons_16.LayoutRightColumnTwoTiles] = "62311",
    _a[BlueprintIcons_16.LayoutSkewGrid] = "61987",
    _a[BlueprintIcons_16.LayoutSortedClusters] = "61988",
    _a[BlueprintIcons_16.LayoutThreeColumns] = "62305",
    _a[BlueprintIcons_16.LayoutThreeRows] = "62306",
    _a[BlueprintIcons_16.LayoutTopRowThreeTiles] = "62314",
    _a[BlueprintIcons_16.LayoutTopRowTwoTiles] = "62313",
    _a[BlueprintIcons_16.LayoutTwoColumns] = "62303",
    _a[BlueprintIcons_16.LayoutTwoRows] = "62304",
    _a[BlueprintIcons_16.Layout] = "61989",
    _a[BlueprintIcons_16.Learning] = "61990",
    _a[BlueprintIcons_16.LeftJoin] = "61991",
    _a[BlueprintIcons_16.LengthenText] = "62270",
    _a[BlueprintIcons_16.LessThanOrEqualTo] = "61992",
    _a[BlueprintIcons_16.LessThan] = "61993",
    _a[BlueprintIcons_16.Lifesaver] = "61994",
    _a[BlueprintIcons_16.Lightbulb] = "61995",
    _a[BlueprintIcons_16.Lightning] = "61996",
    _a[BlueprintIcons_16.Link] = "61997",
    _a[BlueprintIcons_16.LinkedSquares] = "62341",
    _a[BlueprintIcons_16.ListColumns] = "61998",
    _a[BlueprintIcons_16.ListDetailView] = "61999",
    _a[BlueprintIcons_16.List] = "62000",
    _a[BlueprintIcons_16.Locate] = "62001",
    _a[BlueprintIcons_16.Lock] = "62002",
    _a[BlueprintIcons_16.Locomotive] = "62267",
    _a[BlueprintIcons_16.LogIn] = "62003",
    _a[BlueprintIcons_16.LogOut] = "62004",
    _a[BlueprintIcons_16.LowVoltagePole] = "62258",
    _a[BlueprintIcons_16.Manual] = "62005",
    _a[BlueprintIcons_16.ManuallyEnteredData] = "62006",
    _a[BlueprintIcons_16.ManyToMany] = "62007",
    _a[BlueprintIcons_16.ManyToOne] = "62008",
    _a[BlueprintIcons_16.MapCreate] = "62009",
    _a[BlueprintIcons_16.MapMarker] = "62010",
    _a[BlueprintIcons_16.Map] = "62011",
    _a[BlueprintIcons_16.Maximize] = "62012",
    _a[BlueprintIcons_16.Media] = "62013",
    _a[BlueprintIcons_16.MenuClosed] = "62014",
    _a[BlueprintIcons_16.MenuOpen] = "62015",
    _a[BlueprintIcons_16.Menu] = "62016",
    _a[BlueprintIcons_16.MergeColumns] = "62017",
    _a[BlueprintIcons_16.MergeLinks] = "62018",
    _a[BlueprintIcons_16.Microphone] = "62275",
    _a[BlueprintIcons_16.Minimize] = "62019",
    _a[BlueprintIcons_16.Minus] = "62020",
    _a[BlueprintIcons_16.MobilePhone] = "62021",
    _a[BlueprintIcons_16.MobileVideo] = "62022",
    _a[BlueprintIcons_16.ModalFilled] = "62023",
    _a[BlueprintIcons_16.Modal] = "62024",
    _a[BlueprintIcons_16.Model] = "62269",
    _a[BlueprintIcons_16.Moon] = "62025",
    _a[BlueprintIcons_16.More] = "62026",
    _a[BlueprintIcons_16.Mountain] = "62027",
    _a[BlueprintIcons_16.Move] = "62028",
    _a[BlueprintIcons_16.Mugshot] = "62029",
    _a[BlueprintIcons_16.MultiSelect] = "62030",
    _a[BlueprintIcons_16.Music] = "62031",
    _a[BlueprintIcons_16.Nest] = "62032",
    _a[BlueprintIcons_16.NewDrawing] = "62033",
    _a[BlueprintIcons_16.NewGridItem] = "62034",
    _a[BlueprintIcons_16.NewLayer] = "62035",
    _a[BlueprintIcons_16.NewLayers] = "62036",
    _a[BlueprintIcons_16.NewLink] = "62037",
    _a[BlueprintIcons_16.NewObject] = "62038",
    _a[BlueprintIcons_16.NewPerson] = "62039",
    _a[BlueprintIcons_16.NewPrescription] = "62040",
    _a[BlueprintIcons_16.NewShield] = "62281",
    _a[BlueprintIcons_16.NewTextBox] = "62041",
    _a[BlueprintIcons_16.Ninja] = "62042",
    _a[BlueprintIcons_16.NotEqualTo] = "62043",
    _a[BlueprintIcons_16.NotificationsAdd] = "62360",
    _a[BlueprintIcons_16.NotificationsSnooze] = "62044",
    _a[BlueprintIcons_16.NotificationsUpdated] = "62045",
    _a[BlueprintIcons_16.Notifications] = "62046",
    _a[BlueprintIcons_16.NumberedList] = "62047",
    _a[BlueprintIcons_16.Numerical] = "62048",
    _a[BlueprintIcons_16.ObjectView] = "62352",
    _a[BlueprintIcons_16.Office] = "62049",
    _a[BlueprintIcons_16.Offline] = "62050",
    _a[BlueprintIcons_16.OilField] = "62051",
    _a[BlueprintIcons_16.OneColumn] = "62052",
    _a[BlueprintIcons_16.OneToMany] = "62053",
    _a[BlueprintIcons_16.OneToOne] = "62054",
    _a[BlueprintIcons_16.OpenApplication] = "62251",
    _a[BlueprintIcons_16.Outdated] = "62055",
    _a[BlueprintIcons_16.Output] = "62320",
    _a[BlueprintIcons_16.Package] = "62325",
    _a[BlueprintIcons_16.PageBreak] = "62373",
    _a[BlueprintIcons_16.PageLayout] = "62056",
    _a[BlueprintIcons_16.PanelStats] = "62057",
    _a[BlueprintIcons_16.PanelTable] = "62058",
    _a[BlueprintIcons_16.Panel] = "62337",
    _a[BlueprintIcons_16.Paperclip] = "62059",
    _a[BlueprintIcons_16.Paragraph] = "62060",
    _a[BlueprintIcons_16.PasteVariable] = "62278",
    _a[BlueprintIcons_16.PathSearch] = "62061",
    _a[BlueprintIcons_16.Path] = "62062",
    _a[BlueprintIcons_16.Pause] = "62063",
    _a[BlueprintIcons_16.People] = "62064",
    _a[BlueprintIcons_16.Percentage] = "62065",
    _a[BlueprintIcons_16.Person] = "62066",
    _a[BlueprintIcons_16.PhoneCall] = "62279",
    _a[BlueprintIcons_16.PhoneForward] = "62280",
    _a[BlueprintIcons_16.PhoneSearch] = "62359",
    _a[BlueprintIcons_16.Phone] = "62067",
    _a[BlueprintIcons_16.PieChart] = "62068",
    _a[BlueprintIcons_16.Pill] = "62326",
    _a[BlueprintIcons_16.Pin] = "62069",
    _a[BlueprintIcons_16.Pistol] = "62364",
    _a[BlueprintIcons_16.PivotTable] = "62070",
    _a[BlueprintIcons_16.Pivot] = "62071",
    _a[BlueprintIcons_16.Play] = "62072",
    _a[BlueprintIcons_16.Playbook] = "62244",
    _a[BlueprintIcons_16.Plus] = "62073",
    _a[BlueprintIcons_16.PolygonFilter] = "62074",
    _a[BlueprintIcons_16.Power] = "62075",
    _a[BlueprintIcons_16.PredictiveAnalysis] = "62076",
    _a[BlueprintIcons_16.Prescription] = "62077",
    _a[BlueprintIcons_16.Presentation] = "62078",
    _a[BlueprintIcons_16.Print] = "62079",
    _a[BlueprintIcons_16.Projects] = "62080",
    _a[BlueprintIcons_16.Properties] = "62081",
    _a[BlueprintIcons_16.Property] = "62082",
    _a[BlueprintIcons_16.PublishFunction] = "62083",
    _a[BlueprintIcons_16.Pulse] = "62084",
    _a[BlueprintIcons_16.Rain] = "62085",
    _a[BlueprintIcons_16.Random] = "62086",
    _a[BlueprintIcons_16.RangeRing] = "62321",
    _a[BlueprintIcons_16.Record] = "62087",
    _a[BlueprintIcons_16.RectHeight] = "62245",
    _a[BlueprintIcons_16.RectWidth] = "62246",
    _a[BlueprintIcons_16.Rectangle] = "62241",
    _a[BlueprintIcons_16.Redo] = "62088",
    _a[BlueprintIcons_16.Refresh] = "62089",
    _a[BlueprintIcons_16.Regex] = "62255",
    _a[BlueprintIcons_16.RegressionChart] = "62090",
    _a[BlueprintIcons_16.RemoveColumnLeft] = "62091",
    _a[BlueprintIcons_16.RemoveColumnRight] = "62092",
    _a[BlueprintIcons_16.RemoveColumn] = "62093",
    _a[BlueprintIcons_16.RemoveRowBottom] = "62094",
    _a[BlueprintIcons_16.RemoveRowTop] = "62095",
    _a[BlueprintIcons_16.Remove] = "62096",
    _a[BlueprintIcons_16.Repeat] = "62097",
    _a[BlueprintIcons_16.Reset] = "62098",
    _a[BlueprintIcons_16.Resolve] = "62099",
    _a[BlueprintIcons_16.Rig] = "62100",
    _a[BlueprintIcons_16.RightJoin] = "62101",
    _a[BlueprintIcons_16.Ring] = "62102",
    _a[BlueprintIcons_16.RocketSlant] = "62103",
    _a[BlueprintIcons_16.Rocket] = "62104",
    _a[BlueprintIcons_16.RootFolder] = "62367",
    _a[BlueprintIcons_16.RotateCcw] = "62345",
    _a[BlueprintIcons_16.RotateCw] = "62344",
    _a[BlueprintIcons_16.RotateDocument] = "62105",
    _a[BlueprintIcons_16.RotatePage] = "62106",
    _a[BlueprintIcons_16.Route] = "62107",
    _a[BlueprintIcons_16.RunHistory] = "62355",
    _a[BlueprintIcons_16.Satellite] = "62108",
    _a[BlueprintIcons_16.Saved] = "62109",
    _a[BlueprintIcons_16.ScatterPlot] = "62110",
    _a[BlueprintIcons_16.SearchAround] = "62111",
    _a[BlueprintIcons_16.SearchTemplate] = "62112",
    _a[BlueprintIcons_16.SearchText] = "62113",
    _a[BlueprintIcons_16.Search] = "62114",
    _a[BlueprintIcons_16.SegmentedControl] = "62115",
    _a[BlueprintIcons_16.Select] = "62116",
    _a[BlueprintIcons_16.SelectionBoxAdd] = "62362",
    _a[BlueprintIcons_16.SelectionBoxEdit] = "62363",
    _a[BlueprintIcons_16.SelectionBox] = "62361",
    _a[BlueprintIcons_16.Selection] = "62117",
    _a[BlueprintIcons_16.SendBackward] = "62293",
    _a[BlueprintIcons_16.SendMessage] = "62118",
    _a[BlueprintIcons_16.SendToGraph] = "62119",
    _a[BlueprintIcons_16.SendToMap] = "62120",
    _a[BlueprintIcons_16.SendTo] = "62121",
    _a[BlueprintIcons_16.Sensor] = "62268",
    _a[BlueprintIcons_16.SeriesAdd] = "62122",
    _a[BlueprintIcons_16.SeriesConfiguration] = "62123",
    _a[BlueprintIcons_16.SeriesDerived] = "62124",
    _a[BlueprintIcons_16.SeriesFiltered] = "62125",
    _a[BlueprintIcons_16.SeriesSearch] = "62126",
    _a[BlueprintIcons_16.ServerInstall] = "62327",
    _a[BlueprintIcons_16.Server] = "62328",
    _a[BlueprintIcons_16.Settings] = "62127",
    _a[BlueprintIcons_16.Shapes] = "62128",
    _a[BlueprintIcons_16.Share] = "62129",
    _a[BlueprintIcons_16.SharedFilter] = "62130",
    _a[BlueprintIcons_16.Shield] = "62131",
    _a[BlueprintIcons_16.Ship] = "62132",
    _a[BlueprintIcons_16.Shop] = "62133",
    _a[BlueprintIcons_16.ShoppingCart] = "62134",
    _a[BlueprintIcons_16.ShortenText] = "62271",
    _a[BlueprintIcons_16.SignalSearch] = "62135",
    _a[BlueprintIcons_16.SimCard] = "62136",
    _a[BlueprintIcons_16.Slash] = "62137",
    _a[BlueprintIcons_16.SmallCross] = "62138",
    _a[BlueprintIcons_16.SmallInfoSign] = "62260",
    _a[BlueprintIcons_16.SmallMinus] = "62139",
    _a[BlueprintIcons_16.SmallPlus] = "62140",
    _a[BlueprintIcons_16.SmallSquare] = "62141",
    _a[BlueprintIcons_16.SmallTick] = "62142",
    _a[BlueprintIcons_16.Snowflake] = "62143",
    _a[BlueprintIcons_16.SoccerBall] = "62288",
    _a[BlueprintIcons_16.SocialMedia] = "62144",
    _a[BlueprintIcons_16.SortAlphabeticalDesc] = "62145",
    _a[BlueprintIcons_16.SortAlphabetical] = "62146",
    _a[BlueprintIcons_16.SortAsc] = "62147",
    _a[BlueprintIcons_16.SortDesc] = "62148",
    _a[BlueprintIcons_16.SortNumericalDesc] = "62149",
    _a[BlueprintIcons_16.SortNumerical] = "62150",
    _a[BlueprintIcons_16.Sort] = "62151",
    _a[BlueprintIcons_16.SpellCheck] = "62272",
    _a[BlueprintIcons_16.SplitColumns] = "62152",
    _a[BlueprintIcons_16.SportsStadium] = "62289",
    _a[BlueprintIcons_16.Square] = "62153",
    _a[BlueprintIcons_16.StackedChart] = "62154",
    _a[BlueprintIcons_16.StadiumGeometry] = "62155",
    _a[BlueprintIcons_16.StarEmpty] = "62156",
    _a[BlueprintIcons_16.Star] = "62157",
    _a[BlueprintIcons_16.StepBackward] = "62158",
    _a[BlueprintIcons_16.StepChart] = "62159",
    _a[BlueprintIcons_16.StepForward] = "62160",
    _a[BlueprintIcons_16.Stop] = "62161",
    _a[BlueprintIcons_16.Stopwatch] = "62162",
    _a[BlueprintIcons_16.Strikethrough] = "62163",
    _a[BlueprintIcons_16.Style] = "62164",
    _a[BlueprintIcons_16.Subscript] = "62265",
    _a[BlueprintIcons_16.SubtractRightJoin] = "62354",
    _a[BlueprintIcons_16.Superscript] = "62266",
    _a[BlueprintIcons_16.SwapHorizontal] = "62165",
    _a[BlueprintIcons_16.SwapVertical] = "62166",
    _a[BlueprintIcons_16.Sweep] = "62372",
    _a[BlueprintIcons_16.Switch] = "62167",
    _a[BlueprintIcons_16.SymbolCircle] = "62168",
    _a[BlueprintIcons_16.SymbolCross] = "62169",
    _a[BlueprintIcons_16.SymbolDiamond] = "62170",
    _a[BlueprintIcons_16.SymbolRectangle] = "62242",
    _a[BlueprintIcons_16.SymbolSquare] = "62171",
    _a[BlueprintIcons_16.SymbolTriangleDown] = "62172",
    _a[BlueprintIcons_16.SymbolTriangleUp] = "62173",
    _a[BlueprintIcons_16.Syringe] = "62174",
    _a[BlueprintIcons_16.TableSync] = "62318",
    _a[BlueprintIcons_16.TagAdd] = "62329",
    _a[BlueprintIcons_16.TagPromote] = "62330",
    _a[BlueprintIcons_16.TagRefresh] = "62331",
    _a[BlueprintIcons_16.TagUndo] = "62332",
    _a[BlueprintIcons_16.Tag] = "62175",
    _a[BlueprintIcons_16.Tags] = "62333",
    _a[BlueprintIcons_16.TakeAction] = "62176",
    _a[BlueprintIcons_16.Tank] = "62177",
    _a[BlueprintIcons_16.Target] = "62178",
    _a[BlueprintIcons_16.Taxi] = "62179",
    _a[BlueprintIcons_16.Team] = "62290",
    _a[BlueprintIcons_16.Temperature] = "62180",
    _a[BlueprintIcons_16.TextHighlight] = "62181",
    _a[BlueprintIcons_16.ThAdd] = "62346",
    _a[BlueprintIcons_16.ThDerived] = "62182",
    _a[BlueprintIcons_16.ThDisconnect] = "62183",
    _a[BlueprintIcons_16.ThFiltered] = "62184",
    _a[BlueprintIcons_16.ThListAdd] = "62347",
    _a[BlueprintIcons_16.ThList] = "62185",
    _a[BlueprintIcons_16.ThVirtualAdd] = "62349",
    _a[BlueprintIcons_16.ThVirtual] = "62348",
    _a[BlueprintIcons_16.Th] = "62186",
    _a[BlueprintIcons_16.ThirdParty] = "62187",
    _a[BlueprintIcons_16.ThumbsDown] = "62188",
    _a[BlueprintIcons_16.ThumbsUp] = "62189",
    _a[BlueprintIcons_16.TickCircle] = "62190",
    _a[BlueprintIcons_16.Tick] = "62191",
    _a[BlueprintIcons_16.Time] = "62192",
    _a[BlueprintIcons_16.TimelineAreaChart] = "62193",
    _a[BlueprintIcons_16.TimelineBarChart] = "62194",
    _a[BlueprintIcons_16.TimelineEvents] = "62195",
    _a[BlueprintIcons_16.TimelineLineChart] = "62196",
    _a[BlueprintIcons_16.Tint] = "62197",
    _a[BlueprintIcons_16.Torch] = "62198",
    _a[BlueprintIcons_16.Tractor] = "62199",
    _a[BlueprintIcons_16.Train] = "62200",
    _a[BlueprintIcons_16.Translate] = "62201",
    _a[BlueprintIcons_16.Trash] = "62202",
    _a[BlueprintIcons_16.Tree] = "62203",
    _a[BlueprintIcons_16.TrendingDown] = "62204",
    _a[BlueprintIcons_16.TrendingUp] = "62205",
    _a[BlueprintIcons_16.Trophy] = "62287",
    _a[BlueprintIcons_16.Truck] = "62206",
    _a[BlueprintIcons_16.TwoColumns] = "62207",
    _a[BlueprintIcons_16.Unarchive] = "62208",
    _a[BlueprintIcons_16.Underline] = "62209",
    _a[BlueprintIcons_16.Undo] = "62210",
    _a[BlueprintIcons_16.UngroupObjects] = "62211",
    _a[BlueprintIcons_16.UnknownVehicle] = "62212",
    _a[BlueprintIcons_16.Unlink] = "62277",
    _a[BlueprintIcons_16.Unlock] = "62213",
    _a[BlueprintIcons_16.Unpin] = "62214",
    _a[BlueprintIcons_16.Unresolve] = "62215",
    _a[BlueprintIcons_16.Updated] = "62216",
    _a[BlueprintIcons_16.Upload] = "62217",
    _a[BlueprintIcons_16.User] = "62218",
    _a[BlueprintIcons_16.Variable] = "62219",
    _a[BlueprintIcons_16.Vector] = "62302",
    _a[BlueprintIcons_16.VerticalBarChartAsc] = "62220",
    _a[BlueprintIcons_16.VerticalBarChartDesc] = "62221",
    _a[BlueprintIcons_16.VerticalDistribution] = "62222",
    _a[BlueprintIcons_16.VerticalInbetween] = "62250",
    _a[BlueprintIcons_16.Video] = "62223",
    _a[BlueprintIcons_16.Virus] = "62224",
    _a[BlueprintIcons_16.VolumeDown] = "62225",
    _a[BlueprintIcons_16.VolumeOff] = "62226",
    _a[BlueprintIcons_16.VolumeUp] = "62227",
    _a[BlueprintIcons_16.Walk] = "62228",
    _a[BlueprintIcons_16.WarningSign] = "62229",
    _a[BlueprintIcons_16.WaterfallChart] = "62230",
    _a[BlueprintIcons_16.Waves] = "62231",
    _a[BlueprintIcons_16.WidgetButton] = "62232",
    _a[BlueprintIcons_16.WidgetFooter] = "62233",
    _a[BlueprintIcons_16.WidgetHeader] = "62234",
    _a[BlueprintIcons_16.Widget] = "62235",
    _a[BlueprintIcons_16.Wind] = "62236",
    _a[BlueprintIcons_16.WrenchRedo] = "62334",
    _a[BlueprintIcons_16.WrenchSnooze] = "62335",
    _a[BlueprintIcons_16.WrenchTime] = "62336",
    _a[BlueprintIcons_16.Wrench] = "62237",
    _a[BlueprintIcons_16.ZoomIn] = "62238",
    _a[BlueprintIcons_16.ZoomOut] = "62239",
    _a[BlueprintIcons_16.ZoomToFit] = "62240",
    _a);

;// ./node_modules/@blueprintjs/icons/lib/esm/iconNames.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable camelcase */

// The two icon sets are identical aside from SVG paths, so we only need to import info for the 16px set

var IconNamesNew = {};
var IconNamesLegacy = {};
for (var _i = 0, iconNames_a = Object.values(BlueprintIcons_16); _i < iconNames_a.length; _i++) {
    var name_1 = iconNames_a[_i];
    IconNamesNew[(0,dist_es2015/* pascalCase */.fL)(name_1)] = name_1;
    IconNamesLegacy[snakeCase(name_1).toUpperCase()] = name_1;
}
var IconNames = (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, IconNamesNew), IconNamesLegacy);
var IconNamesSet = new Set(Object.values(IconNames));

;// ./node_modules/@blueprintjs/icons/lib/esm/loaderUtils.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Returns whether bundler-injected variable `NODE_ENV` equals `env`. */
function loaderUtils_isNodeEnv(env) {
    return typeof NODE_ENV !== "undefined" && NODE_ENV === env;
}
/**
 * Wraps an async task with a performance timer. Only logs to console in development.
 */
function wrapWithTimer(taskDescription, task) {
    return (0,tslib_es6/* __awaiter */.sH)(this, void 0, void 0, function () {
        var shouldMeasure, start, time;
        return (0,tslib_es6/* __generator */.YH)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    shouldMeasure = loaderUtils_isNodeEnv("development") && typeof performance !== "undefined";
                    if (shouldMeasure) {
                        start = performance.now();
                        console.info("Started '".concat(taskDescription, "'..."));
                    }
                    return [4 /*yield*/, task()];
                case 1:
                    _a.sent();
                    if (shouldMeasure) {
                        time = Math.round(performance.now() - start);
                        console.info("Finished '".concat(taskDescription, "' in ").concat(time, "ms"));
                    }
                    return [2 /*return*/];
            }
        });
    });
}

;// ./node_modules/@blueprintjs/icons/lib/esm/iconLoader.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function getLoaderFn(options) {
    return (0,tslib_es6/* __awaiter */.sH)(this, void 0, void 0, function () {
        var _a, loader;
        return (0,tslib_es6/* __generator */.YH)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = options.loader, loader = _a === void 0 ? singleton.defaultLoader : _a;
                    if (!(typeof loader === "function")) return [3 /*break*/, 1];
                    return [2 /*return*/, loader];
                case 1:
                    if (!(loader === "all")) return [3 /*break*/, 3];
                    return [4 /*yield*/, __webpack_require__.e(/* import() | blueprint-icons-all-paths-loader */ 824).then(__webpack_require__.bind(__webpack_require__, 6740))];
                case 2: return [2 /*return*/, (_b.sent()).allPathsLoader];
                case 3: return [4 /*yield*/, __webpack_require__.e(/* import() | blueprint-icons-split-paths-by-size-loader */ 231).then(__webpack_require__.bind(__webpack_require__, 9745))];
                case 4: return [2 /*return*/, (_b.sent()).splitPathsBySizeLoader];
            }
        });
    });
}
/**
 * Blueprint icons loader.
 */
var Icons = /** @class */ (function () {
    function Icons() {
        /** @internal */
        this.defaultLoader = "split-by-size";
        /** @internal */
        this.loadedIconPaths16 = new Map();
        /** @internal */
        this.loadedIconPaths20 = new Map();
    }
    /**
     * Set global icon loading options for all subsequent `Icons.load()` calls.
     */
    Icons.setLoaderOptions = function (options) {
        if (options.loader !== undefined) {
            singleton.defaultLoader = options.loader;
        }
    };
    Icons.load = function (icons, size, options) {
        return (0,tslib_es6/* __awaiter */.sH)(this, void 0, void 0, function () {
            var _this = this;
            return (0,tslib_es6/* __generator */.YH)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!Array.isArray(icons)) {
                            icons = [icons];
                        }
                        return [4 /*yield*/, Promise.all(icons.map(function (icon) { return _this.loadImpl(icon, size, options); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Load all available icons for use in Blueprint components.
     */
    Icons.loadAll = function (options) {
        return (0,tslib_es6/* __awaiter */.sH)(this, void 0, void 0, function () {
            var allIcons;
            var _this = this;
            return (0,tslib_es6/* __generator */.YH)(this, function (_a) {
                allIcons = Object.values(IconNames);
                wrapWithTimer("[Blueprint] loading all icons", function () { return (0,tslib_es6/* __awaiter */.sH)(_this, void 0, void 0, function () {
                    return (0,tslib_es6/* __generator */.YH)(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, Promise.all([
                                    this.load(allIcons, iconTypes/* IconSize */.l.STANDARD, options),
                                    this.load(allIcons, iconTypes/* IconSize */.l.LARGE, options),
                                ])];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); });
                return [2 /*return*/];
            });
        });
    };
    /**
     * Get the icon SVG paths. Returns `undefined` if the icon has not been loaded yet.
     */
    Icons.getPaths = function (icon, size) {
        if (!this.isValidIconName(icon)) {
            // don't warn, since this.load() will have warned already
            return undefined;
        }
        var loadedIcons = size < iconTypes/* IconSize */.l.LARGE ? singleton.loadedIconPaths16 : singleton.loadedIconPaths20;
        return loadedIcons.get(icon);
    };
    Icons.loadImpl = function (icon, size, options) {
        if (options === void 0) { options = {}; }
        return (0,tslib_es6/* __awaiter */.sH)(this, void 0, void 0, function () {
            var loadedIcons, loaderFn, supportedSize, paths, e_1;
            return (0,tslib_es6/* __generator */.YH)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.isValidIconName(icon)) {
                            console.error("[Blueprint] Unknown icon '".concat(icon, "'"));
                            return [2 /*return*/];
                        }
                        loadedIcons = size < iconTypes/* IconSize */.l.LARGE ? singleton.loadedIconPaths16 : singleton.loadedIconPaths20;
                        if (loadedIcons.has(icon)) {
                            // already loaded, no-op
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, getLoaderFn(options)];
                    case 1:
                        loaderFn = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        supportedSize = size < iconTypes/* IconSize */.l.LARGE ? iconTypes/* IconSize */.l.STANDARD : iconTypes/* IconSize */.l.LARGE;
                        return [4 /*yield*/, loaderFn(icon, supportedSize)];
                    case 3:
                        paths = _a.sent();
                        loadedIcons.set(icon, paths);
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        console.error("[Blueprint] Unable to load ".concat(size, "px icon '").concat(icon, "'"), e_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @returns true if the given string is a valid {@link IconName}
     */
    Icons.isValidIconName = function (iconName) {
        return IconNamesSet.has(iconName);
    };
    return Icons;
}());

var singleton = new Icons();

;// ./node_modules/@blueprintjs/core/lib/esm/components/icon/icon.js
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// re-export for convenience, since some users won't be importing from or have a direct dependency on the icons package

/**
 * Icon component.
 *
 * @see https://blueprintjs.com/docs/#core/components/icon
 */
// eslint-disable-next-line prefer-arrow-callback
var Icon = react.forwardRef(function (props, ref) {
    var _a, _b;
    var _c = props.autoLoad, autoLoad = _c === void 0 ? true : _c, className = props.className, color = props.color, icon = props.icon, intent = props.intent, _d = props.tagName, tagName = _d === void 0 ? "span" : _d, svgProps = props.svgProps, title = props.title, htmlTitle = props.htmlTitle, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["autoLoad", "className", "color", "icon", "intent", "tagName", "svgProps", "title", "htmlTitle"]);
    // Preserve Blueprint v4.x behavior: iconSize prop takes predecence, then size prop, then fall back to default value
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    var size = (_b = (_a = props.iconSize) !== null && _a !== void 0 ? _a : props.size) !== null && _b !== void 0 ? _b : iconTypes/* IconSize */.l.STANDARD;
    var _e = react.useState(function () {
        return typeof icon === "string" ? Icons.getPaths(icon, size) : undefined;
    }), iconPaths = _e[0], setIconPaths = _e[1];
    react.useEffect(function () {
        var shouldCancelIconLoading = false;
        if (typeof icon === "string") {
            // The icon may have been loaded already, in which case we can simply grab it.
            // N.B. when `autoLoad={true}`, we can't rely on simply calling Icons.load() here to re-load an icon module
            // which has already been loaded & cached, since it may have been loaded with special loading options which
            // this component knows nothing about.
            var loadedIconPaths = Icons.getPaths(icon, size);
            if (loadedIconPaths !== undefined) {
                setIconPaths(loadedIconPaths);
            }
            else if (autoLoad) {
                Icons.load(icon, size)
                    .then(function () {
                    // if this effect expired by the time icon loaded, then don't set state
                    if (!shouldCancelIconLoading) {
                        setIconPaths(Icons.getPaths(icon, size));
                    }
                })
                    .catch(function (reason) {
                    console.error("[Blueprint] Icon '".concat(icon, "' (").concat(size, "px) could not be loaded."), reason);
                });
            }
            else {
                console.error("[Blueprint] Icon '".concat(icon, "' (").concat(size, "px) is not loaded yet and autoLoad={false}, did you call Icons.load('").concat(icon, "', ").concat(size, ")?"));
            }
        }
        return function () {
            shouldCancelIconLoading = true;
        };
    }, [autoLoad, icon, size]);
    if (icon == null || typeof icon === "boolean") {
        return null;
    }
    else if (typeof icon !== "string") {
        return icon;
    }
    if (iconPaths == null) {
        // fall back to icon font if unloaded or unable to load SVG implementation
        var sizeClass = size === iconTypes/* IconSize */.l.STANDARD
            ? ICON_STANDARD
            : size === iconTypes/* IconSize */.l.LARGE
                ? ICON_LARGE
                : undefined;
        return react.createElement(tagName || "span", (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ "aria-hidden": title ? undefined : true }, removeNonHTMLProps(htmlProps)), { className: classnames_default()(ICON, sizeClass, iconClass(icon), classes_intentClass(intent), className), "data-icon": icon, ref: ref, title: htmlTitle }));
    }
    else {
        var pathElements = iconPaths.map(function (d, i) { return react.createElement("path", { d: d, key: i, fillRule: "evenodd" }); });
        // HACKHACK: there is no good way to narrow the type of SVGIconContainerProps here because of the use
        // of a conditional type within the type union that defines that interface. So we cast to <any>.
        // see https://github.com/microsoft/TypeScript/issues/24929, https://github.com/microsoft/TypeScript/issues/33014
        return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ children: pathElements, 
            // don't forward `Classes.ICON` or `Classes.iconClass(icon)` here, since the container will render those classes
            className: classnames_default()(classes_intentClass(intent), className), color: color, htmlTitle: htmlTitle, iconName: icon, ref: ref, size: size, svgProps: svgProps, tagName: tagName, title: title }, removeNonHTMLProps(htmlProps))));
    }
});
Icon.displayName = "".concat(DISPLAYNAME_PREFIX, ".Icon");

;// ./node_modules/@blueprintjs/core/lib/esm/hooks/useValidateProps.js
/* !
 * (c) Copyright 2025 Palantir Technologies Inc. All rights reserved.
 */


/**
 * Custom hook for validating component props during development.
 * This hook runs validation checks only in non-production environments,
 * following the same pattern as AbstractComponent.
 *
 * @param validator - Function that performs the validation checks
 * @param dependencies - Optional array of dependencies that trigger validation when changed
 *
 * @example
 * useValidateProps(() => {
 *     if (value < 0) console.warn("Value must be positive");
 * }, [value]);
 */
function useValidateProps(validator, dependencies) {
    if (dependencies === void 0) { dependencies = []; }
    react.useEffect(function () {
        if (!isNodeEnv("production")) {
            validator();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/spinner/spinner.js
/*
 * Copyright 2025 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var SpinnerSize;
(function (SpinnerSize) {
    SpinnerSize[SpinnerSize["SMALL"] = 20] = "SMALL";
    SpinnerSize[SpinnerSize["STANDARD"] = 50] = "STANDARD";
    SpinnerSize[SpinnerSize["LARGE"] = 100] = "LARGE";
})(SpinnerSize || (SpinnerSize = {}));
// see http://stackoverflow.com/a/18473154/3124288 for calculating arc path
var R = 45;
var spinner_SPINNER_TRACK = "M 50,50 m 0,-".concat(R, " a ").concat(R, ",").concat(R, " 0 1 1 0,").concat(R * 2, " a ").concat(R, ",").concat(R, " 0 1 1 0,-").concat(R * 2);
// unitless total length of SVG path, to which stroke-dash* properties are relative.
// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pathLength
// this value is the result of `<path d={SPINNER_TRACK} />.getTotalLength()` and works in all browsers:
var PATH_LENGTH = 280;
var MIN_SIZE = 10;
var STROKE_WIDTH = 4;
var MIN_STROKE_WIDTH = 16;
/**
 * Spinner component.
 *
 * @see https://blueprintjs.com/docs/#core/components/spinner
 */
var Spinner = function (props) {
    var _a;
    var _b = props.className, className = _b === void 0 ? "" : _b, intent = props.intent, value = props.value, _c = props.tagName, tagName = _c === void 0 ? "div" : _c, size = props.size, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["className", "intent", "value", "tagName", "size"]);
    useValidateProps(function () {
        var isSizePropSet = size != null;
        var isSizeClassSet = className.indexOf(SMALL) >= 0 || className.indexOf(LARGE) >= 0;
        if (isSizePropSet && isSizeClassSet) {
            console.warn(SPINNER_WARN_CLASSES_SIZE);
        }
    }, [className, size]);
    var sizePx = getSize(size, className);
    // keep spinner track width consistent at all sizes (down to about 10px).
    var strokeWidth = Math.min(MIN_STROKE_WIDTH, (STROKE_WIDTH * SpinnerSize.LARGE) / sizePx);
    var strokeOffset = PATH_LENGTH - PATH_LENGTH * (value == null ? 0.25 : clamp(value, 0, 1));
    var classes = classnames_default()(SPINNER, classes_intentClass(intent), (_a = {}, _a[SPINNER_NO_SPIN] = value != null, _a), className);
    // multiple DOM elements around SVG are necessary to properly isolate animation:
    // - SVG elements in IE do not support anim/trans so they must be set on a parent HTML element.
    // - SPINNER_ANIMATION isolates svg from parent display and is always centered inside root element.
    return react.createElement(tagName, (0,tslib_es6/* __assign */.Cl)({ "aria-label": "loading", "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": value === undefined ? undefined : value * 100, className: classes, role: "progressbar" }, htmlProps), react.createElement(tagName, { className: SPINNER_ANIMATION }, react.createElement("svg", { width: sizePx, height: sizePx, strokeWidth: strokeWidth.toFixed(2), viewBox: getViewBox(strokeWidth) },
        react.createElement("path", { className: SPINNER_TRACK, d: spinner_SPINNER_TRACK }),
        react.createElement("path", { className: SPINNER_HEAD, d: spinner_SPINNER_TRACK, pathLength: PATH_LENGTH, strokeDasharray: "".concat(PATH_LENGTH, " ").concat(PATH_LENGTH), strokeDashoffset: strokeOffset }))));
};
Spinner.displayName = "".concat(DISPLAYNAME_PREFIX, ".Spinner");
/**
 * Resolve size to a pixel value.
 * Size can be set by className, props, default, or minimum constant.
 */
var getSize = function (size, className) {
    if (size == null) {
        if (className.indexOf(SMALL) >= 0) {
            return SpinnerSize.SMALL;
        }
        else if (className.indexOf(LARGE) >= 0) {
            return SpinnerSize.LARGE;
        }
        return SpinnerSize.STANDARD;
    }
    return Math.max(MIN_SIZE, size);
};
/** Compute viewbox such that stroked track sits exactly at edge of image frame. */
var getViewBox = function (strokeWidth) {
    var radius = R + strokeWidth / 2;
    var viewBoxX = (50 - radius).toFixed(2);
    var viewBoxWidth = (radius * 2).toFixed(2);
    return "".concat(viewBoxX, " ").concat(viewBoxX, " ").concat(viewBoxWidth, " ").concat(viewBoxWidth);
};

;// ./node_modules/@blueprintjs/core/lib/esm/hooks/useIsomorphicLayoutEffect.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @returns the appropriate React layout effect hook for the current environment (server or client).
 */
var useIsomorphicLayoutEffect = hasDOMEnvironment() ? react.useLayoutEffect : react.useEffect;

;// ./node_modules/@blueprintjs/core/lib/esm/components/text/text.js
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Text component.
 *
 * @see https://blueprintjs.com/docs/#core/components/text
 */
var Text = react.forwardRef(function (_a, forwardedRef) {
    var _b;
    var children = _a.children, _c = _a.tagName, tagName = _c === void 0 ? "div" : _c, title = _a.title, className = _a.className, _d = _a.ellipsize, ellipsize = _d === void 0 ? false : _d, htmlProps = (0,tslib_es6/* __rest */.Tt)(_a, ["children", "tagName", "title", "className", "ellipsize"]);
    var contentMeasuringRef = react.useRef();
    var textRef = react.useMemo(function () { return mergeRefs(contentMeasuringRef, forwardedRef); }, [forwardedRef]);
    var _e = react.useState(""), textContent = _e[0], setTextContent = _e[1];
    var _f = react.useState(), isContentOverflowing = _f[0], setIsContentOverflowing = _f[1];
    // try to be conservative about running this effect, since querying scrollWidth causes the browser to reflow / recalculate styles,
    // which can be very expensive for long lists (for example, in long Menus)
    useIsomorphicLayoutEffect(function () {
        var _a;
        if (((_a = contentMeasuringRef.current) === null || _a === void 0 ? void 0 : _a.textContent) != null) {
            setIsContentOverflowing(ellipsize && contentMeasuringRef.current.scrollWidth > contentMeasuringRef.current.clientWidth);
            setTextContent(contentMeasuringRef.current.textContent);
        }
    }, [contentMeasuringRef, children, ellipsize]);
    return react.createElement(tagName, (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, htmlProps), { className: classnames_default()((_b = {},
            _b[TEXT_OVERFLOW_ELLIPSIS] = ellipsize,
            _b), className), ref: textRef, title: title !== null && title !== void 0 ? title : (isContentOverflowing ? textContent : undefined) }), children);
});
Text.displayName = "".concat(DISPLAYNAME_PREFIX, ".Text");

;// ./node_modules/@blueprintjs/core/lib/esm/components/button/buttons.js
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Button component.
 *
 * @see https://blueprintjs.com/docs/#core/components/button
 */
var Button = react.forwardRef(function (props, ref) {
    var commonAttributes = useSharedButtonAttributes(props, ref);
    return (react.createElement("button", (0,tslib_es6/* __assign */.Cl)({ type: "button" }, removeNonHTMLProps(props), commonAttributes), renderButtonContents(props)));
});
Button.displayName = "".concat(DISPLAYNAME_PREFIX, ".Button");
/**
 * AnchorButton component.
 *
 * @see https://blueprintjs.com/docs/#core/components/button
 */
var AnchorButton = react.forwardRef(function (props, ref) {
    var href = props.href;
    var commonProps = useSharedButtonAttributes(props, ref, {
        defaultTabIndex: 0,
        disabledTabIndex: -1,
    });
    return (react.createElement("a", (0,tslib_es6/* __assign */.Cl)({ role: "button" }, removeNonHTMLProps(props), commonProps, { "aria-disabled": commonProps.disabled, href: commonProps.disabled ? undefined : href }), renderButtonContents(props)));
});
AnchorButton.displayName = "".concat(DISPLAYNAME_PREFIX, ".AnchorButton");
/**
 * Most of the button logic lives in this shared hook.
 */
function useSharedButtonAttributes(props, ref, options) {
    var _a;
    var alignText = props.alignText, fill = props.fill, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    large = props.large, _b = props.loading, loading = _b === void 0 ? false : _b, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    minimal = props.minimal, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    outlined = props.outlined, _c = props.size, size = _c === void 0 ? "medium" : _c, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    small = props.small, _d = props.variant, variant = _d === void 0 ? "solid" : _d;
    var disabled = props.disabled || loading;
    var _e = useInteractiveAttributes(!disabled, props, ref, options), active = _e[0], interactiveProps = _e[1];
    var className = classnames_default()(BUTTON, (_a = {},
        _a[ACTIVE] = active,
        _a[DISABLED] = disabled,
        _a[FILL] = fill,
        _a[LOADING] = loading,
        _a), alignmentClass(alignText), classes_intentClass(props.intent), sizeClass(size, { large: large, small: small }), variantClass(variant, { minimal: minimal, outlined: outlined }), props.className);
    return (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, interactiveProps), { className: className, disabled: disabled });
}
/**
 * Shared rendering code for button contents.
 */
function renderButtonContents(props) {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    var children = props.children, ellipsizeText = props.ellipsizeText, endIcon = props.endIcon, icon = props.icon, loading = props.loading, rightIcon = props.rightIcon, text = props.text, textClassName = props.textClassName;
    var hasTextContent = !isReactNodeEmpty(text) || !isReactNodeEmpty(children);
    return (react.createElement(react.Fragment, null,
        loading && react.createElement(Spinner, { className: BUTTON_SPINNER, size: SpinnerSize.SMALL }),
        react.createElement(Icon, { icon: icon }),
        hasTextContent && (react.createElement(Text, { className: classnames_default()(BUTTON_TEXT, textClassName), ellipsize: ellipsizeText, tagName: "span" },
            text,
            children)),
        react.createElement(Icon, { icon: endIcon !== null && endIcon !== void 0 ? endIcon : rightIcon })));
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/toast/toast.js
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to Toast2 instead.
 */








/**
 * Toast component.
 *
 * @deprecated use `Toast2` instead, which forwards DOM refs and is thus compatible with `Overlay2`.
 * @see https://blueprintjs.com/docs/#core/components/toast
 */
var Toast = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(Toast, _super);
    function Toast() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleActionClick = function (e) {
            var _a, _b;
            (_b = (_a = _this.props.action) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            _this.triggerDismiss(false);
        };
        _this.handleCloseClick = function () { return _this.triggerDismiss(false); };
        _this.startTimeout = function () {
            _this.clearTimeouts();
            if (_this.props.timeout > 0) {
                _this.setTimeout(function () { return _this.triggerDismiss(true); }, _this.props.timeout);
            }
        };
        return _this;
    }
    Toast.prototype.render = function () {
        var _a = this.props, className = _a.className, icon = _a.icon, intent = _a.intent, message = _a.message, isCloseButtonShown = _a.isCloseButtonShown;
        return (react.createElement("div", { className: classnames_default()(TOAST, classes_intentClass(intent), className), onBlur: this.startTimeout, onFocus: this.clearTimeouts, onMouseEnter: this.clearTimeouts, onMouseLeave: this.startTimeout, tabIndex: 0 },
            react.createElement(Icon, { icon: icon }),
            react.createElement("span", { className: TOAST_MESSAGE, role: "alert" }, message),
            react.createElement(ButtonGroup, { variant: "minimal" },
                this.maybeRenderActionButton(),
                isCloseButtonShown && (react.createElement(Button, { "aria-label": "Close", icon: react.createElement(Cross, null), onClick: this.handleCloseClick })))));
    };
    Toast.prototype.componentDidMount = function () {
        this.startTimeout();
    };
    Toast.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.timeout !== this.props.timeout) {
            if (this.props.timeout > 0) {
                this.startTimeout();
            }
            else {
                this.clearTimeouts();
            }
        }
    };
    Toast.prototype.componentWillUnmount = function () {
        this.clearTimeouts();
    };
    Toast.prototype.maybeRenderActionButton = function () {
        var action = this.props.action;
        if (action == null) {
            return undefined;
        }
        else {
            return react.createElement(AnchorButton, (0,tslib_es6/* __assign */.Cl)({}, action, { intent: undefined, onClick: this.handleActionClick }));
        }
    };
    Toast.prototype.triggerDismiss = function (didTimeoutExpire) {
        var _a, _b;
        this.clearTimeouts();
        (_b = (_a = this.props).onDismiss) === null || _b === void 0 ? void 0 : _b.call(_a, didTimeoutExpire);
    };
    Toast.defaultProps = {
        className: "",
        isCloseButtonShown: true,
        message: "",
        timeout: 5000,
    };
    Toast.displayName = "".concat(DISPLAYNAME_PREFIX, ".Toast");
    return Toast;
}(AbstractPureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/hooks/useTimeout.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * React hook wrapper for setTimeout(), adapted from usehooks-ts.
 * The provided callback is invoked after the specified delay in milliseconds.
 * If the delay is null or the component is unmounted, any pending timeout is cleared.
 *
 * @see https://usehooks-ts.com/react-hook/use-timeout
 */
function useTimeout(callback, delay) {
    var savedCallback = react.useRef(callback);
    // remember the latest callback if it changes
    useIsomorphicLayoutEffect(function () {
        savedCallback.current = callback;
    }, [callback]);
    // set up the timeout
    react.useEffect(function () {
        // Don't schedule if no delay is specified.
        // Note: 0 is a valid value for delay.
        if (!delay && delay !== 0) {
            return;
        }
        var id = setTimeout(function () { return savedCallback.current(); }, delay);
        return function () { return clearTimeout(id); };
    }, [delay]);
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/toast/toast2.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * Toast2 component.
 *
 * Compared to the deprecated `Toast` component, this is a function component which forwards DOM
 * refs and is thus compatible with `Overlay2`.
 *
 * @see https://blueprintjs.com/docs/#core/components/toast2
 */
var Toast2 = react.forwardRef(function (props, ref) {
    var action = props.action, className = props.className, icon = props.icon, intent = props.intent, _a = props.isCloseButtonShown, isCloseButtonShown = _a === void 0 ? true : _a, message = props.message, onDismiss = props.onDismiss, _b = props.timeout, timeout = _b === void 0 ? 5000 : _b;
    var _c = react.useState(false), isTimeoutStarted = _c[0], setIsTimeoutStarted = _c[1];
    var startTimeout = react.useCallback(function () { return setIsTimeoutStarted(true); }, []);
    var clearTimeout = react.useCallback(function () { return setIsTimeoutStarted(false); }, []);
    // Per docs: "Providing a value less than or equal to 0 will disable the timeout (this is discouraged)."
    var isTimeoutEnabled = timeout != null && timeout > 0;
    // timeout is triggered & cancelled by updating `isTimeoutStarted` state
    useTimeout(function () {
        triggerDismiss(true);
    }, isTimeoutStarted && isTimeoutEnabled ? timeout : null);
    // start timeout on mount or change, cancel on unmount
    react.useEffect(function () {
        if (isTimeoutEnabled) {
            startTimeout();
        }
        else {
            clearTimeout();
        }
        return clearTimeout;
    }, [clearTimeout, startTimeout, isTimeoutEnabled, timeout]);
    var triggerDismiss = react.useCallback(function (didTimeoutExpire) {
        clearTimeout();
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(didTimeoutExpire);
    }, [clearTimeout, onDismiss]);
    var handleCloseClick = react.useCallback(function () { return triggerDismiss(false); }, [triggerDismiss]);
    var handleActionClick = react.useCallback(function (e) {
        var _a;
        (_a = action === null || action === void 0 ? void 0 : action.onClick) === null || _a === void 0 ? void 0 : _a.call(action, e);
        triggerDismiss(false);
    }, [action, triggerDismiss]);
    return (react.createElement("div", { className: classnames_default()(TOAST, classes_intentClass(intent), className), 
        // Pause timeouts if users are hovering over or click on the toast. The toast may have
        // actions the user wants to click. It'd be a poor experience to "pull the toast" out
        // from under them.
        onBlur: startTimeout, onFocus: clearTimeout, onMouseEnter: clearTimeout, onMouseLeave: startTimeout, ref: ref, tabIndex: 0 },
        react.createElement(Icon, { icon: icon }),
        react.createElement("span", { className: TOAST_MESSAGE, role: "alert" }, message),
        react.createElement(ButtonGroup, { variant: "minimal" },
            action && react.createElement(AnchorButton, (0,tslib_es6/* __assign */.Cl)({}, action, { intent: undefined, onClick: handleActionClick })),
            isCloseButtonShown && react.createElement(Button, { "aria-label": "Close", icon: react.createElement(Cross, null), onClick: handleCloseClick }))));
});
Toast2.displayName = "".concat(DISPLAYNAME_PREFIX, ".Toast2");

;// ./node_modules/@blueprintjs/core/lib/esm/components/toast/overlayToaster.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var OVERLAY_TOASTER_DELAY_MS = 50;
/**
 * OverlayToaster component.
 *
 * @see https://blueprintjs.com/docs/#core/components/toast
 */
var OverlayToaster = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(OverlayToaster, _super);
    function OverlayToaster() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            toastRefs: {},
            toasts: [],
        };
        // Queue of toasts to be displayed. If toasts are shown too quickly back to back, it can result in cut off toasts.
        // The queue ensures that toasts are only displayed in QUEUE_TIMEOUT_MS increments.
        _this.queue = {
            cancel: undefined,
            isRunning: false,
            toasts: [],
        };
        // auto-incrementing identifier for un-keyed toasts
        _this.toastId = 0;
        _this.toastRefs = {};
        /** Compute a new collection of toast refs (usually after updating toasts) */
        _this.getToastRefs = function (toasts) {
            return toasts.reduce(function (refs, toast) {
                refs[toast.key] = react.createRef();
                return refs;
            }, {});
        };
        _this.handleQueueTimeout = function () {
            var nextToast = _this.queue.toasts.shift();
            if (nextToast != null) {
                _this.immediatelyShowToast(nextToast);
                _this.startQueueTimeout();
            }
            else {
                _this.queue.isRunning = false;
            }
        };
        _this.renderToast = function (toast) {
            return react.createElement(Toast2, (0,tslib_es6/* __assign */.Cl)({}, toast, { onDismiss: _this.getDismissHandler(toast) }));
        };
        _this.getDismissHandler = function (toast) { return function (timeoutExpired) {
            _this.dismiss(toast.key, timeoutExpired);
        }; };
        _this.handleClose = function (e) {
            // NOTE that `e` isn't always a KeyboardEvent but that's the only type we care about
            if (e.key === "Escape") {
                _this.clear();
            }
        };
        return _this;
    }
    /**
     * Create a new `Toaster` instance that can be shared around your application.
     * The `Toaster` will be rendered into a new element appended to the given container.
     */
    OverlayToaster.create = function (props, container) {
        if (container === void 0) { container = document.body; }
        if (props != null && props.usePortal != null && !isNodeEnv("production")) {
            console.warn(TOASTER_WARN_INLINE);
        }
        var containerElement = document.createElement("div");
        container.appendChild(containerElement);
        // TODO(React 18): Replace deprecated ReactDOM methods. See: https://github.com/palantir/blueprint/issues/7166
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        var toaster = react_dom.render(react.createElement(OverlayToaster, (0,tslib_es6/* __assign */.Cl)({}, props, { usePortal: false })), containerElement);
        if (toaster == null) {
            throw new Error(TOASTER_CREATE_NULL);
        }
        return toaster;
    };
    /**
     * Similar to {@link OverlayToaster.create}, but returns a Promise to a
     * Toaster instance after it's rendered and mounted to the DOM.
     *
     * This API will replace the synchronous {@link OverlayToaster.create} in a
     * future major version of Blueprint to reflect React 18+'s new asynchronous
     * rendering API.
     */
    OverlayToaster.createAsync = function (props, options) {
        var _a, _b;
        if (props != null && props.usePortal != null && !isNodeEnv("production")) {
            console.warn(TOASTER_WARN_INLINE);
        }
        var container = (_a = options === null || options === void 0 ? void 0 : options.container) !== null && _a !== void 0 ? _a : document.body;
        // TODO(React 18): Replace deprecated ReactDOM methods. See: https://github.com/palantir/blueprint/issues/7166
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        var domRenderer = (_b = options === null || options === void 0 ? void 0 : options.domRenderer) !== null && _b !== void 0 ? _b : react_dom.render;
        var toasterComponentRoot = document.createElement("div");
        container.appendChild(toasterComponentRoot);
        return new Promise(function (resolve, reject) {
            try {
                // TODO(React 18): Replace deprecated ReactDOM methods. See: https://github.com/palantir/blueprint/issues/7166
                // eslint-disable-next-line @typescript-eslint/no-deprecated
                domRenderer(react.createElement(OverlayToaster, (0,tslib_es6/* __assign */.Cl)({}, props, { ref: handleRef, usePortal: false })), toasterComponentRoot);
            }
            catch (error) {
                // Note that we're catching errors from the domRenderer function
                // call, but not errors when rendering <OverlayToaster>, which
                // happens in a separate scheduled tick. Wrapping the
                // OverlayToaster in an error boundary would be necessary to
                // capture rendering errors, but that's still a bit unreliable
                // and would only catch errors rendering the initial mount.
                reject(error);
            }
            // We can get a rough guarantee that the OverlayToaster has been
            // mounted to the DOM by waiting until the ref callback here has
            // been fired.
            //
            // This is the approach suggested under "What about the render
            // callback?" at https://github.com/reactwg/react-18/discussions/5.
            function handleRef(ref) {
                if (ref == null) {
                    reject(new Error(TOASTER_CREATE_ASYNC_NULL));
                    return;
                }
                resolve(ref);
            }
        });
    };
    OverlayToaster.prototype.show = function (props, key) {
        var options = this.createToastOptions(props, key);
        var wasExistingToastUpdated = this.maybeUpdateExistingToast(options, key);
        if (wasExistingToastUpdated) {
            return options.key;
        }
        if (this.queue.isRunning) {
            // If a toast has been shown recently, push to the queued toasts to prevent toasts from being shown too
            // quickly for the animations to keep up
            this.queue.toasts.push(options);
        }
        else {
            // If we have not recently shown a toast, we can immediately show the given toast
            this.immediatelyShowToast(options);
            this.startQueueTimeout();
        }
        return options.key;
    };
    OverlayToaster.prototype.maybeUpdateExistingToast = function (options, key) {
        if (key == null) {
            return false;
        }
        var isExistingQueuedToast = this.queue.toasts.some(function (toast) { return toast.key === key; });
        if (isExistingQueuedToast) {
            this.queue.toasts = this.queue.toasts.map(function (t) { return (t.key === key ? options : t); });
            return true;
        }
        var isExistingShownToast = this.state.toasts.some(function (toast) { return toast.key === key; });
        if (isExistingShownToast) {
            this.updateToastsInState(function (toasts) { return toasts.map(function (t) { return (t.key === key ? options : t); }); });
            return true;
        }
        return false;
    };
    OverlayToaster.prototype.immediatelyShowToast = function (options) {
        if (this.props.maxToasts) {
            // check if active number of toasts are at the maxToasts limit
            this.dismissIfAtLimit();
        }
        this.updateToastsInState(function (toasts) { return (0,tslib_es6/* __spreadArray */.fX)([options], toasts, true); });
    };
    OverlayToaster.prototype.startQueueTimeout = function () {
        this.queue.isRunning = true;
        this.queue.cancel = this.setTimeout(this.handleQueueTimeout, OVERLAY_TOASTER_DELAY_MS);
    };
    OverlayToaster.prototype.updateToastsInState = function (getNewToasts) {
        var _this = this;
        this.setState(function (prevState) {
            var toasts = getNewToasts(prevState.toasts);
            return { toastRefs: _this.getToastRefs(toasts), toasts: toasts };
        });
    };
    OverlayToaster.prototype.dismiss = function (key, timeoutExpired) {
        var _this = this;
        if (timeoutExpired === void 0) { timeoutExpired = false; }
        this.setState(function (prevState) {
            var toasts = prevState.toasts.filter(function (t) {
                var _a;
                var matchesKey = t.key === key;
                if (matchesKey) {
                    (_a = t.onDismiss) === null || _a === void 0 ? void 0 : _a.call(t, timeoutExpired);
                }
                return !matchesKey;
            });
            return { toastRefs: _this.getToastRefs(toasts), toasts: toasts };
        });
    };
    OverlayToaster.prototype.clear = function () {
        var _a, _b;
        (_b = (_a = this.queue).cancel) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.queue = { cancel: undefined, isRunning: false, toasts: [] };
        this.state.toasts.forEach(function (t) { var _a; return (_a = t.onDismiss) === null || _a === void 0 ? void 0 : _a.call(t, false); });
        this.setState({ toastRefs: {}, toasts: [] });
    };
    OverlayToaster.prototype.getToasts = function () {
        return this.state.toasts;
    };
    OverlayToaster.prototype.render = function () {
        var classes = classnames_default()(TOAST_CONTAINER, this.getPositionClasses(), this.props.className);
        return (react.createElement(Overlay2, { autoFocus: this.props.autoFocus, canEscapeKeyClose: this.props.canEscapeKeyClear, canOutsideClickClose: false, className: classes, childRefs: this.toastRefs, enforceFocus: false, hasBackdrop: false, isOpen: this.state.toasts.length > 0 || this.props.children != null, onClose: this.handleClose, shouldReturnFocusOnClose: false, 
            // $pt-transition-duration * 3 + $pt-transition-duration / 2
            transitionDuration: 350, transitionName: TOAST, usePortal: this.props.usePortal },
            this.state.toasts.map(this.renderToast, this),
            this.renderChildren()));
    };
    OverlayToaster.prototype.validateProps = function (_a) {
        var maxToasts = _a.maxToasts;
        // maximum number of toasts should not be a number less than 1
        if (maxToasts !== undefined && maxToasts < 1) {
            throw new Error(TOASTER_MAX_TOASTS_INVALID);
        }
    };
    /**
     * If provided `Toast` children, automaticaly upgrade them to `Toast2` elements so that `Overlay2` can inject
     * refs into them for use by `CSSTransition`. This is a bit hacky but ensures backwards compatibility for
     * `OverlayToaster`. It should be an uncommon code path in most applications, since we expect most usage to
     * occur via the imperative toaster APIs.
     *
     * We can remove this indirection once `Toast2` fully replaces `Toast` in a future major version.
     *
     * TODO(@adidahiya): Blueprint v6.0
     */
    OverlayToaster.prototype.renderChildren = function () {
        return react.Children.map(this.props.children, function (child) {
            // TODO(React 18): Replace deprecated ReactDOM methods. See: https://github.com/palantir/blueprint/issues/7166
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            if (isElementOfType(child, Toast)) {
                return react.createElement(Toast2, (0,tslib_es6/* __assign */.Cl)({}, child.props));
            }
            else {
                return child;
            }
        });
    };
    OverlayToaster.prototype.dismissIfAtLimit = function () {
        if (this.state.toasts.length === this.props.maxToasts) {
            // dismiss the oldest toast to stay within the maxToasts limit
            this.dismiss(this.state.toasts[this.state.toasts.length - 1].key);
        }
    };
    OverlayToaster.prototype.createToastOptions = function (props, key) {
        if (key === void 0) { key = "toast-".concat(this.toastId++); }
        // clone the object before adding the key prop to avoid leaking the mutation
        return (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, props), { key: key });
    };
    OverlayToaster.prototype.getPositionClasses = function () {
        var positions = this.props.position.split("-");
        // NOTE that there is no -center class because that's the default style
        return (0,tslib_es6/* __spreadArray */.fX)((0,tslib_es6/* __spreadArray */.fX)([], positions.map(function (p) { return "".concat(TOAST_CONTAINER, "-").concat(p.toLowerCase()); }), true), [
            "".concat(TOAST_CONTAINER, "-").concat(this.props.usePortal ? "in-portal" : "inline"),
        ], false);
    };
    OverlayToaster.displayName = "".concat(DISPLAYNAME_PREFIX, ".OverlayToaster");
    OverlayToaster.defaultProps = {
        autoFocus: false,
        canEscapeKeyClear: true,
        position: Position.TOP,
        usePortal: true,
    };
    return OverlayToaster;
}(AbstractPureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/components/toast/toaster.js
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// merges with declaration of `Toaster` type in `toasterTypes.ts`
// kept for backwards-compatibility with v4.x
var Toaster = {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    create: deprecatedToasterCreate,
};
/** @deprecated use OverlayToaster.create() instead */
function deprecatedToasterCreate(props, container) {
    if (container === void 0) { container = document.body; }
    return OverlayToaster.create(props, container);
}

;// ./app/Alert.js

const maxToasts = 3;
let toaster;
let toaster2;
let callbacks = new Set();
let observer = new MutationObserver(() => {
    let len = 0;
    if (toaster2) {
        let toasts = toaster2.getToasts();
        if (toasts) {
            len = toasts.length;
        }
    }
    callbacks.forEach((callback) => {
        callback(len);
    });
});
function clean() {
    let toasts = toaster.getToasts();
    if (toasts.length > maxToasts - 1) {
        toaster.dismiss(toasts[toasts.length - 1].key);
        clean();
    }
}
function clean2() {
    let toasts = toaster2.getToasts();
    if (toasts.length > maxToasts - 1) {
        toaster2.dismiss(toasts[toasts.length - 1].key);
        clean2();
    }
}
function success(message, timeout) {
    if (timeout === undefined) {
        timeout = 5000;
    }
    else {
        timeout = timeout * 1000;
    }
    clean();
    return toaster.show({
        intent: Intent.SUCCESS,
        message: message,
        timeout: timeout,
    });
}
function info(message, timeout) {
    if (timeout === undefined) {
        timeout = 5000;
    }
    else {
        timeout = timeout * 1000;
    }
    clean();
    return toaster.show({
        intent: Intent.PRIMARY,
        message: message,
        timeout: timeout,
    });
}
function warning(message, timeout) {
    if (timeout === undefined) {
        timeout = 5000;
    }
    else {
        timeout = timeout * 1000;
    }
    clean();
    return toaster.show({
        intent: Blueprint.Intent.WARNING,
        message: message,
        timeout: timeout,
    });
}
function error(message, timeout) {
    if (timeout === undefined) {
        timeout = 10000;
    }
    else {
        timeout = timeout * 1000;
    }
    clean();
    return toaster.show({
        intent: Intent.DANGER,
        message: message,
        timeout: timeout,
    });
}
function error2(message, timeout) {
    if (timeout === undefined) {
        timeout = 10000;
    }
    else {
        timeout = timeout * 1000;
    }
    clean2();
    return toaster2.show({
        intent: Intent.DANGER,
        message: message,
        timeout: timeout,
    });
}
function clearAlert() {
    let toasts = toaster.getToasts();
    for (let toast of toasts) {
        toaster2.dismiss(toast.key);
    }
}
function clearAlert2() {
    let toasts = toaster2.getToasts();
    for (let toast of toasts) {
        toaster2.dismiss(toast.key);
    }
}
function dismiss(key) {
    toaster.dismiss(key);
}
function init() {
    if (!toaster) {
        if (Toaster) {
            toaster = Toaster.create({
                position: Position.BOTTOM,
            }, document.getElementById("toaster"));
        }
        else {
            console.error("Failed to load toaster");
        }
    }
    if (!toaster2) {
        let elmt = document.getElementById("toaster2");
        if (Toaster) {
            elmt.style.display = "none";
            toaster2 = Toaster.create({
                position: Position.TOP,
            }, elmt);
        }
        else {
            console.error("Failed to load toaster2");
        }
        observer.observe(elmt, {
            childList: true,
            subtree: true,
        });
    }
}
function addChangeListener(callback) {
    callbacks.add(callback);
}
function removeChangeListener(callback) {
    callbacks.delete(callback);
}

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);
;// ./app/Auth.js


let token = '';
function _load() {
    external_fs_default().readFile(authPath, 'utf-8', (err, data) => {
        if (err || !data) {
            setTimeout(() => {
                _load();
            }, 100);
            return;
        }
        token = data.trim();
        setTimeout(() => {
            _load();
        }, 3000);
    });
}
function load() {
    return new Promise((resolve, reject) => {
        external_fs_default().readFile(authPath, 'utf-8', (err, data) => {
            if (err || !data) {
                setTimeout(() => {
                    _load();
                }, 100);
                resolve();
                return;
            }
            token = data.trim();
            resolve();
            setTimeout(() => {
                _load();
            }, 3000);
        });
    });
}

;// external "http"
const external_http_namespaceObject = require("http");
var external_http_default = /*#__PURE__*/__webpack_require__.n(external_http_namespaceObject);
;// external "https"
const external_https_namespaceObject = require("https");
var external_https_default = /*#__PURE__*/__webpack_require__.n(external_https_namespaceObject);
;// ./app/Request.js




var DefaultTimeout = 20;
class Response {
    constructor(res) {
        this.response = res;
        this.status = res.statusCode;
        this.message = res.statusMessage;
        this.data = "";
    }
    get(key) {
        if (this.headers) {
            return this.headers.get(key);
        }
        let curKey = null;
        let headers = new Map();
        for (let item of this.response.rawHeaders) {
            if (curKey) {
                headers.set(curKey, item);
                curKey = null;
            }
            else {
                curKey = item;
            }
        }
        this.headers = headers;
        return this.headers.get(key);
    }
    json() {
        try {
            return JSON.parse(this.data || null);
        }
        catch (err) {
            err = new ReadError(err, "Request: JSON parse failed", { data: this.data });
            throw err;
        }
    }
    jsonPassive() {
        try {
            return JSON.parse(this.data || null);
        }
        catch {
            return null;
        }
    }
    string() {
        return this.data;
    }
}
class Request_Request {
    constructor() {
        this.headers = new Map();
    }
    tcp(host) {
        let hosts = host.split("://");
        this.ssl = hosts[0] === "https";
        hosts = hosts[1].split(":");
        if (hosts.length > 1) {
            this.port = parseInt(hosts.pop(), 10);
            if (this.ssl && this.port === 80) {
                this.port = 443;
            }
        }
        else {
            if (this.ssl) {
                this.port = 443;
            }
            else {
                this.port = 80;
            }
        }
        this.hostname = hosts.join(":");
        return this;
    }
    unix(path) {
        this.socketPath = path;
        return this;
    }
    timeout(timeout) {
        this.ttl = timeout * 1000;
        return this;
    }
    get(path) {
        this.method = "GET";
        this.path = path;
        return this;
    }
    put(path) {
        this.method = "PUT";
        this.path = path;
        return this;
    }
    post(path) {
        this.method = "POST";
        this.path = path;
        return this;
    }
    delete(path) {
        this.method = "DELETE";
        this.path = path;
        return this;
    }
    set(key, value) {
        this.headers.set(key, value);
        return this;
    }
    secure(secure) {
        this.skipVerify = !secure;
        return this;
    }
    send(data) {
        if (typeof data === "string") {
            this.data = data;
        }
        else {
            this.headers.set("Content-Type", "application/json");
            this.data = JSON.stringify(data);
        }
        return this;
    }
    parseError(wrapErr, msg) {
        let data = {};
        if (this.ssl !== undefined) {
            data.ssl = this.ssl;
        }
        if (this.hostname) {
            data.hostname = this.hostname;
        }
        if (this.port) {
            data.port = this.port;
        }
        if (this.method) {
            data.method = this.method;
        }
        if (this.path) {
            data.path = this.path;
        }
        if (this.ttl !== undefined) {
            data.ttl = this.ttl;
        }
        return new RequestError(wrapErr, msg, data);
    }
    end() {
        return new Promise((resolve, reject) => {
            try {
                let options = {
                    path: this.path,
                    method: this.method,
                    headers: Object.fromEntries(this.headers)
                };
                if (this.socketPath) {
                    options.socketPath = this.socketPath;
                }
                else {
                    options.hostname = this.hostname;
                    options.port = this.port;
                }
                if (this.skipVerify) {
                    options.rejectUnauthorized = false;
                }
                options.timeout = this.ttl || (DefaultTimeout * 1000);
                let callback = (nodeResp) => {
                    let resp = new Response(nodeResp);
                    nodeResp.on("data", (data) => {
                        if (data) {
                            resp.data += data.toString();
                        }
                    });
                    nodeResp.on("end", () => {
                        resolve(resp);
                    });
                };
                let req;
                if (this.ssl) {
                    req = external_https_default().request(options, callback);
                }
                else {
                    req = external_http_default().request(options, callback);
                }
                req.on("timeout", () => {
                    let err = this.parseError(null, "Request: Timeout error");
                    req.destroy(err);
                    Logger_error(err);
                    reject(err);
                });
                req.on("error", (err) => {
                    err = this.parseError(err, "Request:  Client error");
                    Logger_error(err);
                    reject(err);
                });
                if (this.data) {
                    req.write(this.data);
                }
                req.end();
            }
            catch (err) {
                err = this.parseError(err, "Request: Exception");
                Logger_error(err);
                reject(err);
            }
        });
    }
}

// EXTERNAL MODULE: ./node_modules/tar/index.js
var tar = __webpack_require__(8302);
;// external "child_process"
const external_child_process_namespaceObject = require("child_process");
var external_child_process_default = /*#__PURE__*/__webpack_require__.n(external_child_process_namespaceObject);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);
;// ./app/utils/MiscUtils.js






function uuid() {
    return (+new Date() + Math.floor(Math.random() * 999999)).toString(36);
}
function uuidRand() {
    let id = "";
    for (let i = 0; i < 4; i++) {
        id += Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return id;
}
function nonce() {
    let nonce = '';
    for (let i = 0; i < 8; i++) {
        nonce += Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return nonce;
}
function titleCase(str) {
    return str
        .toLowerCase()
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}
function shuffle(n) {
    let i = n.length, j;
    while (i != 0) {
        j = Math.floor(Math.random() * i);
        i--;
        [n[i], n[j]] = [n[j], n[i]];
    }
    return n;
}
function objectIdNil(objId) {
    return !objId || objId == '000000000000000000000000';
}
function zeroPad(num, width) {
    if (num < Math.pow(10, width)) {
        return ('0'.repeat(width - 1) + num).slice(-width);
    }
    return num.toString();
}
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function formatAmount(amount) {
    if (!amount) {
        return '-';
    }
    return '$' + (amount / 100).toFixed(2);
}
function formatDate(dateData) {
    if (!dateData || dateData === '0001-01-01T00:00:00Z') {
        return '';
    }
    let date;
    if (dateData instanceof String) {
        date = new Date(dateData);
    }
    else {
        date = new Date(0);
        date.setUTCSeconds(dateData);
    }
    let str = '';
    let hours = date.getHours();
    let period = 'AM';
    if (hours > 12) {
        period = 'PM';
        hours -= 12;
    }
    else if (hours === 0) {
        hours = 12;
    }
    let day;
    switch (date.getDay()) {
        case 0:
            day = 'Sun';
            break;
        case 1:
            day = 'Mon';
            break;
        case 2:
            day = 'Tue';
            break;
        case 3:
            day = 'Wed';
            break;
        case 4:
            day = 'Thu';
            break;
        case 5:
            day = 'Fri';
            break;
        case 6:
            day = 'Sat';
            break;
    }
    let month;
    switch (date.getMonth()) {
        case 0:
            month = 'Jan';
            break;
        case 1:
            month = 'Feb';
            break;
        case 2:
            month = 'Mar';
            break;
        case 3:
            month = 'Apr';
            break;
        case 4:
            month = 'May';
            break;
        case 5:
            month = 'Jun';
            break;
        case 6:
            month = 'Jul';
            break;
        case 7:
            month = 'Aug';
            break;
        case 8:
            month = 'Sep';
            break;
        case 9:
            month = 'Oct';
            break;
        case 10:
            month = 'Nov';
            break;
        case 11:
            month = 'Dec';
            break;
    }
    str += day + ' ';
    str += date.getDate() + ' ';
    str += month + ' ';
    str += date.getFullYear() + ', ';
    str += hours + ':';
    str += zeroPad(date.getMinutes(), 2) + ':';
    str += zeroPad(date.getSeconds(), 2) + ' ';
    str += period;
    return str;
}
function formatDateLess(dateData) {
    if (!dateData || dateData === '0001-01-01T00:00:00Z') {
        return '';
    }
    let date;
    if (dateData instanceof String) {
        date = new Date(dateData);
    }
    else {
        date = new Date(0);
        date.setUTCSeconds(dateData);
    }
    let str = '';
    let hours = date.getHours();
    let period = 'AM';
    if (hours > 12) {
        period = 'PM';
        hours -= 12;
    }
    else if (hours === 0) {
        hours = 12;
    }
    let month;
    switch (date.getMonth()) {
        case 0:
            month = 'Jan';
            break;
        case 1:
            month = 'Feb';
            break;
        case 2:
            month = 'Mar';
            break;
        case 3:
            month = 'Apr';
            break;
        case 4:
            month = 'May';
            break;
        case 5:
            month = 'Jun';
            break;
        case 6:
            month = 'Jul';
            break;
        case 7:
            month = 'Aug';
            break;
        case 8:
            month = 'Sep';
            break;
        case 9:
            month = 'Oct';
            break;
        case 10:
            month = 'Nov';
            break;
        case 11:
            month = 'Dec';
            break;
    }
    str += month + ' ';
    str += date.getDate() + ' ';
    str += date.getFullYear() + ', ';
    str += hours + ':';
    str += zeroPad(date.getMinutes(), 2);
    str += period;
    return str;
}
function formatDateShort(dateData) {
    if (!dateData || dateData === '0001-01-01T00:00:00Z') {
        return '';
    }
    let date;
    if (dateData instanceof String) {
        date = new Date(dateData);
    }
    else {
        date = new Date(0);
        date.setUTCSeconds(dateData);
    }
    let curDate = new Date();
    let month;
    switch (date.getMonth()) {
        case 0:
            month = 'Jan';
            break;
        case 1:
            month = 'Feb';
            break;
        case 2:
            month = 'Mar';
            break;
        case 3:
            month = 'Apr';
            break;
        case 4:
            month = 'May';
            break;
        case 5:
            month = 'Jun';
            break;
        case 6:
            month = 'Jul';
            break;
        case 7:
            month = 'Aug';
            break;
        case 8:
            month = 'Sep';
            break;
        case 9:
            month = 'Oct';
            break;
        case 10:
            month = 'Nov';
            break;
        case 11:
            month = 'Dec';
            break;
    }
    let str = month + ' ' + date.getDate();
    if (date.getFullYear() !== curDate.getFullYear()) {
        str += ' ' + date.getFullYear();
    }
    return str;
}
function formatDateShortTime(dateData) {
    if (!dateData || dateData === '0001-01-01T00:00:00Z') {
        return '';
    }
    let date;
    if (dateData instanceof String) {
        date = new Date(dateData);
    }
    else {
        date = new Date(0);
        date.setUTCSeconds(dateData);
    }
    let curDate = new Date();
    let month;
    switch (date.getMonth()) {
        case 0:
            month = 'Jan';
            break;
        case 1:
            month = 'Feb';
            break;
        case 2:
            month = 'Mar';
            break;
        case 3:
            month = 'Apr';
            break;
        case 4:
            month = 'May';
            break;
        case 5:
            month = 'Jun';
            break;
        case 6:
            month = 'Jul';
            break;
        case 7:
            month = 'Aug';
            break;
        case 8:
            month = 'Sep';
            break;
        case 9:
            month = 'Oct';
            break;
        case 10:
            month = 'Nov';
            break;
        case 11:
            month = 'Dec';
            break;
    }
    let str = month + ' ' + date.getDate();
    if (date.getFullYear() !== curDate.getFullYear()) {
        str += ' ' + date.getFullYear();
    }
    else if (date.getMonth() === curDate.getMonth() &&
        date.getDate() === curDate.getDate()) {
        let hours = date.getHours();
        let period = 'AM';
        if (hours > 12) {
            period = 'PM';
            hours -= 12;
        }
        else if (hours === 0) {
            hours = 12;
        }
        str = hours + ':';
        str += zeroPad(date.getMinutes(), 2) + ':';
        str += zeroPad(date.getSeconds(), 2) + ' ';
        str += period;
    }
    return str;
}
function exec(path, ...args) {
    return new Promise((resolve) => {
        external_child_process_default().execFile(path, args, (err, stdout, stderr) => {
            if (err) {
                err = new ExecError(err, "Utils: Exec error", { path: path, args: args, stdout: stdout, stderr: stderr });
            }
            resolve({
                stdout: stdout,
                stderr: stderr,
                error: err,
            });
        });
    });
}
function fileExists(path) {
    return new Promise((resolve) => {
        external_fs_default().stat(path, (err, stat) => {
            if (!err) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
    });
}
function fileSize(path) {
    return new Promise((resolve) => {
        external_fs_default().stat(path, (err, stat) => {
            if (err || !stat) {
                resolve(0);
            }
            resolve(stat.size || 0);
        });
    });
}
function fileDelete(path) {
    return new Promise((resolve, reject) => {
        external_fs_default().exists(path, (exists) => {
            if (!exists) {
                resolve();
                return;
            }
            external_fs_default().unlink(path, (err) => {
                if (err) {
                    err = new WriteError(err, "Utils: Failed to delete file", { path: path });
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    });
}
function fileRead(path) {
    return new Promise((resolve, reject) => {
        external_fs_default().readFile(path, "utf-8", (err, data) => {
            if (err) {
                err = new ReadError(err, "Utils: Failed to read file", { path: path });
                reject(err);
                return;
            }
            resolve(data);
        });
    });
}
function fileWrite(path, data) {
    return new Promise((resolve, reject) => {
        external_fs_default().writeFile(path, data, (err) => {
            if (err) {
                err = new WriteError(err, "Utils: Failed to write file", { path: path });
                reject(err);
                return;
            }
            resolve();
        });
    });
}
function uriFromPath(pth) {
    const pathName = external_path_default().resolve(pth).replace(/\\/g, "/");
    return encodeURI("file://" + (pathName.charAt(0) !== "/" ?
        "/" + pathName : pathName));
}
function encryptAvailable() {
    return new Promise((resolve, reject) => {
        try {
            let evt = external_electron_default().ipcRenderer.invoke("processing", "encryptable");
            evt.then((resp) => {
                if (!resp) {
                    let err = new ParseError(null, "Utils: Failed to check encryption support e1");
                    reject(err);
                }
                else if (resp[0]) {
                    let err = new ParseError(resp[0], "Utils: Failed to check encryption support e2");
                    reject(err);
                }
                else {
                    resolve(resp[1]);
                }
            }).catch((err) => {
                err = new ParseError(err, "Utils: Failed to check encryption support e3");
                reject(err);
            });
        }
        catch (err) {
            err = new ParseError(err, "Utils: Failed to check encryption support e4");
            reject(err);
        }
    });
}
function encryptString(decData) {
    return new Promise((resolve, reject) => {
        try {
            let evt = external_electron_default().ipcRenderer.invoke("processing", "encrypt", decData);
            evt.then((resp) => {
                if (!resp) {
                    let err = new ParseError(null, "Utils: Failed to encrypt string e1");
                    reject(err);
                }
                else if (resp[0]) {
                    let err = new ParseError(resp[0], "Utils: Failed to encrypt string e2");
                    reject(err);
                }
                else {
                    resolve(resp[1]);
                }
            }).catch((err) => {
                err = new ParseError(err, "Utils: Failed to encrypt string e3");
                reject(err);
            });
        }
        catch (err) {
            err = new ParseError(err, "Utils: Failed to encrypt string e4");
            reject(err);
        }
    });
}
function decryptString(encData) {
    return new Promise((resolve, reject) => {
        try {
            let evt = external_electron_default().ipcRenderer.invoke("processing", "decrypt", encData);
            evt.then((resp) => {
                if (!resp) {
                    let err = new ParseError(null, "Utils: Failed to decrypt string e1");
                    reject(err);
                }
                else if (resp[0]) {
                    let err = new ParseError(resp[0], "Utils: Failed to decrypt string e2");
                    reject(err);
                }
                else {
                    resolve(resp[1]);
                }
            }).catch((err) => {
                err = new ParseError(err, "Utils: Failed to decrypt string e3");
                reject(err);
            });
        }
        catch (err) {
            err = new ParseError(err, "Utils: Failed to decrypt string e4");
            reject(err);
        }
    });
}
function tarRead(path) {
    return new Promise((resolve, reject) => {
        try {
            let files = [];
            let parser = new tar.Parse();
            external_fs_default().createReadStream(path)
                .pipe(parser)
                .on("entry", (entry) => {
                let data = "";
                entry.on("data", (content) => {
                    data += content.toString();
                });
                entry.on("end", () => {
                    files.push({
                        path: entry.path,
                        data: data,
                    });
                });
            })
                .on("end", () => {
                resolve(files);
            });
        }
        catch (err) {
            err = new ReadError(err, "Utils: Failed to read tar file", { path: path });
            reject(err);
        }
    });
}

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);
;// ./app/utils/RequestUtils.js





function get(path) {
    let req = new Request_Request();
    if (unix) {
        req.unix(unixPath);
    }
    else {
        req.tcp(webHost);
    }
    req.get(path)
        .set("Auth-Token", token)
        .set("User-Agent", "pritunl");
    return req;
}
function put(path) {
    let req = new Request_Request();
    if (unix) {
        req.unix(unixPath);
    }
    else {
        req.tcp(webHost);
    }
    req.put(path)
        .set("Auth-Token", token)
        .set("User-Agent", "pritunl");
    return req;
}
function post(path) {
    let req = new Request_Request();
    if (unix) {
        req.unix(unixPath);
    }
    else {
        req.tcp(webHost);
    }
    req.post(path)
        .set("Auth-Token", token)
        .set("User-Agent", "pritunl");
    return req;
}
function del(path) {
    let req = new Request_Request();
    if (unix) {
        req.unix(unixPath);
    }
    else {
        req.tcp(webHost);
    }
    req.delete(path)
        .set("Auth-Token", token)
        .set("User-Agent", "pritunl");
    return req;
}
function authGet(host, path, token, secret) {
    let req = new Request.Request();
    req.get(host + path)
        .set("Auth-Token", Auth.token)
        .set("User-Agent", "pritunl");
    let authTimestamp = Math.floor(new Date().getTime() / 1000).toString();
    let authNonce = MiscUtils.nonce();
    let authString = [token, authTimestamp, authNonce, "get", path].join("&");
    let authSignature = crypto.createHmac("sha512", secret).update(authString).digest("base64");
    req.secure(false)
        .set("Auth-Token", token)
        .set("Auth-Timestamp", authTimestamp)
        .set("Auth-Nonce", authNonce)
        .set("Auth-Signature", authSignature);
    return req;
}

// EXTERNAL MODULE: external "process"
var external_process_ = __webpack_require__(932);
var external_process_default = /*#__PURE__*/__webpack_require__.n(external_process_);
;// external "os"
const external_os_namespaceObject = require("os");
var external_os_default = /*#__PURE__*/__webpack_require__.n(external_os_namespaceObject);
;// ./app/Constants.js







const loadDelay = 700;
let unix = false;
const unixPath = "/var/run/pritunl.sock";
const webHost = 'http://127.0.0.1:9770';
const unixWsHost = 'ws+unix://' + external_path_default().join((external_path_default()).sep, 'var', 'run', 'pritunl.sock') + ':';
const webWsHost = 'ws://127.0.0.1:9770';
const platform = external_os_default().platform();
const hostname = external_os_default().hostname();
const args = new Map();
let production = true;
let authPath = '';
let deviceAuthPath = '';
let frameless = false;
let winDrive = 'C:\\';
let systemDrv = (external_process_default()).env.SYSTEMDRIVE;
if (systemDrv) {
    winDrive = systemDrv + '\\';
}
if ((external_process_default()).platform === 'linux' || (external_process_default()).platform === 'darwin') {
    unix = true;
}
let queryVals = window.location.search.substring(1).split('&');
for (let item of queryVals) {
    let items = item.split('=');
    if (items.length < 2) {
        continue;
    }
    let key = items[0];
    let value = items.slice(1).join('=');
    args.set(key, decodeURIComponent(value));
}
if (args.get('dev') === 'true') {
    production = false;
}
if ((external_process_default()).platform === 'win32') {
    authPath = external_path_default().join(winDrive, 'ProgramData', 'Pritunl', 'auth');
}
else {
    authPath = external_path_default().join((external_path_default()).sep, 'var', 'run', 'pritunl.auth');
}
if (args.get("frameless") === "true") {
    frameless = true;
}
const dataPath = args.get('dataPath');
let state = {};
function syncState() {
    get("/state")
        .set('Accept', 'application/json')
        .end()
        .then((resp) => {
        state = (resp.json() || {});
        triggerChange();
    }, (err) => {
        err = new RequestError(err, "Constants: Failed to load state");
        errorAlert2(err);
    });
}
function Constants_load() {
    if (token === '') {
        setTimeout(() => {
            Constants_load();
        }, 100);
        return;
    }
    syncState();
    setInterval(syncState, 5000);
}
let started = false;
function app_Constants_load() {
    if (started) {
        return;
    }
    started = true;
    Constants_load();
}
let Constants_callbacks = new Set();
function triggerChange() {
    Constants_callbacks.forEach((callback) => {
        callback();
    });
}
function Constants_addChangeListener(callback) {
    Constants_callbacks.add(callback);
}
function Constants_removeChangeListener(callback) {
    Constants_callbacks.delete(callback);
}

;// ./app/Paths.js


function log() {
    return external_path_default().join(dataPath, "pritunl.log");
}
function Paths_config() {
    return external_path_default().join(dataPath, "pritunl.json");
}
function profiles() {
    return external_path_default().join(dataPath, "profiles");
}

;// ./app/Logger.js




function push(level, err) {
    if (!err) {
        err = "Undefined error";
    }
    let time = new Date();
    let msg = err.message || err;
    msg = "[" + time.getFullYear() + "-" + (time.getMonth() + 1) + "-" +
        time.getDate() + " " + time.getHours() + ":" + time.getMinutes() + ":" +
        time.getSeconds() + "][" + level + "] " + msg + "\n" + (err.stack || "");
    msg = msg.trim();
    let pth = log();
    external_fs_default().stat(pth, (err, stat) => {
        if (stat && stat.size > 200000) {
            external_fs_default().unlink(pth, () => {
                external_fs_default().appendFile(pth, msg + "\n", (err) => {
                    if (err) {
                        err = new WriteError(err, "Logger: Failed to write log", { log_path: pth });
                        error2(err.message, 10);
                    }
                });
            });
        }
        else {
            external_fs_default().appendFile(pth, msg + "\n", (err) => {
                if (err) {
                    err = new WriteError(err, "Logger: Failed to write log", { log_path: pth });
                    error2(err.message, 10);
                }
            });
        }
    });
}
function Logger_info(err) {
    push("INFO", err);
}
function Logger_warning(err) {
    push("WARN", err);
}
function Logger_error(err) {
    push("ERROR", err);
}
function errorAlert(err, timeout) {
    if (!err) {
        err = "Undefined error";
    }
    push("ERROR", err);
    error(err.message || err, timeout);
}
function errorAlert2(err, timeout) {
    if (!err) {
        err = "Undefined error";
    }
    push("ERROR", err);
    error2(err.message || err, timeout);
}

;// ./app/Config.js





class ConfigData {
    constructor() {
        this.window_width = 0;
        this.window_height = 0;
        this.disable_tray_icon = false;
        this.classic_interface = false;
        this.safe_storage = false;
        this.frameless = null;
        this.theme = "dark-3";
        this.editor_theme = "";
    }
    _load(data) {
        if (data["disable_tray_icon"] !== undefined) {
            this.disable_tray_icon = data["disable_tray_icon"];
        }
        if (data["classic_interface"] !== undefined) {
            this.classic_interface = data["classic_interface"];
        }
        if (data["safe_storage"] !== undefined) {
            this.safe_storage = data["safe_storage"];
        }
        if (data["theme"] !== undefined) {
            this.theme = data["theme"];
        }
        if (data["editor_theme"] !== undefined) {
            this.editor_theme = data["editor_theme"];
        }
        if (data["window_width"] !== undefined) {
            this.window_width = data["window_width"];
        }
        if (data["window_height"] !== undefined) {
            this.window_height = data["window_height"];
        }
        if (data["frameless"] !== undefined) {
            this.frameless = data["frameless"];
        }
    }
    load() {
        return new Promise((resolve, reject) => {
            external_fs_default().readFile(Paths_config(), "utf-8", (err, data) => {
                if (err) {
                    if (err.code !== "ENOENT") {
                        err = new ReadError(err, "Config: Read error", { path: Paths_config() });
                        errorAlert(err, 10);
                    }
                    resolve();
                    return;
                }
                let configData = {};
                if (data) {
                    try {
                        configData = JSON.parse(data);
                    }
                    catch (err) {
                        err = new ReadError(err, "Config: Parse error", { path: Paths_config() });
                        errorAlert(err, 10);
                        configData = {};
                    }
                }
                this._load(configData);
                triggerChange();
                resolve();
            });
        });
    }
    save(opts) {
        let data = {
            disable_tray_icon: opts["disable_tray_icon"],
            classic_interface: opts["classic_interface"],
            safe_storage: opts["safe_storage"],
            window_width: opts["window_width"],
            window_height: opts["window_height"],
            frameless: opts["frameless"],
            theme: opts["theme"],
            editor_theme: opts["editor_theme"],
        };
        return new Promise((resolve, reject) => {
            this.load().then(() => {
                if (data.disable_tray_icon === undefined) {
                    data.disable_tray_icon = this.disable_tray_icon;
                }
                if (data.classic_interface === undefined) {
                    data.classic_interface = this.classic_interface;
                }
                if (data.safe_storage === undefined) {
                    data.safe_storage = this.safe_storage;
                }
                if (data.window_width === undefined) {
                    data.window_width = this.window_width;
                }
                if (data.theme === undefined) {
                    data.theme = this.theme;
                }
                if (data.editor_theme === undefined) {
                    data.editor_theme = this.editor_theme;
                }
                if (data.frameless === undefined) {
                    data.frameless = this.frameless;
                }
                this._load(data);
                external_fs_default().writeFile(Paths_config(), JSON.stringify(data), (err) => {
                    if (err) {
                        err = new ReadError(err, "Config: Write error", { path: Paths_config() });
                        errorAlert(err);
                    }
                    triggerChange();
                    resolve();
                });
            });
        });
    }
}
const Config = new ConfigData();
/* harmony default export */ const app_Config = (Config);

;// ./app/EditorThemes.js
let allHallowsEve = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "000000", "token": "" },
        { "foreground": "ffffff", "background": "434242", "token": "text" },
        { "foreground": "ffffff", "background": "000000", "token": "source" },
        { "foreground": "9933cc", "token": "comment" },
        { "foreground": "3387cc", "token": "constant" },
        { "foreground": "cc7833", "token": "keyword" },
        { "foreground": "d0d0ff", "token": "meta.preprocessor.c" },
        { "fontStyle": "italic", "token": "variable.parameter" },
        { "foreground": "ffffff", "background": "9b9b9b", "token": "source comment.block" },
        { "foreground": "66cc33", "token": "string" },
        { "foreground": "aaaaaa", "token": "string constant.character.escape" },
        { "foreground": "000000", "background": "cccc33", "token": "string.interpolated" },
        { "foreground": "cccc33", "token": "string.regexp" },
        { "foreground": "cccc33", "token": "string.literal" },
        { "foreground": "555555", "token": "string.interpolated constant.character.escape" },
        { "fontStyle": "underline", "token": "entity.name.type" },
        { "fontStyle": "italic underline", "token": "entity.other.inherited-class" },
        { "fontStyle": "underline", "token": "entity.name.tag" },
        { "foreground": "c83730", "token": "support.function" }
    ],
    "colors": {
        "editor.foreground": "#FFFFFF",
        "editor.background": "#000000",
        "editor.selectionBackground": "#73597EE0",
        "editor.lineHighlightBackground": "#333300",
        "editorCursor.foreground": "#FFFFFF",
        "editorWhitespace.foreground": "#404040"
    }
};
let amy = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "200020", "token": "" },
        { "foreground": "404080", "background": "200020", "fontStyle": "italic", "token": "comment.block" },
        { "foreground": "999999", "token": "string" },
        { "foreground": "707090", "token": "constant.language" },
        { "foreground": "7090b0", "token": "constant.numeric" },
        { "fontStyle": "bold", "token": "constant.numeric.integer.int32" },
        { "fontStyle": "italic", "token": "constant.numeric.integer.int64" },
        { "fontStyle": "bold italic", "token": "constant.numeric.integer.nativeint" },
        { "fontStyle": "underline", "token": "constant.numeric.floating-point.ocaml" },
        { "foreground": "666666", "token": "constant.character" },
        { "foreground": "8080a0", "token": "constant.language.boolean" },
        { "foreground": "008080", "token": "variable.language" },
        { "foreground": "008080", "token": "variable.other" },
        { "foreground": "a080ff", "token": "keyword" },
        { "foreground": "a0a0ff", "token": "keyword.operator" },
        { "foreground": "d0d0ff", "token": "keyword.other.decorator" },
        { "fontStyle": "underline", "token": "keyword.operator.infix.floating-point.ocaml" },
        { "fontStyle": "underline", "token": "keyword.operator.prefix.floating-point.ocaml" },
        { "foreground": "c080c0", "token": "keyword.other.directive" },
        { "foreground": "c080c0", "fontStyle": "underline", "token": "keyword.other.directive.line-number" },
        { "foreground": "80a0ff", "token": "keyword.control" },
        { "foreground": "b0fff0", "token": "storage" },
        { "foreground": "60b0ff", "token": "entity.name.type.variant" },
        { "foreground": "60b0ff", "fontStyle": "italic", "token": "storage.type.variant.polymorphic" },
        { "foreground": "60b0ff", "fontStyle": "italic", "token": "entity.name.type.variant.polymorphic" },
        { "foreground": "b000b0", "token": "entity.name.type.module" },
        { "foreground": "b000b0", "fontStyle": "underline", "token": "entity.name.type.module-type.ocaml" },
        { "foreground": "a00050", "token": "support.other" },
        { "foreground": "70e080", "token": "entity.name.type.class" },
        { "foreground": "70e0a0", "token": "entity.name.type.class-type" },
        { "foreground": "50a0a0", "token": "entity.name.function" },
        { "foreground": "80b0b0", "token": "variable.parameter" },
        { "foreground": "3080a0", "token": "entity.name.type.token" },
        { "foreground": "3cb0d0", "token": "entity.name.type.token.reference" },
        { "foreground": "90e0e0", "token": "entity.name.function.non-terminal" },
        { "foreground": "c0f0f0", "token": "entity.name.function.non-terminal.reference" },
        { "foreground": "009090", "token": "entity.name.tag" },
        { "background": "200020", "token": "support.constant" },
        { "foreground": "400080", "background": "ffff00", "fontStyle": "bold", "token": "invalid.illegal" },
        { "foreground": "200020", "background": "cc66ff", "token": "invalid.deprecated" },
        { "background": "40008054", "token": "source.camlp4.embedded" },
        { "foreground": "805080", "token": "punctuation" }
    ],
    "colors": {
        "editor.foreground": "#D0D0FF",
        "editor.background": "#200020",
        "editor.selectionBackground": "#80000080",
        "editor.lineHighlightBackground": "#80000040",
        "editorCursor.foreground": "#7070FF",
        "editorWhitespace.foreground": "#BFBFBF"
    }
};
let birdsOfParadise = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "372725", "token": "" },
        { "foreground": "e6e1c4", "background": "322323", "token": "source" },
        { "foreground": "6b4e32", "fontStyle": "italic", "token": "comment" },
        { "foreground": "ef5d32", "token": "keyword" },
        { "foreground": "ef5d32", "token": "storage" },
        { "foreground": "efac32", "token": "entity.name.function" },
        { "foreground": "efac32", "token": "keyword.other.name-of-parameter.objc" },
        { "foreground": "efac32", "fontStyle": "bold", "token": "entity.name" },
        { "foreground": "6c99bb", "token": "constant.numeric" },
        { "foreground": "7daf9c", "token": "variable.language" },
        { "foreground": "7daf9c", "token": "variable.other" },
        { "foreground": "6c99bb", "token": "constant" },
        { "foreground": "efac32", "token": "variable.other.constant" },
        { "foreground": "6c99bb", "token": "constant.language" },
        { "foreground": "d9d762", "token": "string" },
        { "foreground": "efac32", "token": "support.function" },
        { "foreground": "efac32", "token": "support.type" },
        { "foreground": "6c99bb", "token": "support.constant" },
        { "foreground": "efcb43", "token": "meta.tag" },
        { "foreground": "efcb43", "token": "declaration.tag" },
        { "foreground": "efcb43", "token": "entity.name.tag" },
        { "foreground": "efcb43", "token": "entity.other.attribute-name" },
        { "foreground": "ffffff", "background": "990000", "token": "invalid" },
        { "foreground": "7daf9c", "token": "constant.character.escaped" },
        { "foreground": "7daf9c", "token": "constant.character.escape" },
        { "foreground": "7daf9c", "token": "string source" },
        { "foreground": "7daf9c", "token": "string source.ruby" },
        { "foreground": "e6e1dc", "background": "144212", "token": "markup.inserted" },
        { "foreground": "e6e1dc", "background": "660000", "token": "markup.deleted" },
        { "background": "2f33ab", "token": "meta.diff.header" },
        { "background": "2f33ab", "token": "meta.separator.diff" },
        { "background": "2f33ab", "token": "meta.diff.index" },
        { "background": "2f33ab", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#E6E1C4",
        "editor.background": "#372725",
        "editor.selectionBackground": "#16120E",
        "editor.lineHighlightBackground": "#1F1611",
        "editorCursor.foreground": "#E6E1C4",
        "editorWhitespace.foreground": "#42302D"
    }
};
let blackboard = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "0C1021", "token": "" },
        { "foreground": "aeaeae", "token": "comment" },
        { "foreground": "d8fa3c", "token": "constant" },
        { "foreground": "ff6400", "token": "entity" },
        { "foreground": "fbde2d", "token": "keyword" },
        { "foreground": "fbde2d", "token": "storage" },
        { "foreground": "61ce3c", "token": "string" },
        { "foreground": "61ce3c", "token": "meta.verbatim" },
        { "foreground": "8da6ce", "token": "support" },
        { "foreground": "ab2a1d", "fontStyle": "italic", "token": "invalid.deprecated" },
        { "foreground": "f8f8f8", "background": "9d1e15", "token": "invalid.illegal" },
        { "foreground": "ff6400", "fontStyle": "italic", "token": "entity.other.inherited-class" },
        { "foreground": "ff6400", "token": "string constant.other.placeholder" },
        { "foreground": "becde6", "token": "meta.function-call.py" },
        { "foreground": "7f90aa", "token": "meta.tag" },
        { "foreground": "7f90aa", "token": "meta.tag entity" },
        { "foreground": "ffffff", "token": "entity.name.section" },
        { "foreground": "d5e0f3", "token": "keyword.type.variant" },
        { "foreground": "f8f8f8", "token": "source.ocaml keyword.operator.symbol" },
        { "foreground": "8da6ce", "token": "source.ocaml keyword.operator.symbol.infix" },
        { "foreground": "8da6ce", "token": "source.ocaml keyword.operator.symbol.prefix" },
        { "fontStyle": "underline", "token": "source.ocaml keyword.operator.symbol.infix.floating-point" },
        { "fontStyle": "underline", "token": "source.ocaml keyword.operator.symbol.prefix.floating-point" },
        { "fontStyle": "underline", "token": "source.ocaml constant.numeric.floating-point" },
        { "background": "ffffff08", "token": "text.tex.latex meta.function.environment" },
        { "background": "7a96fa08", "token": "text.tex.latex meta.function.environment meta.function.environment" },
        { "foreground": "fbde2d", "token": "text.tex.latex support.function" },
        { "foreground": "ffffff", "token": "source.plist string.unquoted" },
        { "foreground": "ffffff", "token": "source.plist keyword.operator" }
    ],
    "colors": {
        "editor.foreground": "#F8F8F8",
        "editor.background": "#0C1021",
        "editor.selectionBackground": "#253B76",
        "editor.lineHighlightBackground": "#FFFFFF0F",
        "editorCursor.foreground": "#FFFFFFA6",
        "editorWhitespace.foreground": "#FFFFFF40"
    }
};
let brillianceBlack = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "0D0D0DFA", "token": "" },
        { "foreground": "000000", "background": "ffffff", "fontStyle": "bold", "token": "meta.thomas_aylott" },
        { "foreground": "555555", "background": "ffffff", "fontStyle": "underline", "token": "meta.subtlegradient" },
        { "foreground": "fffc80", "background": "803d0033", "token": "string -meta.tag -meta.doctype -string.regexp -string.literal -string.interpolated -string.quoted.literal -string.unquoted" },
        { "foreground": "fffc80", "background": "803d0033", "token": "variable.parameter.misc.css" },
        { "foreground": "fffc80", "background": "803d0033", "token": "text string source string" },
        { "foreground": "fffc80", "background": "803d0033", "token": "string.unquoted string" },
        { "foreground": "fffc80", "background": "803d0033", "token": "string.regexp string" },
        { "foreground": "fffc80", "background": "803d0033", "token": "string.interpolated string" },
        { "foreground": "fffc80", "background": "803d0033", "token": "meta.tag source string" },
        { "foreground": "803d00", "token": "punctuation.definition.string -meta.tag" },
        { "foreground": "fff80033", "token": "string.regexp punctuation.definition.string" },
        { "foreground": "fff80033", "token": "string.quoted.literal punctuation.definition.string" },
        { "foreground": "fff80033", "token": "string.quoted.double.ruby.mod punctuation.definition.string" },
        { "foreground": "fff800", "background": "43800033", "token": "string.quoted.literal" },
        { "foreground": "fff800", "background": "43800033", "token": "string.quoted.double.ruby.mod" },
        { "foreground": "ffbc80", "token": "string.unquoted -string.unquoted.embedded" },
        { "foreground": "ffbc80", "token": "string.quoted.double.multiline" },
        { "foreground": "ffbc80", "token": "meta.scope.heredoc" },
        { "foreground": "fffc80", "background": "1a1a1a", "token": "string.interpolated" },
        { "foreground": "fff800", "background": "43800033", "token": "string.regexp" },
        { "background": "43800033", "token": "string.regexp.group" },
        { "foreground": "ffffff66", "background": "43800033", "token": "string.regexp.group string.regexp.group" },
        { "foreground": "ffffff66", "background": "43800033", "token": "string.regexp.group string.regexp.group string.regexp.group" },
        { "foreground": "ffffff66", "background": "43800033", "token": "string.regexp.group string.regexp.group string.regexp.group string.regexp.group" },
        { "foreground": "86ff00", "background": "43800033", "token": "string.regexp.character-class" },
        { "foreground": "00fff8", "background": "43800033", "token": "string.regexp.arbitrary-repitition" },
        { "foreground": "803d00", "token": "string.regexp punctuation.definition.string keyword.other" },
        { "background": "0086ff33", "token": "meta.group.assertion.regexp" },
        { "foreground": "0086ff", "token": "meta.assertion" },
        { "foreground": "0086ff", "token": "meta.group.assertion keyword.control.group.regexp" },
        { "foreground": "0086ff", "token": "meta.group.assertion punctuation.definition.group" },
        { "foreground": "c6ff00", "token": "constant.numeric" },
        { "foreground": "86ff00", "token": "constant.character" },
        { "foreground": "07ff00", "token": "constant.language" },
        { "foreground": "07ff00", "token": "keyword.other.unit" },
        { "foreground": "07ff00", "token": "constant.other.java" },
        { "foreground": "07ff00", "token": "constant.other.unit" },
        { "foreground": "07ff00", "background": "04800033", "token": "constant.language.pseudo-variable" },
        { "foreground": "00ff79", "token": "constant.other" },
        { "foreground": "00ff79", "token": "constant.block" },
        { "foreground": "00fff8", "token": "support.constant" },
        { "foreground": "00fff8", "token": "constant.name" },
        { "foreground": "00ff79", "background": "00807c33", "token": "variable.other.readwrite.global.pre-defined" },
        { "foreground": "00ff79", "background": "00807c33", "token": "variable.language" },
        { "foreground": "00fff8", "token": "variable.other.constant" },
        { "foreground": "00fff8", "background": "00807c33", "token": "support.variable" },
        { "foreground": "00807c", "background": "00438033", "token": "variable.other.readwrite.global" },
        { "foreground": "31a6ff", "token": "variable.other" },
        { "foreground": "31a6ff", "token": "variable.js" },
        { "foreground": "31a6ff", "token": "punctuation.separator.variable" },
        { "foreground": "0086ff", "background": "0008ff33", "token": "variable.other.readwrite.class" },
        { "foreground": "406180", "token": "variable.other.readwrite.instance" },
        { "foreground": "406180", "token": "variable.other.php" },
        { "foreground": "406180", "token": "variable.other.normal" },
        { "foreground": "00000080", "token": "punctuation.definition" },
        { "foreground": "00000080", "token": "punctuation.separator.variable" },
        { "foreground": "7e0080", "token": "storage -storage.modifier" },
        { "background": "803d0033", "token": "other.preprocessor" },
        { "background": "803d0033", "token": "entity.name.preprocessor" },
        { "foreground": "666666", "token": "variable.language.this.js" },
        { "foreground": "803d00", "token": "storage.modifier" },
        { "foreground": "ff0000", "token": "entity.name.class" },
        { "foreground": "ff0000", "token": "entity.name.type.class" },
        { "foreground": "ff0000", "token": "entity.name.type.module" },
        { "foreground": "870000", "background": "ff000033", "token": "meta.class -meta.class.instance" },
        { "foreground": "870000", "background": "ff000033", "token": "declaration.class" },
        { "foreground": "870000", "background": "ff000033", "token": "meta.definition.class" },
        { "foreground": "870000", "background": "ff000033", "token": "declaration.module" },
        { "foreground": "ff0000", "background": "87000033", "token": "support.type" },
        { "foreground": "ff0000", "background": "87000033", "token": "support.class" },
        { "foreground": "ff3d44", "token": "entity.name.instance" },
        { "foreground": "ff3d44", "token": "entity.name.type.instance" },
        { "background": "831e5133", "token": "meta.class.instance.constructor" },
        { "foreground": "ff0086", "background": "80000433", "token": "entity.other.inherited-class" },
        { "foreground": "ff0086", "background": "80000433", "token": "entity.name.module" },
        { "foreground": "ff0086", "token": "meta.definition.method" },
        { "foreground": "ff0086", "token": "entity.name.function" },
        { "foreground": "ff0086", "token": "entity.name.preprocessor" },
        { "foreground": "9799ff", "token": "variable.parameter.function" },
        { "foreground": "9799ff", "token": "variable.parameter -variable.parameter.misc.css" },
        { "foreground": "9799ff", "token": "meta.definition.method  meta.definition.param-list" },
        { "foreground": "9799ff", "token": "meta.function.method.with-arguments variable.parameter.function" },
        { "foreground": "800004", "token": "punctuation.definition.parameters" },
        { "foreground": "800004", "token": "variable.parameter.function punctuation.separator.object" },
        { "foreground": "782ec1", "token": "keyword.other.special-method" },
        { "foreground": "782ec1", "token": "meta.function-call entity.name.function -(meta.function-call meta.function)" },
        { "foreground": "782ec1", "token": "support.function - variable" },
        { "foreground": "9d3eff", "token": "meta.function-call support.function - variable" },
        { "foreground": "603f80", "background": "603f8033", "token": "support.function" },
        { "foreground": "bc80ff", "token": "punctuation.section.function" },
        { "foreground": "bc80ff", "token": "meta.brace.curly.function" },
        { "foreground": "bc80ff", "token": "meta.function-call punctuation.section.scope.ruby" },
        { "foreground": "bc80ff", "token": "meta.function-call punctuation.separator.object" },
        { "foreground": "bc80ff", "fontStyle": "bold", "token": "meta.group.braces.round punctuation.section.scope" },
        { "foreground": "bc80ff", "fontStyle": "bold", "token": "meta.group.braces.round meta.delimiter.object.comma" },
        { "foreground": "bc80ff", "fontStyle": "bold", "token": "meta.group.braces.curly.function meta.delimiter.object.comma" },
        { "foreground": "bc80ff", "fontStyle": "bold", "token": "meta.brace.round" },
        { "foreground": "a88fc0", "token": "meta.function-call.method.without-arguments" },
        { "foreground": "a88fc0", "token": "meta.function-call.method.without-arguments entity.name.function" },
        { "foreground": "f800ff", "token": "keyword.control" },
        { "foreground": "7900ff", "token": "keyword.other" },
        { "foreground": "0000ce", "token": "keyword.operator" },
        { "foreground": "0000ce", "token": "declaration.function.operator" },
        { "foreground": "0000ce", "token": "meta.preprocessor.c.include" },
        { "foreground": "0000ce", "token": "punctuation.separator.operator" },
        { "foreground": "0000ce", "background": "00009a33", "token": "keyword.operator.assignment" },
        { "foreground": "2136ce", "token": "keyword.operator.arithmetic" },
        { "foreground": "3759ff", "background": "00009a33", "token": "keyword.operator.logical" },
        { "foreground": "7c88ff", "token": "keyword.operator.comparison" },
        { "foreground": "800043", "token": "meta.class.instance.constructor keyword.operator.new" },
        { "foreground": "cccccc", "background": "333333", "token": "meta.doctype" },
        { "foreground": "cccccc", "background": "333333", "token": "meta.tag.sgml-declaration.doctype" },
        { "foreground": "cccccc", "background": "333333", "token": "meta.tag.sgml.doctype" },
        { "foreground": "333333", "token": "meta.tag" },
        { "foreground": "666666", "background": "333333bf", "token": "meta.tag.structure" },
        { "foreground": "666666", "background": "333333bf", "token": "meta.tag.segment" },
        { "foreground": "4c4c4c", "background": "4c4c4c33", "token": "meta.tag.block" },
        { "foreground": "4c4c4c", "background": "4c4c4c33", "token": "meta.tag.xml" },
        { "foreground": "4c4c4c", "background": "4c4c4c33", "token": "meta.tag.key" },
        { "foreground": "ff7900", "background": "803d0033", "token": "meta.tag.inline" },
        { "background": "803d0033", "token": "meta.tag.inline source" },
        { "foreground": "ff0007", "background": "80000433", "token": "meta.tag.other" },
        { "foreground": "ff0007", "background": "80000433", "token": "entity.name.tag.style" },
        { "foreground": "ff0007", "background": "80000433", "token": "entity.name.tag.script" },
        { "foreground": "ff0007", "background": "80000433", "token": "meta.tag.block.script" },
        { "foreground": "ff0007", "background": "80000433", "token": "source.js.embedded punctuation.definition.tag.html" },
        { "foreground": "ff0007", "background": "80000433", "token": "source.css.embedded punctuation.definition.tag.html" },
        { "foreground": "0086ff", "background": "00438033", "token": "meta.tag.form" },
        { "foreground": "0086ff", "background": "00438033", "token": "meta.tag.block.form" },
        { "foreground": "f800ff", "background": "3c008033", "token": "meta.tag.meta" },
        { "background": "121212", "token": "meta.section.html.head" },
        { "background": "0043801a", "token": "meta.section.html.form" },
        { "foreground": "666666", "token": "meta.tag.xml" },
        { "foreground": "ffffff4d", "token": "entity.name.tag" },
        { "foreground": "ffffff33", "token": "entity.other.attribute-name" },
        { "foreground": "ffffff33", "token": "meta.tag punctuation.definition.string" },
        { "foreground": "ffffff66", "token": "meta.tag string -source -punctuation" },
        { "foreground": "ffffff66", "token": "text source text meta.tag string -punctuation" },
        { "foreground": "999999", "token": "text meta.paragraph" },
        { "foreground": "fff800", "background": "33333333", "token": "markup markup -(markup meta.paragraph.list)" },
        { "foreground": "000000", "background": "ffffff", "token": "markup.hr" },
        { "foreground": "ffffff", "token": "markup.heading" },
        { "foreground": "95d4ff80", "fontStyle": "bold", "token": "markup.bold" },
        { "fontStyle": "italic", "token": "markup.italic" },
        { "fontStyle": "underline", "token": "markup.underline" },
        { "foreground": "0086ff", "token": "meta.reference" },
        { "foreground": "0086ff", "token": "markup.underline.link" },
        { "foreground": "00fff8", "background": "00438033", "token": "entity.name.reference" },
        { "foreground": "00fff8", "fontStyle": "underline", "token": "meta.reference.list markup.underline.link" },
        { "foreground": "00fff8", "fontStyle": "underline", "token": "text.html.textile markup.underline.link" },
        { "background": "80808040", "token": "markup.raw.block" },
        { "background": "ffffff1a", "token": "markup.quote" },
        { "foreground": "ffffff", "token": "markup.list meta.paragraph" },
        { "foreground": "000000", "background": "ffffff", "token": "text.html.markdown" },
        { "foreground": "000000", "token": "text.html.markdown meta.paragraph" },
        { "foreground": "555555", "token": "text.html.markdown markup.list meta.paragraph" },
        { "foreground": "000000", "fontStyle": "bold", "token": "text.html.markdown markup.heading" },
        { "foreground": "8a5420", "token": "text.html.markdown string" },
        { "foreground": "666666", "token": "meta.selector" },
        { "foreground": "006680", "token": "source.css meta.scope.property-list meta.property-value punctuation.definition.arguments" },
        { "foreground": "006680", "token": "source.css meta.scope.property-list meta.property-value punctuation.separator.arguments" },
        { "foreground": "4f00ff", "token": "entity.other.attribute-name.pseudo-element" },
        { "foreground": "7900ff", "token": "entity.other.attribute-name.pseudo-class" },
        { "foreground": "7900ff", "token": "entity.other.attribute-name.tag.pseudo-class" },
        { "foreground": "f800ff", "token": "meta.selector entity.other.attribute-name.class" },
        { "foreground": "ff0086", "token": "meta.selector entity.other.attribute-name.id" },
        { "foreground": "ff0007", "token": "meta.selector entity.name.tag" },
        { "foreground": "ff7900", "fontStyle": "bold", "token": "entity.name.tag.wildcard" },
        { "foreground": "ff7900", "fontStyle": "bold", "token": "entity.other.attribute-name.universal" },
        { "foreground": "c25a00", "token": "source.css entity.other.attribute-name.attribute" },
        { "foreground": "673000", "token": "source.css meta.attribute-selector keyword.operator.comparison" },
        { "foreground": "333333", "fontStyle": "bold", "token": "meta.scope.property-list" },
        { "foreground": "999999", "token": "meta.property-name" },
        { "foreground": "ffffff", "background": "0d0d0d", "token": "support.type.property-name" },
        { "foreground": "999999", "background": "19191980", "token": "meta.property-value" },
        { "background": "000000", "token": "text.latex markup.raw" },
        { "foreground": "bc80ff", "token": "text.latex support.function -support.function.textit -support.function.emph" },
        { "foreground": "ffffffbf", "token": "text.latex support.function.section" },
        { "foreground": "000000", "background": "ffffff", "token": "text.latex entity.name.section -meta.group -keyword.operator.braces" },
        { "background": "00000080", "token": "text.latex keyword.operator.delimiter" },
        { "foreground": "999999", "token": "text.latex keyword.operator.brackets" },
        { "foreground": "666666", "token": "text.latex keyword.operator.braces" },
        { "foreground": "0008ff4d", "background": "00008033", "token": "meta.footnote" },
        { "background": "ffffff0d", "token": "text.latex meta.label.reference" },
        { "foreground": "ff0007", "background": "260001", "token": "text.latex keyword.control.ref" },
        { "foreground": "ffbc80", "background": "400002", "token": "text.latex variable.parameter.label.reference" },
        { "foreground": "ff0086", "background": "260014", "token": "text.latex keyword.control.cite" },
        { "foreground": "ffbfe1", "background": "400022", "token": "variable.parameter.cite" },
        { "foreground": "ffffff80", "token": "text.latex variable.parameter.label" },
        { "foreground": "cdcdcd", "token": "meta.function markup" },
        { "foreground": "33333333", "token": "text.latex meta.group.braces" },
        { "foreground": "33333333", "background": "00000080", "token": "text.latex meta.environment.list" },
        { "foreground": "33333333", "background": "00000080", "token": "text.latex meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "background": "000000", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "000000", "background": "cccccc", "token": "text.latex meta.end-document" },
        { "foreground": "000000", "background": "cccccc", "token": "text.latex meta.begin-document" },
        { "foreground": "000000", "background": "cccccc", "token": "meta.end-document.latex support.function" },
        { "foreground": "000000", "background": "cccccc", "token": "meta.end-document.latex variable.parameter" },
        { "foreground": "000000", "background": "cccccc", "token": "meta.begin-document.latex support.function" },
        { "foreground": "000000", "background": "cccccc", "token": "meta.begin-document.latex variable.parameter" },
        { "foreground": "00ffaa", "background": "00805533", "token": "meta.brace.erb.return-value" },
        { "background": "8080801a", "token": "source.ruby.rails.embedded.return-value.one-line" },
        { "foreground": "00fff8", "background": "00fff81a", "token": "punctuation.section.embedded -(source string source punctuation.section.embedded)" },
        { "foreground": "00fff8", "background": "00fff81a", "token": "meta.brace.erb.html" },
        { "background": "00fff81a", "token": "source.ruby.rails.embedded.one-line" },
        { "foreground": "406180", "token": "source string source punctuation.section.embedded" },
        { "background": "0d0d0d", "token": "source.js.embedded" },
        { "background": "000000", "token": "meta.brace.erb" },
        { "foreground": "ffffff", "background": "33333380", "token": "source string source" },
        { "foreground": "999999", "background": "00000099", "token": "source string.interpolated source" },
        { "background": "3333331a", "token": "source source" },
        { "background": "3333331a", "token": "source.java.embedded" },
        { "foreground": "ffffff", "token": "text -text.xml.strict" },
        { "foreground": "cccccc", "background": "000000", "token": "text source" },
        { "foreground": "cccccc", "background": "000000", "token": "meta.scope.django.template" },
        { "foreground": "999999", "token": "text string source" },
        { "foreground": "330004", "background": "ff0007", "fontStyle": "bold", "token": "invalid -invalid.SOMETHING" },
        { "foreground": "ff3600", "fontStyle": "underline", "token": "invalid.SOMETHING" },
        { "foreground": "333333", "token": "meta.syntax" },
        { "foreground": "4c4c4c", "background": "33333333", "token": "comment -comment.line" },
        { "foreground": "4c4c4c", "fontStyle": "italic", "token": "comment.line" },
        { "fontStyle": "italic", "token": "text comment.block -source" },
        { "foreground": "40ff9a", "background": "00401e", "token": "markup.inserted" },
        { "foreground": "ff40a3", "background": "400022", "token": "markup.deleted" },
        { "foreground": "ffff55", "background": "803d00", "token": "markup.changed" },
        { "foreground": "ffffff", "background": "000000", "token": "text.subversion-commit meta.scope.changed-files" },
        { "foreground": "ffffff", "background": "000000", "token": "text.subversion-commit meta.scope.changed-files.svn meta.diff.separator" },
        { "foreground": "000000", "background": "ffffff", "token": "text.subversion-commit" },
        { "foreground": "7f7f7f", "background": "ffffff03", "fontStyle": "bold", "token": "punctuation.terminator" },
        { "foreground": "7f7f7f", "background": "ffffff03", "fontStyle": "bold", "token": "meta.delimiter" },
        { "foreground": "7f7f7f", "background": "ffffff03", "fontStyle": "bold", "token": "punctuation.separator.method" },
        { "background": "00000080", "token": "punctuation.terminator.statement" },
        { "background": "00000080", "token": "meta.delimiter.statement.js" },
        { "background": "00000040", "token": "meta.delimiter.object.js" },
        { "foreground": "803d00", "fontStyle": "bold", "token": "string.quoted.single.brace" },
        { "foreground": "803d00", "fontStyle": "bold", "token": "string.quoted.double.brace" },
        { "foreground": "333333", "background": "dcdcdc", "token": "text.blog" },
        { "foreground": "333333", "background": "dcdcdc", "token": "text.mail" },
        { "foreground": "cccccc", "background": "000000", "token": "text.blog text" },
        { "foreground": "cccccc", "background": "000000", "token": "text.mail text" },
        { "foreground": "06403e", "background": "00fff81a", "token": "meta.header.blog keyword.other" },
        { "foreground": "06403e", "background": "00fff81a", "token": "meta.header.mail keyword.other" },
        { "foreground": "803d00", "background": "ffff551a", "token": "meta.header.blog string.unquoted.blog" },
        { "foreground": "803d00", "background": "ffff551a", "token": "meta.header.mail string.unquoted" },
        { "foreground": "ff0000", "token": "source.ocaml entity.name.type.module" },
        { "foreground": "ff0000", "background": "83000033", "token": "source.ocaml support.other.module" },
        { "foreground": "00fff8", "token": "entity.name.type.variant" },
        { "foreground": "00ff79", "token": "source.ocaml entity.name.tag" },
        { "foreground": "00ff79", "token": "source.ocaml meta.record.definition" },
        { "foreground": "ffffff", "fontStyle": "bold", "token": "punctuation.separator.parameters" },
        { "foreground": "4c4c4c", "background": "33333333", "token": "meta.brace.pipe" },
        { "foreground": "666666", "fontStyle": "bold", "token": "meta.brace.erb" },
        { "foreground": "666666", "fontStyle": "bold", "token": "source.ruby.embedded.source.brace" },
        { "foreground": "666666", "fontStyle": "bold", "token": "punctuation.section.dictionary" },
        { "foreground": "666666", "fontStyle": "bold", "token": "punctuation.terminator.dictionary" },
        { "foreground": "666666", "fontStyle": "bold", "token": "punctuation.separator.object" },
        { "foreground": "666666", "fontStyle": "bold", "token": "punctuation.separator.statement" },
        { "foreground": "666666", "fontStyle": "bold", "token": "punctuation.separator.key-value.css" },
        { "foreground": "999999", "fontStyle": "bold", "token": "punctuation.section.scope.curly" },
        { "foreground": "999999", "fontStyle": "bold", "token": "punctuation.section.scope" },
        { "foreground": "0c823b", "fontStyle": "bold", "token": "punctuation.separator.objects" },
        { "foreground": "0c823b", "fontStyle": "bold", "token": "meta.group.braces.curly meta.delimiter.object.comma" },
        { "foreground": "0c823b", "fontStyle": "bold", "token": "punctuation.separator.key-value -meta.tag" },
        { "foreground": "0c823b", "fontStyle": "bold", "token": "source.ocaml punctuation.separator.match-definition" },
        { "foreground": "800043", "token": "punctuation.separator.parameters.function.js" },
        { "foreground": "800043", "token": "punctuation.definition.function" },
        { "foreground": "800043", "token": "punctuation.separator.function-return" },
        { "foreground": "800043", "token": "punctuation.separator.function-definition" },
        { "foreground": "800043", "token": "punctuation.definition.arguments" },
        { "foreground": "800043", "token": "punctuation.separator.arguments" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "meta.group.braces.square punctuation.section.scope" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "meta.group.braces.square meta.delimiter.object.comma" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "meta.brace.square" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "punctuation.separator.array" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "punctuation.section.array" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "punctuation.definition.array" },
        { "foreground": "7f5e40", "background": "803d001a", "fontStyle": "bold", "token": "punctuation.definition.constant.range" },
        { "background": "803d001a", "token": "meta.structure.array -punctuation.definition.array" },
        { "background": "803d001a", "token": "meta.definition.range -punctuation.definition.constant.range" },
        { "background": "00000080", "token": "meta.brace.curly meta.group.css" },
        { "foreground": "666666", "background": "00000080", "token": "meta.source.embedded" },
        { "foreground": "666666", "background": "00000080", "token": "entity.other.django.tagbraces" },
        { "background": "00000080", "token": "source.ruby meta.even-tab" },
        { "background": "00000080", "token": "source.ruby meta.even-tab.group2" },
        { "background": "00000080", "token": "source.ruby meta.even-tab.group4" },
        { "background": "00000080", "token": "source.ruby meta.even-tab.group6" },
        { "background": "00000080", "token": "source.ruby meta.even-tab.group8" },
        { "background": "00000080", "token": "source.ruby meta.even-tab.group10" },
        { "background": "00000080", "token": "source.ruby meta.even-tab.group12" },
        { "foreground": "666666", "token": "meta.block.slate" },
        { "foreground": "cccccc", "token": "meta.block.content.slate" },
        { "background": "0a0a0a", "token": "meta.odd-tab.group1" },
        { "background": "0a0a0a", "token": "meta.group.braces" },
        { "background": "0a0a0a", "token": "meta.block.slate" },
        { "background": "0a0a0a", "token": "text.xml.strict meta.tag" },
        { "background": "0a0a0a", "token": "meta.paren-group" },
        { "background": "0a0a0a", "token": "meta.section" },
        { "background": "0e0e0e", "token": "meta.even-tab.group2" },
        { "background": "0e0e0e", "token": "meta.group.braces meta.group.braces" },
        { "background": "0e0e0e", "token": "meta.block.slate meta.block.slate" },
        { "background": "0e0e0e", "token": "text.xml.strict meta.tag meta.tag" },
        { "background": "0e0e0e", "token": "meta.group.braces meta.group.braces" },
        { "background": "0e0e0e", "token": "meta.paren-group meta.paren-group" },
        { "background": "0e0e0e", "token": "meta.section meta.section" },
        { "background": "111111", "token": "meta.odd-tab.group3" },
        { "background": "111111", "token": "meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "111111", "token": "meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "111111", "token": "text.xml.strict meta.tag meta.tag meta.tag" },
        { "background": "111111", "token": "meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "111111", "token": "meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "111111", "token": "meta.section meta.section meta.section" },
        { "background": "151515", "token": "meta.even-tab.group4" },
        { "background": "151515", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "151515", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "151515", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag" },
        { "background": "151515", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "151515", "token": "meta.paren-group meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "151515", "token": "meta.section meta.section meta.section meta.section" },
        { "background": "191919", "token": "meta.odd-tab.group5" },
        { "background": "191919", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "191919", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "191919", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "191919", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "191919", "token": "meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "191919", "token": "meta.section meta.section meta.section meta.section meta.section" },
        { "background": "1c1c1c", "token": "meta.even-tab.group6" },
        { "background": "1c1c1c", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1c1c1c", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "1c1c1c", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "1c1c1c", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1c1c1c", "token": "meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "1c1c1c", "token": "meta.section meta.section meta.section meta.section meta.section meta.section" },
        { "background": "1f1f1f", "token": "meta.odd-tab.group7" },
        { "background": "1f1f1f", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1f1f1f", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "1f1f1f", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "1f1f1f", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1f1f1f", "token": "meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "1f1f1f", "token": "meta.section meta.section meta.section meta.section meta.section meta.section meta.section" },
        { "background": "212121", "token": "meta.even-tab.group8" },
        { "background": "212121", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "212121", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "212121", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "212121", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "212121", "token": "meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "212121", "token": "meta.section meta.section meta.section meta.section meta.section meta.section meta.section meta.section" },
        { "background": "242424", "token": "meta.odd-tab.group9" },
        { "background": "242424", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "242424", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "242424", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "242424", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "242424", "token": "meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group meta.paren-group" },
        { "background": "242424", "token": "meta.section meta.section meta.section meta.section meta.section meta.section meta.section meta.section meta.section" },
        { "background": "1f1f1f", "token": "meta.even-tab.group10" },
        { "background": "151515", "token": "meta.odd-tab.group11" },
        { "foreground": "1b95e2", "token": "meta.property.vendor.microsoft.trident.4" },
        { "foreground": "1b95e2", "token": "meta.property.vendor.microsoft.trident.4 support.type.property-name" },
        { "foreground": "1b95e2", "token": "meta.property.vendor.microsoft.trident.4 punctuation.terminator.rule" },
        { "foreground": "f5c034", "token": "meta.property.vendor.microsoft.trident.5" },
        { "foreground": "f5c034", "token": "meta.property.vendor.microsoft.trident.5 support.type.property-name" },
        { "foreground": "f5c034", "token": "meta.property.vendor.microsoft.trident.5 punctuation.separator.key-value" },
        { "foreground": "f5c034", "token": "meta.property.vendor.microsoft.trident.5 punctuation.terminator.rule" }
    ],
    "colors": {
        "editor.foreground": "#EEEEEE",
        "editor.background": "#0D0D0DFA",
        "editor.selectionBackground": "#0010B499",
        "editor.lineHighlightBackground": "#00008033",
        "editorCursor.foreground": "#3333FF",
        "editorWhitespace.foreground": "#CCCCCC1A"
    }
};
let brillianceDull = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "050505FA", "token": "" },
        { "foreground": "000000", "background": "ffffff", "fontStyle": "bold", "token": "meta.thomas_aylott" },
        { "foreground": "555555", "background": "ffffff", "fontStyle": "underline", "token": "meta.subtlegradient" },
        { "foreground": "e6e6e6", "background": "ffffff", "token": "meta.subtlegradient" },
        { "foreground": "d2d1ab", "background": "803d0033", "token": "string -meta.tag -meta.doctype -string.regexp -string.literal -string.interpolated -string.quoted.literal -string.unquoted" },
        { "foreground": "d2d1ab", "background": "803d0033", "token": "variable.parameter.misc.css" },
        { "foreground": "d2d1ab", "background": "803d0033", "token": "text string source string" },
        { "foreground": "d2d1ab", "background": "803d0033", "token": "string.unquoted string" },
        { "foreground": "d2d1ab", "background": "803d0033", "token": "string.regexp string" },
        { "foreground": "533f2c", "token": "punctuation.definition.string -meta.tag" },
        { "foreground": "fff80033", "token": "string.regexp punctuation.definition.string" },
        { "foreground": "fff80033", "token": "string.quoted.literal punctuation.definition.string" },
        { "foreground": "fff80033", "token": "string.quoted.double.ruby.mod punctuation.definition.string" },
        { "foreground": "a6a458", "background": "43800033", "token": "string.quoted.literal" },
        { "foreground": "a6a458", "background": "43800033", "token": "string.quoted.double.ruby.mod" },
        { "foreground": "d2beab", "token": "string.unquoted -string.unquoted.embedded" },
        { "foreground": "d2beab", "token": "string.quoted.double.multiline" },
        { "foreground": "d2beab", "token": "meta.scope.heredoc" },
        { "foreground": "d2d1ab", "background": "1a1a1a", "token": "string.interpolated" },
        { "foreground": "a6a458", "background": "43800033", "token": "string.regexp" },
        { "background": "43800033", "token": "string.regexp.group" },
        { "foreground": "ffffff66", "background": "43800033", "token": "string.regexp.group string.regexp.group" },
        { "foreground": "ffffff66", "background": "43800033", "token": "string.regexp.group string.regexp.group string.regexp.group" },
        { "foreground": "ffffff66", "background": "43800033", "token": "string.regexp.group string.regexp.group string.regexp.group string.regexp.group" },
        { "foreground": "80a659", "background": "43800033", "token": "string.regexp.character-class" },
        { "foreground": "56a5a4", "background": "43800033", "token": "string.regexp.arbitrary-repitition" },
        { "foreground": "a75980", "token": "source.regexp keyword.operator" },
        { "foreground": "ffffff", "fontStyle": "italic", "token": "string.regexp comment" },
        { "background": "0086ff33", "token": "meta.group.assertion.regexp" },
        { "foreground": "5780a6", "token": "meta.assertion" },
        { "foreground": "5780a6", "token": "meta.group.assertion keyword.control.group.regexp" },
        { "foreground": "95a658", "token": "constant.numeric" },
        { "foreground": "80a659", "token": "constant.character" },
        { "foreground": "59a559", "token": "constant.language" },
        { "foreground": "59a559", "token": "keyword.other.unit" },
        { "foreground": "59a559", "token": "constant.other.java" },
        { "foreground": "59a559", "token": "constant.other.unit" },
        { "foreground": "59a559", "background": "04800033", "token": "constant.language.pseudo-variable" },
        { "foreground": "57a57d", "token": "constant.other" },
        { "foreground": "57a57d", "token": "constant.block" },
        { "foreground": "56a5a4", "token": "support.constant" },
        { "foreground": "56a5a4", "token": "constant.name" },
        { "foreground": "5e6b6b", "token": "variable.language" },
        { "foreground": "5e6b6b", "token": "variable.other.readwrite.global.pre-defined" },
        { "foreground": "56a5a4", "token": "variable.other.constant" },
        { "foreground": "56a5a4", "background": "00807c33", "token": "support.variable" },
        { "foreground": "2b5252", "background": "00438033", "token": "variable.other.readwrite.global" },
        { "foreground": "5780a6", "token": "variable.other" },
        { "foreground": "5780a6", "token": "variable.js" },
        { "foreground": "5780a6", "background": "0007ff33", "token": "variable.other.readwrite.class" },
        { "foreground": "555f69", "token": "variable.other.readwrite.instance" },
        { "foreground": "555f69", "token": "variable.other.php" },
        { "foreground": "555f69", "token": "variable.other.normal" },
        { "foreground": "00000080", "token": "punctuation.definition -punctuation.definition.comment" },
        { "foreground": "00000080", "token": "punctuation.separator.variable" },
        { "foreground": "a77d58", "token": "storage -storage.modifier" },
        { "background": "803d0033", "token": "other.preprocessor" },
        { "background": "803d0033", "token": "entity.name.preprocessor" },
        { "foreground": "666666", "token": "variable.language.this.js" },
        { "foreground": "533f2c", "token": "storage.modifier" },
        { "foreground": "a7595a", "token": "entity.name.class" },
        { "foreground": "a7595a", "token": "entity.name.type.class" },
        { "foreground": "a7595a", "token": "entity.name.type.module" },
        { "foreground": "532d2d", "background": "29161780", "token": "meta.class -meta.class.instance" },
        { "foreground": "532d2d", "background": "29161780", "token": "declaration.class" },
        { "foreground": "532d2d", "background": "29161780", "token": "meta.definition.class" },
        { "foreground": "532d2d", "background": "29161780", "token": "declaration.module" },
        { "foreground": "a7595a", "background": "80000433", "token": "support.type" },
        { "foreground": "a7595a", "background": "80000433", "token": "support.class" },
        { "foreground": "a7595a", "token": "entity.name.instance" },
        { "background": "80004333", "token": "meta.class.instance.constructor" },
        { "foreground": "a75980", "background": "80000433", "token": "entity.other.inherited-class" },
        { "foreground": "a75980", "background": "80000433", "token": "entity.name.module" },
        { "foreground": "a75980", "token": "object.property.function" },
        { "foreground": "a75980", "token": "meta.definition.method" },
        { "foreground": "532d40", "background": "80004333", "token": "meta.function -(meta.tell-block)" },
        { "foreground": "532d40", "background": "80004333", "token": "meta.property.function" },
        { "foreground": "532d40", "background": "80004333", "token": "declaration.function" },
        { "foreground": "a75980", "token": "entity.name.function" },
        { "foreground": "a75980", "token": "entity.name.preprocessor" },
        { "foreground": "a459a5", "token": "keyword" },
        { "foreground": "a459a5", "background": "3c008033", "token": "keyword.control" },
        { "foreground": "8d809d", "token": "keyword.other.special-method" },
        { "foreground": "8d809d", "token": "meta.function-call entity.name.function -(meta.function-call meta.function)" },
        { "foreground": "8d809d", "token": "support.function - variable" },
        { "foreground": "634683", "token": "support.function - variable" },
        { "foreground": "7979b7", "fontStyle": "bold", "token": "keyword.operator" },
        { "foreground": "7979b7", "fontStyle": "bold", "token": "declaration.function.operator" },
        { "foreground": "7979b7", "fontStyle": "bold", "token": "meta.preprocessor.c.include" },
        { "foreground": "9899c8", "token": "keyword.operator.comparison" },
        { "foreground": "abacd2", "background": "3c008033", "token": "variable.parameter -variable.parameter.misc.css" },
        { "foreground": "abacd2", "background": "3c008033", "token": "meta.definition.method  meta.definition.param-list" },
        { "foreground": "abacd2", "background": "3c008033", "token": "meta.function.method.with-arguments variable.parameter.function" },
        { "foreground": "cdcdcd", "background": "333333", "token": "meta.doctype" },
        { "foreground": "cdcdcd", "background": "333333", "token": "meta.tag.sgml-declaration.doctype" },
        { "foreground": "cdcdcd", "background": "333333", "token": "meta.tag.sgml.doctype" },
        { "foreground": "333333", "token": "meta.tag" },
        { "foreground": "666666", "background": "333333bf", "token": "meta.tag.structure" },
        { "foreground": "666666", "background": "333333bf", "token": "meta.tag.segment" },
        { "foreground": "4c4c4c", "background": "4c4c4c33", "token": "meta.tag.block" },
        { "foreground": "4c4c4c", "background": "4c4c4c33", "token": "meta.tag.xml" },
        { "foreground": "4c4c4c", "background": "4c4c4c33", "token": "meta.tag.key" },
        { "foreground": "a77d58", "background": "803d0033", "token": "meta.tag.inline" },
        { "background": "803d0033", "token": "meta.tag.inline source" },
        { "foreground": "a7595a", "background": "80000433", "token": "meta.tag.other" },
        { "foreground": "a7595a", "background": "80000433", "token": "entity.name.tag.style" },
        { "foreground": "a7595a", "background": "80000433", "token": "source entity.other.attribute-name -text.html.basic.embedded" },
        { "foreground": "a7595a", "background": "80000433", "token": "entity.name.tag.script" },
        { "foreground": "a7595a", "background": "80000433", "token": "meta.tag.block.script" },
        { "foreground": "5780a6", "background": "00438033", "token": "meta.tag.form" },
        { "foreground": "5780a6", "background": "00438033", "token": "meta.tag.block.form" },
        { "foreground": "a459a5", "background": "3c008033", "token": "meta.tag.meta" },
        { "background": "121212", "token": "meta.section.html.head" },
        { "background": "0043801a", "token": "meta.section.html.form" },
        { "foreground": "666666", "token": "meta.tag.xml" },
        { "foreground": "ffffff4d", "token": "entity.name.tag" },
        { "foreground": "ffffff33", "token": "entity.other.attribute-name" },
        { "foreground": "ffffff33", "token": "meta.tag punctuation.definition.string" },
        { "foreground": "ffffff66", "token": "meta.tag string -source -punctuation" },
        { "foreground": "ffffff66", "token": "text source text meta.tag string -punctuation" },
        { "foreground": "a6a458", "background": "33333333", "token": "markup markup -(markup meta.paragraph.list)" },
        { "foreground": "000000", "background": "ffffff", "token": "markup.hr" },
        { "foreground": "666666", "background": "33333380", "token": "markup.heading" },
        { "fontStyle": "bold", "token": "markup.bold" },
        { "fontStyle": "italic", "token": "markup.italic" },
        { "fontStyle": "underline", "token": "markup.underline" },
        { "foreground": "5780a6", "token": "meta.reference" },
        { "foreground": "5780a6", "token": "markup.underline.link" },
        { "foreground": "56a5a4", "background": "00438033", "token": "entity.name.reference" },
        { "foreground": "56a5a4", "fontStyle": "underline", "token": "meta.reference.list markup.underline.link" },
        { "foreground": "56a5a4", "fontStyle": "underline", "token": "text.html.textile markup.underline.link" },
        { "foreground": "999999", "background": "000000", "token": "markup.raw.block" },
        { "background": "ffffff1a", "token": "markup.quote" },
        { "foreground": "666666", "background": "00000080", "token": "meta.selector" },
        { "foreground": "575aa6", "background": "00048033", "token": "meta.attribute-match.css" },
        { "foreground": "7c58a5", "token": "entity.other.attribute-name.pseudo-class" },
        { "foreground": "7c58a5", "token": "entity.other.attribute-name.tag.pseudo-class" },
        { "foreground": "a459a5", "token": "meta.selector entity.other.attribute-name.class" },
        { "foreground": "a75980", "token": "meta.selector entity.other.attribute-name.id" },
        { "foreground": "a7595a", "token": "meta.selector entity.name.tag" },
        { "foreground": "a77d58", "fontStyle": "bold", "token": "entity.name.tag.wildcard" },
        { "foreground": "a77d58", "fontStyle": "bold", "token": "entity.other.attribute-name.universal" },
        { "foreground": "333333", "fontStyle": "bold", "token": "meta.scope.property-list" },
        { "foreground": "999999", "token": "meta.property-name" },
        { "foreground": "ffffff", "background": "000000", "token": "support.type.property-name" },
        { "foreground": "999999", "background": "0d0d0d", "token": "meta.property-value" },
        { "background": "000000", "token": "text.latex markup.raw" },
        { "foreground": "bdabd1", "token": "text.latex support.function -support.function.textit -support.function.emph" },
        { "foreground": "ffffffbf", "token": "text.latex support.function.section" },
        { "foreground": "000000", "background": "ffffff", "token": "text.latex entity.name.section -meta.group -keyword.operator.braces" },
        { "background": "00000080", "token": "text.latex keyword.operator.delimiter" },
        { "foreground": "999999", "token": "text.latex keyword.operator.brackets" },
        { "foreground": "666666", "token": "text.latex keyword.operator.braces" },
        { "foreground": "0008ff4d", "background": "00048033", "token": "meta.footnote" },
        { "background": "ffffff0d", "token": "text.latex meta.label.reference" },
        { "foreground": "a7595a", "background": "180d0c", "token": "text.latex keyword.control.ref" },
        { "foreground": "d2beab", "background": "291616", "token": "text.latex variable.parameter.label.reference" },
        { "foreground": "a75980", "background": "180d12", "token": "text.latex keyword.control.cite" },
        { "foreground": "e8d5de", "background": "29161f", "token": "variable.parameter.cite" },
        { "foreground": "ffffff80", "token": "text.latex variable.parameter.label" },
        { "foreground": "33333333", "token": "text.latex meta.group.braces" },
        { "foreground": "33333333", "background": "00000080", "token": "text.latex meta.environment.list" },
        { "foreground": "33333333", "background": "00000080", "token": "text.latex meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "background": "000000", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "33333333", "token": "text.latex meta.environment.list meta.environment.list meta.environment.list meta.environment.list meta.environment.list meta.environment.list" },
        { "foreground": "000000", "background": "cdcdcd", "token": "text.latex meta.end-document" },
        { "foreground": "000000", "background": "cdcdcd", "token": "text.latex meta.begin-document" },
        { "foreground": "000000", "background": "cdcdcd", "token": "meta.end-document.latex support.function" },
        { "foreground": "000000", "background": "cdcdcd", "token": "meta.end-document.latex variable.parameter" },
        { "foreground": "000000", "background": "cdcdcd", "token": "meta.begin-document.latex support.function" },
        { "foreground": "000000", "background": "cdcdcd", "token": "meta.begin-document.latex variable.parameter" },
        { "foreground": "596b61", "background": "45815d33", "token": "meta.brace.erb.return-value" },
        { "background": "66666633", "token": "source.ruby.rails.embedded.return-value.one-line" },
        { "foreground": "56a5a4", "background": "00fff81a", "token": "punctuation.section.embedded -(source string source punctuation.section.embedded)" },
        { "foreground": "56a5a4", "background": "00fff81a", "token": "meta.brace.erb.html" },
        { "background": "00fff81a", "token": "source.ruby.rails.embedded.one-line" },
        { "foreground": "555f69", "token": "source string source punctuation.section.embedded" },
        { "background": "000000", "token": "source" },
        { "background": "000000", "token": "meta.brace.erb" },
        { "foreground": "ffffff", "background": "33333380", "token": "source string source" },
        { "foreground": "999999", "background": "00000099", "token": "source string.interpolated source" },
        { "background": "3333331a", "token": "source.java.embedded" },
        { "foreground": "ffffff", "token": "text -text.xml.strict" },
        { "foreground": "cccccc", "background": "000000", "token": "text source" },
        { "foreground": "cccccc", "background": "000000", "token": "meta.scope.django.template" },
        { "foreground": "999999", "token": "text string source" },
        { "foreground": "333333", "token": "meta.syntax" },
        { "foreground": "211211", "background": "a7595a", "fontStyle": "bold", "token": "invalid" },
        { "foreground": "8f8fc3", "background": "0000ff1a", "fontStyle": "italic", "token": "0comment" },
        { "foreground": "0000ff1a", "fontStyle": "bold", "token": "comment punctuation" },
        { "foreground": "333333", "token": "comment" },
        { "foreground": "262626", "background": "8080800d", "fontStyle": "bold italic", "token": "comment punctuation" },
        { "fontStyle": "italic", "token": "text comment.block -source" },
        { "foreground": "81bb9e", "background": "15281f", "token": "markup.inserted" },
        { "foreground": "bc839f", "background": "400021", "token": "markup.deleted" },
        { "foreground": "c3c38f", "background": "533f2c", "token": "markup.changed" },
        { "foreground": "ffffff", "background": "000000", "token": "text.subversion-commit meta.scope.changed-files" },
        { "foreground": "ffffff", "background": "000000", "token": "text.subversion-commit meta.scope.changed-files.svn meta.diff.separator" },
        { "foreground": "000000", "background": "ffffff", "token": "text.subversion-commit" },
        { "foreground": "ffffff", "background": "ffffff03", "fontStyle": "bold", "token": "punctuation.terminator" },
        { "foreground": "ffffff", "background": "ffffff03", "fontStyle": "bold", "token": "meta.delimiter" },
        { "foreground": "ffffff", "background": "ffffff03", "fontStyle": "bold", "token": "punctuation.separator.method" },
        { "background": "000000bf", "token": "punctuation.terminator.statement" },
        { "background": "000000bf", "token": "meta.delimiter.statement.js" },
        { "background": "00000040", "token": "meta.delimiter.object.js" },
        { "foreground": "533f2c", "fontStyle": "bold", "token": "string.quoted.single.brace" },
        { "foreground": "533f2c", "fontStyle": "bold", "token": "string.quoted.double.brace" },
        { "background": "ffffff", "token": "text.blog -(text.blog text)" },
        { "foreground": "666666", "background": "ffffff", "token": "meta.headers.blog" },
        { "foreground": "192b2a", "background": "00fff81a", "token": "meta.headers.blog keyword.other.blog" },
        { "foreground": "533f2c", "background": "ffff551a", "token": "meta.headers.blog string.unquoted.blog" },
        { "foreground": "4c4c4c", "background": "33333333", "token": "meta.brace.pipe" },
        { "foreground": "4c4c4c", "fontStyle": "bold", "token": "meta.brace.erb" },
        { "foreground": "4c4c4c", "fontStyle": "bold", "token": "source.ruby.embedded.source.brace" },
        { "foreground": "4c4c4c", "fontStyle": "bold", "token": "punctuation.section.dictionary" },
        { "foreground": "4c4c4c", "fontStyle": "bold", "token": "punctuation.terminator.dictionary" },
        { "foreground": "4c4c4c", "fontStyle": "bold", "token": "punctuation.separator.object" },
        { "foreground": "ffffff", "fontStyle": "bold", "token": "meta.group.braces.curly punctuation.section.scope" },
        { "foreground": "ffffff", "fontStyle": "bold", "token": "meta.brace.curly" },
        { "foreground": "345743", "fontStyle": "bold", "token": "punctuation.separator.objects" },
        { "foreground": "345743", "fontStyle": "bold", "token": "meta.group.braces.curly meta.delimiter.object.comma" },
        { "foreground": "345743", "fontStyle": "bold", "token": "punctuation.separator.key-value -meta.tag" },
        { "foreground": "695f55", "background": "803d001a", "fontStyle": "bold", "token": "meta.group.braces.square punctuation.section.scope" },
        { "foreground": "695f55", "background": "803d001a", "fontStyle": "bold", "token": "meta.group.braces.square meta.delimiter.object.comma" },
        { "foreground": "695f55", "background": "803d001a", "fontStyle": "bold", "token": "meta.brace.square" },
        { "foreground": "695f55", "background": "803d001a", "fontStyle": "bold", "token": "punctuation.separator.array" },
        { "foreground": "695f55", "background": "803d001a", "fontStyle": "bold", "token": "punctuation.section.array" },
        { "foreground": "cdcdcd", "background": "00000080", "token": "meta.brace.curly meta.group" },
        { "foreground": "532d40", "fontStyle": "bold", "token": "meta.group.braces.round punctuation.section.scope" },
        { "foreground": "532d40", "fontStyle": "bold", "token": "meta.group.braces.round meta.delimiter.object.comma" },
        { "foreground": "532d40", "fontStyle": "bold", "token": "meta.brace.round" },
        { "foreground": "abacd2", "background": "3c008033", "token": "punctuation.section.function" },
        { "foreground": "abacd2", "background": "3c008033", "token": "meta.brace.curly.function" },
        { "foreground": "abacd2", "background": "3c008033", "token": "meta.function-call punctuation.section.scope.ruby" },
        { "foreground": "666666", "background": "00000080", "token": "meta.source.embedded" },
        { "foreground": "666666", "background": "00000080", "token": "entity.other.django.tagbraces" },
        { "background": "0a0a0a", "token": "meta.odd-tab.group1" },
        { "background": "0a0a0a", "token": "meta.group.braces" },
        { "background": "0a0a0a", "token": "meta.block.slate" },
        { "background": "0a0a0a", "token": "text.xml.strict meta.tag" },
        { "background": "0a0a0a", "token": "meta.tell-block meta.tell-block" },
        { "background": "0e0e0e", "token": "meta.even-tab.group2" },
        { "background": "0e0e0e", "token": "meta.group.braces meta.group.braces" },
        { "background": "0e0e0e", "token": "meta.block.slate meta.block.slate" },
        { "background": "0e0e0e", "token": "text.xml.strict meta.tag meta.tag" },
        { "background": "0e0e0e", "token": "meta.group.braces meta.group.braces" },
        { "background": "0e0e0e", "token": "meta.tell-block meta.tell-block" },
        { "background": "111111", "token": "meta.odd-tab.group3" },
        { "background": "111111", "token": "meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "111111", "token": "meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "111111", "token": "text.xml.strict meta.tag meta.tag meta.tag" },
        { "background": "111111", "token": "meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "111111", "token": "meta.tell-block meta.tell-block meta.tell-block" },
        { "background": "151515", "token": "meta.even-tab.group4" },
        { "background": "151515", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "151515", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "151515", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag" },
        { "background": "151515", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "151515", "token": "meta.tell-block meta.tell-block meta.tell-block meta.tell-block" },
        { "background": "191919", "token": "meta.odd-tab.group5" },
        { "background": "191919", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "191919", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "191919", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "191919", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "191919", "token": "meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block" },
        { "background": "1c1c1c", "token": "meta.even-tab.group6" },
        { "background": "1c1c1c", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1c1c1c", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "1c1c1c", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "1c1c1c", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1c1c1c", "token": "meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block" },
        { "background": "1f1f1f", "token": "meta.odd-tab.group7" },
        { "background": "1f1f1f", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1f1f1f", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "1f1f1f", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "1f1f1f", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "1f1f1f", "token": "meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block" },
        { "background": "212121", "token": "meta.even-tab.group8" },
        { "background": "212121", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "212121", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "212121", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "212121", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "212121", "token": "meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block" },
        { "background": "242424", "token": "meta.odd-tab.group11" },
        { "background": "242424", "token": "meta.odd-tab.group10" },
        { "background": "242424", "token": "meta.odd-tab.group9" },
        { "background": "242424", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "242424", "token": "meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate meta.block.slate" },
        { "background": "242424", "token": "text.xml.strict meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag meta.tag" },
        { "background": "242424", "token": "meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces meta.group.braces" },
        { "background": "242424", "token": "meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block meta.tell-block" },
        { "foreground": "666666", "token": "meta.block.slate" },
        { "foreground": "cdcdcd", "token": "meta.block.content.slate" }
    ],
    "colors": {
        "editor.foreground": "#CDCDCD",
        "editor.background": "#050505FA",
        "editor.selectionBackground": "#2E2EE64D",
        "editor.lineHighlightBackground": "#0000801A",
        "editorCursor.foreground": "#7979B7",
        "editorWhitespace.foreground": "#CDCDCD1A"
    }
};
let chromeDevTools = {
    "base": "vs",
    "inherit": true,
    "rules": [
        { "background": "FFFFFF", "token": "" },
        { "foreground": "c41a16", "token": "string" },
        { "foreground": "1c00cf", "token": "constant.numeric" },
        { "foreground": "aa0d91", "token": "keyword" },
        { "foreground": "000000", "token": "keyword.operator" },
        { "foreground": "aa0d91", "token": "constant.language" },
        { "foreground": "990000", "token": "support.class.exception" },
        { "foreground": "000000", "token": "entity.name.function" },
        { "fontStyle": "bold underline", "token": "entity.name.type" },
        { "fontStyle": "italic", "token": "variable.parameter" },
        { "foreground": "007400", "token": "comment" },
        { "foreground": "ff0000", "token": "invalid" },
        { "background": "e71a1100", "token": "invalid.deprecated.trailing-whitespace" },
        { "foreground": "000000", "background": "fafafafc", "token": "text source" },
        { "foreground": "aa0d91", "token": "meta.tag" },
        { "foreground": "aa0d91", "token": "declaration.tag" },
        { "foreground": "000000", "fontStyle": "bold", "token": "support" },
        { "foreground": "aa0d91", "token": "storage" },
        { "fontStyle": "bold underline", "token": "entity.name.section" },
        { "foreground": "000000", "fontStyle": "bold", "token": "entity.name.function.frame" },
        { "foreground": "333333", "token": "meta.tag.preprocessor.xml" },
        { "foreground": "994500", "fontStyle": "italic", "token": "entity.other.attribute-name" },
        { "foreground": "881280", "token": "entity.name.tag" }
    ],
    "colors": {
        "editor.foreground": "#000000",
        "editor.background": "#FFFFFF",
        "editor.selectionBackground": "#BAD6FD",
        "editor.lineHighlightBackground": "#0000001A",
        "editorCursor.foreground": "#000000",
        "editorWhitespace.foreground": "#B3B3B3F4"
    }
};
let cloudsMidnight = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "191919", "token": "" },
        { "foreground": "3c403b", "token": "comment" },
        { "foreground": "5d90cd", "token": "string" },
        { "foreground": "46a609", "token": "constant.numeric" },
        { "foreground": "39946a", "token": "constant.language" },
        { "foreground": "927c5d", "token": "keyword" },
        { "foreground": "927c5d", "token": "support.constant.property-value" },
        { "foreground": "927c5d", "token": "constant.other.color" },
        { "foreground": "366f1a", "token": "keyword.other.unit" },
        { "foreground": "a46763", "token": "entity.other.attribute-name.html" },
        { "foreground": "4b4b4b", "token": "keyword.operator" },
        { "foreground": "e92e2e", "token": "storage" },
        { "foreground": "858585", "token": "entity.other.inherited-class" },
        { "foreground": "606060", "token": "entity.name.tag" },
        { "foreground": "a165ac", "token": "constant.character.entity" },
        { "foreground": "a165ac", "token": "support.class.js" },
        { "foreground": "606060", "token": "entity.other.attribute-name" },
        { "foreground": "e92e2e", "token": "meta.selector.css" },
        { "foreground": "e92e2e", "token": "entity.name.tag.css" },
        { "foreground": "e92e2e", "token": "entity.other.attribute-name.id.css" },
        { "foreground": "e92e2e", "token": "entity.other.attribute-name.class.css" },
        { "foreground": "616161", "token": "meta.property-name.css" },
        { "foreground": "e92e2e", "token": "support.function" },
        { "foreground": "ffffff", "background": "e92e2e", "token": "invalid" },
        { "foreground": "e92e2e", "token": "punctuation.section.embedded" },
        { "foreground": "606060", "token": "punctuation.definition.tag" },
        { "foreground": "a165ac", "token": "constant.other.color.rgb-value.css" },
        { "foreground": "a165ac", "token": "support.constant.property-value.css" }
    ],
    "colors": {
        "editor.foreground": "#929292",
        "editor.background": "#191919",
        "editor.selectionBackground": "#000000",
        "editor.lineHighlightBackground": "#D7D7D708",
        "editorCursor.foreground": "#7DA5DC",
        "editorWhitespace.foreground": "#BFBFBF"
    }
};
let clouds = {
    "base": "vs",
    "inherit": true,
    "rules": [
        { "background": "FFFFFF", "token": "" },
        { "foreground": "bcc8ba", "token": "comment" },
        { "foreground": "5d90cd", "token": "string" },
        { "foreground": "46a609", "token": "constant.numeric" },
        { "foreground": "39946a", "token": "constant.language" },
        { "foreground": "af956f", "token": "keyword" },
        { "foreground": "af956f", "token": "support.constant.property-value" },
        { "foreground": "af956f", "token": "constant.other.color" },
        { "foreground": "96dc5f", "token": "keyword.other.unit" },
        { "foreground": "484848", "token": "keyword.operator" },
        { "foreground": "c52727", "token": "storage" },
        { "foreground": "858585", "token": "entity.other.inherited-class" },
        { "foreground": "606060", "token": "entity.name.tag" },
        { "foreground": "bf78cc", "token": "constant.character.entity" },
        { "foreground": "bf78cc", "token": "support.class.js" },
        { "foreground": "606060", "token": "entity.other.attribute-name" },
        { "foreground": "c52727", "token": "meta.selector.css" },
        { "foreground": "c52727", "token": "entity.name.tag.css" },
        { "foreground": "c52727", "token": "entity.other.attribute-name.id.css" },
        { "foreground": "c52727", "token": "entity.other.attribute-name.class.css" },
        { "foreground": "484848", "token": "meta.property-name.css" },
        { "foreground": "c52727", "token": "support.function" },
        { "background": "ff002a", "token": "invalid" },
        { "foreground": "c52727", "token": "punctuation.section.embedded" },
        { "foreground": "606060", "token": "punctuation.definition.tag" },
        { "foreground": "bf78cc", "token": "constant.other.color.rgb-value.css" },
        { "foreground": "bf78cc", "token": "support.constant.property-value.css" }
    ],
    "colors": {
        "editor.foreground": "#000000",
        "editor.background": "#FFFFFF",
        "editor.selectionBackground": "#BDD5FC",
        "editor.lineHighlightBackground": "#FFFBD1",
        "editorCursor.foreground": "#000000",
        "editorWhitespace.foreground": "#BFBFBF"
    }
};
let cobalt = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "002240", "token": "" },
        { "foreground": "e1efff", "token": "punctuation - (punctuation.definition.string || punctuation.definition.comment)" },
        { "foreground": "ff628c", "token": "constant" },
        { "foreground": "ffdd00", "token": "entity" },
        { "foreground": "ff9d00", "token": "keyword" },
        { "foreground": "ffee80", "token": "storage" },
        { "foreground": "3ad900", "token": "string -string.unquoted.old-plist -string.unquoted.heredoc" },
        { "foreground": "3ad900", "token": "string.unquoted.heredoc string" },
        { "foreground": "0088ff", "fontStyle": "italic", "token": "comment" },
        { "foreground": "80ffbb", "token": "support" },
        { "foreground": "cccccc", "token": "variable" },
        { "foreground": "ff80e1", "token": "variable.language" },
        { "foreground": "ffee80", "token": "meta.function-call" },
        { "foreground": "f8f8f8", "background": "800f00", "token": "invalid" },
        { "foreground": "ffffff", "background": "223545", "token": "text source" },
        { "foreground": "ffffff", "background": "223545", "token": "string.unquoted.heredoc" },
        { "foreground": "ffffff", "background": "223545", "token": "source source" },
        { "foreground": "80fcff", "fontStyle": "italic", "token": "entity.other.inherited-class" },
        { "foreground": "9eff80", "token": "string.quoted source" },
        { "foreground": "80ff82", "token": "string constant" },
        { "foreground": "80ffc2", "token": "string.regexp" },
        { "foreground": "edef7d", "token": "string variable" },
        { "foreground": "ffb054", "token": "support.function" },
        { "foreground": "eb939a", "token": "support.constant" },
        { "foreground": "ff1e00", "token": "support.type.exception" },
        { "foreground": "8996a8", "token": "meta.preprocessor.c" },
        { "foreground": "afc4db", "token": "meta.preprocessor.c keyword" },
        { "foreground": "73817d", "token": "meta.sgml.html meta.doctype" },
        { "foreground": "73817d", "token": "meta.sgml.html meta.doctype entity" },
        { "foreground": "73817d", "token": "meta.sgml.html meta.doctype string" },
        { "foreground": "73817d", "token": "meta.xml-processing" },
        { "foreground": "73817d", "token": "meta.xml-processing entity" },
        { "foreground": "73817d", "token": "meta.xml-processing string" },
        { "foreground": "9effff", "token": "meta.tag" },
        { "foreground": "9effff", "token": "meta.tag entity" },
        { "foreground": "9effff", "token": "meta.selector.css entity.name.tag" },
        { "foreground": "ffb454", "token": "meta.selector.css entity.other.attribute-name.id" },
        { "foreground": "5fe461", "token": "meta.selector.css entity.other.attribute-name.class" },
        { "foreground": "9df39f", "token": "support.type.property-name.css" },
        { "foreground": "f6f080", "token": "meta.property-group support.constant.property-value.css" },
        { "foreground": "f6f080", "token": "meta.property-value support.constant.property-value.css" },
        { "foreground": "f6aa11", "token": "meta.preprocessor.at-rule keyword.control.at-rule" },
        { "foreground": "edf080", "token": "meta.property-value support.constant.named-color.css" },
        { "foreground": "edf080", "token": "meta.property-value constant" },
        { "foreground": "eb939a", "token": "meta.constructor.argument.css" },
        { "foreground": "f8f8f8", "background": "000e1a", "token": "meta.diff" },
        { "foreground": "f8f8f8", "background": "000e1a", "token": "meta.diff.header" },
        { "foreground": "f8f8f8", "background": "4c0900", "token": "markup.deleted" },
        { "foreground": "f8f8f8", "background": "806f00", "token": "markup.changed" },
        { "foreground": "f8f8f8", "background": "154f00", "token": "markup.inserted" },
        { "background": "8fddf630", "token": "markup.raw" },
        { "background": "004480", "token": "markup.quote" },
        { "background": "130d26", "token": "markup.list" },
        { "foreground": "c1afff", "fontStyle": "bold", "token": "markup.bold" },
        { "foreground": "b8ffd9", "fontStyle": "italic", "token": "markup.italic" },
        { "foreground": "c8e4fd", "background": "001221", "fontStyle": "bold", "token": "markup.heading" }
    ],
    "colors": {
        "editor.foreground": "#FFFFFF",
        "editor.background": "#002240",
        "editor.selectionBackground": "#B36539BF",
        "editor.lineHighlightBackground": "#00000059",
        "editorCursor.foreground": "#FFFFFF",
        "editorWhitespace.foreground": "#FFFFFF26"
    }
};
let dracula = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "282a36", "token": "" },
        { "foreground": "6272a4", "token": "comment" },
        { "foreground": "f1fa8c", "token": "string" },
        { "foreground": "bd93f9", "token": "constant.numeric" },
        { "foreground": "bd93f9", "token": "constant.language" },
        { "foreground": "bd93f9", "token": "constant.character" },
        { "foreground": "bd93f9", "token": "constant.other" },
        { "foreground": "ffb86c", "token": "variable.other.readwrite.instance" },
        { "foreground": "ff79c6", "token": "constant.character.escaped" },
        { "foreground": "ff79c6", "token": "constant.character.escape" },
        { "foreground": "ff79c6", "token": "string source" },
        { "foreground": "ff79c6", "token": "string source.ruby" },
        { "foreground": "ff79c6", "token": "keyword" },
        { "foreground": "ff79c6", "token": "storage" },
        { "foreground": "8be9fd", "fontStyle": "italic", "token": "storage.type" },
        { "foreground": "50fa7b", "fontStyle": "underline", "token": "entity.name.class" },
        { "foreground": "50fa7b", "fontStyle": "italic underline", "token": "entity.other.inherited-class" },
        { "foreground": "50fa7b", "token": "entity.name.function" },
        { "foreground": "ffb86c", "fontStyle": "italic", "token": "variable.parameter" },
        { "foreground": "ff79c6", "token": "entity.name.tag" },
        { "foreground": "50fa7b", "token": "entity.other.attribute-name" },
        { "foreground": "8be9fd", "token": "support.function" },
        { "foreground": "6be5fd", "token": "support.constant" },
        { "foreground": "66d9ef", "fontStyle": " italic", "token": "support.type" },
        { "foreground": "66d9ef", "fontStyle": " italic", "token": "support.class" },
        { "foreground": "f8f8f0", "background": "ff79c6", "token": "invalid" },
        { "foreground": "f8f8f0", "background": "bd93f9", "token": "invalid.deprecated" },
        { "foreground": "cfcfc2", "token": "meta.structure.dictionary.json string.quoted.double.json" },
        { "foreground": "6272a4", "token": "meta.diff" },
        { "foreground": "6272a4", "token": "meta.diff.header" },
        { "foreground": "ff79c6", "token": "markup.deleted" },
        { "foreground": "50fa7b", "token": "markup.inserted" },
        { "foreground": "e6db74", "token": "markup.changed" },
        { "foreground": "bd93f9", "token": "constant.numeric.line-number.find-in-files - match" },
        { "foreground": "e6db74", "token": "entity.name.filename" },
        { "foreground": "f83333", "token": "message.error" },
        { "foreground": "eeeeee", "token": "punctuation.definition.string.begin.json - meta.structure.dictionary.value.json" },
        { "foreground": "eeeeee", "token": "punctuation.definition.string.end.json - meta.structure.dictionary.value.json" },
        { "foreground": "8be9fd", "token": "meta.structure.dictionary.json string.quoted.double.json" },
        { "foreground": "f1fa8c", "token": "meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "50fa7b", "token": "meta meta meta meta meta meta meta.structure.dictionary.value string" },
        { "foreground": "ffb86c", "token": "meta meta meta meta meta meta.structure.dictionary.value string" },
        { "foreground": "ff79c6", "token": "meta meta meta meta meta.structure.dictionary.value string" },
        { "foreground": "bd93f9", "token": "meta meta meta meta.structure.dictionary.value string" },
        { "foreground": "50fa7b", "token": "meta meta meta.structure.dictionary.value string" },
        { "foreground": "ffb86c", "token": "meta meta.structure.dictionary.value string" }
    ],
    "colors": {
        "editor.foreground": "#f8f8f2",
        "editor.background": "#282a36",
        "editor.selectionBackground": "#44475a",
        "editor.lineHighlightBackground": "#44475a",
        "editorCursor.foreground": "#f8f8f0",
        "editorWhitespace.foreground": "#3B3A32",
        "editorIndentGuide.activeBackground": "#9D550FB0",
        "editor.selectionHighlightBorder": "#222218"
    }
};
let dreamweaver = {
    "base": "vs",
    "inherit": true,
    "rules": [
        { "background": "FFFFFF", "token": "" },
        { "foreground": "000000", "token": "text" },
        { "foreground": "ee000b", "token": "constant.numeric - source.css" },
        { "foreground": "9a9a9a", "token": "comment" },
        { "foreground": "00359e", "token": "text.html meta.tag" },
        { "foreground": "001eff", "token": "text.html.basic meta.tag string.quoted - source" },
        { "foreground": "000000", "fontStyle": "bold", "token": "text.html.basic constant.character.entity.html" },
        { "foreground": "106800", "token": "text.html meta.tag.a - string" },
        { "foreground": "6d232e", "token": "text.html meta.tag.img - string" },
        { "foreground": "ff9700", "token": "text.html meta.tag.form - string" },
        { "foreground": "009079", "token": "text.html meta.tag.table - string" },
        { "foreground": "842b44", "token": "source.js.embedded.html punctuation.definition.tag - source.php" },
        { "foreground": "842b44", "token": "source.js.embedded.html entity.name.tag.script" },
        { "foreground": "842b44", "token": "source.js.embedded entity.other.attribute-name - source.js string" },
        { "foreground": "9a9a9a", "token": "source.js comment - source.php" },
        { "foreground": "000000", "token": "source.js meta.function - source.php" },
        { "foreground": "24c696", "token": "source.js meta.class - source.php" },
        { "foreground": "24c696", "token": "source.js support.function - source.php" },
        { "foreground": "0035ff", "token": "source.js string - source.php" },
        { "foreground": "0035ff", "token": "source.js keyword.operator" },
        { "foreground": "7e00b7", "token": "source.js support.class" },
        { "foreground": "000000", "fontStyle": "bold", "token": "source.js storage" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js storage - storage.type.function - source.php" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js constant - source.php" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js keyword - source.php" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js variable.language" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js meta.brace" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js punctuation.definition.parameters.begin" },
        { "foreground": "05208c", "fontStyle": "bold", "token": "source.js punctuation.definition.parameters.end" },
        { "foreground": "106800", "token": "source.js string.regexp" },
        { "foreground": "106800", "token": "source.js string.regexp constant" },
        { "foreground": "8d00b7", "token": "source.css.embedded.html punctuation.definition.tag" },
        { "foreground": "8d00b7", "token": "source.css.embedded.html entity.name.tag.style" },
        { "foreground": "8d00b7", "token": "source.css.embedded entity.other.attribute-name - meta.selector" },
        { "foreground": "009c7f", "fontStyle": "bold", "token": "source.css meta.at-rule.import.css" },
        { "foreground": "ee000b", "fontStyle": "bold", "token": "source.css keyword.other.important" },
        { "foreground": "430303", "fontStyle": "bold", "token": "source.css meta.at-rule.media" },
        { "foreground": "106800", "token": "source.css string" },
        { "foreground": "da29ff", "token": "source.css meta.selector" },
        { "foreground": "da29ff", "token": "source.css meta.property-list" },
        { "foreground": "da29ff", "token": "source.css meta.at-rule" },
        { "foreground": "da29ff", "fontStyle": "bold", "token": "source.css punctuation.separator - source.php" },
        { "foreground": "da29ff", "fontStyle": "bold", "token": "source.css punctuation.terminator - source.php" },
        { "foreground": "05208c", "token": "source.css meta.property-name" },
        { "foreground": "0035ff", "token": "source.css meta.property-value" },
        { "foreground": "ee000b", "fontStyle": "bold", "token": "source.php punctuation.section.embedded.begin" },
        { "foreground": "ee000b", "fontStyle": "bold", "token": "source.php punctuation.section.embedded.end" },
        { "foreground": "000000", "token": "source.php - punctuation.section" },
        { "foreground": "000000", "token": "source.php variable" },
        { "foreground": "000000", "token": "source.php meta.function.arguments" },
        { "foreground": "05208c", "token": "source.php punctuation - string - variable - meta.function" },
        { "foreground": "24bf96", "token": "source.php storage.type" },
        { "foreground": "009714", "token": "source.php keyword - comment" },
        { "foreground": "009714", "token": "source.php storage.type.class" },
        { "foreground": "009714", "token": "source.php storage.type.interface" },
        { "foreground": "009714", "token": "source.php storage.modifier" },
        { "foreground": "009714", "token": "source.php constant.language" },
        { "foreground": "0035ff", "token": "source.php support" },
        { "foreground": "0035ff", "token": "source.php storage" },
        { "foreground": "0035ff", "token": "source.php keyword.operator" },
        { "foreground": "0035ff", "token": "source.php storage.type.function" },
        { "foreground": "0092f2", "token": "source.php variable.other.global" },
        { "foreground": "551d02", "token": "source.php support.constant" },
        { "foreground": "551d02", "token": "source.php constant.language.php" },
        { "foreground": "e20000", "token": "source.php string" },
        { "foreground": "e20000", "token": "source.php string keyword.operator" },
        { "foreground": "ff6200", "token": "source.php string.quoted.double variable" },
        { "foreground": "ff9404", "token": "source.php comment" },
        { "foreground": "ee000b", "background": "efff8a", "fontStyle": "bold", "token": "invalid" }
    ],
    "colors": {
        "editor.foreground": "#000000",
        "editor.background": "#FFFFFF",
        "editor.selectionBackground": "#5EA0FF",
        "editor.lineHighlightBackground": "#00000012",
        "editorCursor.foreground": "#000000",
        "editorWhitespace.foreground": "#BFBFBF"
    }
};
let espressoLibre = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "2A211C", "token": "" },
        { "foreground": "0066ff", "fontStyle": "italic", "token": "comment" },
        { "foreground": "43a8ed", "fontStyle": "bold", "token": "keyword" },
        { "foreground": "43a8ed", "fontStyle": "bold", "token": "storage" },
        { "foreground": "44aa43", "token": "constant.numeric" },
        { "foreground": "c5656b", "fontStyle": "bold", "token": "constant" },
        { "foreground": "585cf6", "fontStyle": "bold", "token": "constant.language" },
        { "foreground": "318495", "token": "variable.language" },
        { "foreground": "318495", "token": "variable.other" },
        { "foreground": "049b0a", "token": "string" },
        { "foreground": "2fe420", "token": "constant.character.escape" },
        { "foreground": "2fe420", "token": "string source" },
        { "foreground": "1a921c", "token": "meta.preprocessor" },
        { "foreground": "9aff87", "fontStyle": "bold", "token": "keyword.control.import" },
        { "foreground": "ff9358", "fontStyle": "bold", "token": "entity.name.function" },
        { "foreground": "ff9358", "fontStyle": "bold", "token": "keyword.other.name-of-parameter.objc" },
        { "fontStyle": "underline", "token": "entity.name.type" },
        { "fontStyle": "italic", "token": "entity.other.inherited-class" },
        { "fontStyle": "italic", "token": "variable.parameter" },
        { "foreground": "8b8e9c", "token": "storage.type.method" },
        { "fontStyle": "italic", "token": "meta.section entity.name.section" },
        { "fontStyle": "italic", "token": "declaration.section entity.name.section" },
        { "foreground": "7290d9", "fontStyle": "bold", "token": "support.function" },
        { "foreground": "6d79de", "fontStyle": "bold", "token": "support.class" },
        { "foreground": "6d79de", "fontStyle": "bold", "token": "support.type" },
        { "foreground": "00af0e", "fontStyle": "bold", "token": "support.constant" },
        { "foreground": "2f5fe0", "fontStyle": "bold", "token": "support.variable" },
        { "foreground": "687687", "token": "keyword.operator.js" },
        { "foreground": "ffffff", "background": "990000", "token": "invalid" },
        { "background": "ffd0d0", "token": "invalid.deprecated.trailing-whitespace" },
        { "background": "f5aa7730", "token": "text source" },
        { "background": "f5aa7730", "token": "string.unquoted" },
        { "foreground": "8f7e65", "token": "meta.tag.preprocessor.xml" },
        { "foreground": "888888", "token": "meta.tag.sgml.doctype" },
        { "fontStyle": "italic", "token": "string.quoted.docinfo.doctype.DTD" },
        { "foreground": "43a8ed", "token": "meta.tag" },
        { "foreground": "43a8ed", "token": "declaration.tag" },
        { "fontStyle": "bold", "token": "entity.name.tag" },
        { "fontStyle": "italic", "token": "entity.other.attribute-name" }
    ],
    "colors": {
        "editor.foreground": "#BDAE9D",
        "editor.background": "#2A211C",
        "editor.selectionBackground": "#C3DCFF",
        "editor.lineHighlightBackground": "#3A312C",
        "editorCursor.foreground": "#889AFF",
        "editorWhitespace.foreground": "#BFBFBF"
    }
};
let githubDark = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "24292e", "token": "" },
        { "foreground": "959da5", "token": "comment" },
        { "foreground": "959da5", "token": "punctuation.definition.comment" },
        { "foreground": "959da5", "token": "string.comment" },
        { "foreground": "c8e1ff", "token": "constant" },
        { "foreground": "c8e1ff", "token": "entity.name.constant" },
        { "foreground": "c8e1ff", "token": "variable.other.constant" },
        { "foreground": "c8e1ff", "token": "variable.language" },
        { "foreground": "b392f0", "token": "entity" },
        { "foreground": "b392f0", "token": "entity.name" },
        { "foreground": "f6f8fa", "token": "variable.parameter.function" },
        { "foreground": "7bcc72", "token": "entity.name.tag" },
        { "foreground": "ea4a5a", "token": "keyword" },
        { "foreground": "ea4a5a", "token": "storage" },
        { "foreground": "ea4a5a", "token": "storage.type" },
        { "foreground": "f6f8fa", "token": "storage.modifier.package" },
        { "foreground": "f6f8fa", "token": "storage.modifier.import" },
        { "foreground": "f6f8fa", "token": "storage.type.java" },
        { "foreground": "79b8ff", "token": "string" },
        { "foreground": "79b8ff", "token": "punctuation.definition.string" },
        { "foreground": "79b8ff", "token": "string punctuation.section.embedded source" },
        { "foreground": "c8e1ff", "token": "support" },
        { "foreground": "c8e1ff", "token": "meta.property-name" },
        { "foreground": "fb8532", "token": "variable" },
        { "foreground": "f6f8fa", "token": "variable.other" },
        { "foreground": "d73a49", "fontStyle": "bold italic underline", "token": "invalid.broken" },
        { "foreground": "d73a49", "fontStyle": "bold italic underline", "token": "invalid.deprecated" },
        { "foreground": "fafbfc", "background": "d73a49", "fontStyle": "italic underline", "token": "invalid.illegal" },
        { "foreground": "fafbfc", "background": "d73a49", "fontStyle": "italic underline", "token": "carriage-return" },
        { "foreground": "d73a49", "fontStyle": "bold italic underline", "token": "invalid.unimplemented" },
        { "foreground": "d73a49", "token": "message.error" },
        { "foreground": "f6f8fa", "token": "string source" },
        { "foreground": "c8e1ff", "token": "string variable" },
        { "foreground": "79b8ff", "token": "source.regexp" },
        { "foreground": "79b8ff", "token": "string.regexp" },
        { "foreground": "79b8ff", "token": "string.regexp.character-class" },
        { "foreground": "79b8ff", "token": "string.regexp constant.character.escape" },
        { "foreground": "79b8ff", "token": "string.regexp source.ruby.embedded" },
        { "foreground": "79b8ff", "token": "string.regexp string.regexp.arbitrary-repitition" },
        { "foreground": "7bcc72", "fontStyle": "bold", "token": "string.regexp constant.character.escape" },
        { "foreground": "c8e1ff", "token": "support.constant" },
        { "foreground": "c8e1ff", "token": "support.variable" },
        { "foreground": "c8e1ff", "token": "meta.module-reference" },
        { "foreground": "fb8532", "token": "markup.list" },
        { "foreground": "0366d6", "fontStyle": "bold", "token": "markup.heading" },
        { "foreground": "0366d6", "fontStyle": "bold", "token": "markup.heading entity.name" },
        { "foreground": "c8e1ff", "token": "markup.quote" },
        { "foreground": "f6f8fa", "fontStyle": "italic", "token": "markup.italic" },
        { "foreground": "f6f8fa", "fontStyle": "bold", "token": "markup.bold" },
        { "foreground": "c8e1ff", "token": "markup.raw" },
        { "foreground": "b31d28", "background": "ffeef0", "token": "markup.deleted" },
        { "foreground": "b31d28", "background": "ffeef0", "token": "meta.diff.header.from-file" },
        { "foreground": "b31d28", "background": "ffeef0", "token": "punctuation.definition.deleted" },
        { "foreground": "176f2c", "background": "f0fff4", "token": "markup.inserted" },
        { "foreground": "176f2c", "background": "f0fff4", "token": "meta.diff.header.to-file" },
        { "foreground": "176f2c", "background": "f0fff4", "token": "punctuation.definition.inserted" },
        { "foreground": "b08800", "background": "fffdef", "token": "markup.changed" },
        { "foreground": "b08800", "background": "fffdef", "token": "punctuation.definition.changed" },
        { "foreground": "2f363d", "background": "959da5", "token": "markup.ignored" },
        { "foreground": "2f363d", "background": "959da5", "token": "markup.untracked" },
        { "foreground": "b392f0", "fontStyle": "bold", "token": "meta.diff.range" },
        { "foreground": "c8e1ff", "token": "meta.diff.header" },
        { "foreground": "0366d6", "fontStyle": "bold", "token": "meta.separator" },
        { "foreground": "0366d6", "token": "meta.output" },
        { "foreground": "ffeef0", "token": "brackethighlighter.tag" },
        { "foreground": "ffeef0", "token": "brackethighlighter.curly" },
        { "foreground": "ffeef0", "token": "brackethighlighter.round" },
        { "foreground": "ffeef0", "token": "brackethighlighter.square" },
        { "foreground": "ffeef0", "token": "brackethighlighter.angle" },
        { "foreground": "ffeef0", "token": "brackethighlighter.quote" },
        { "foreground": "d73a49", "token": "brackethighlighter.unmatched" },
        { "foreground": "d73a49", "token": "sublimelinter.mark.error" },
        { "foreground": "fb8532", "token": "sublimelinter.mark.warning" },
        { "foreground": "6a737d", "token": "sublimelinter.gutter-mark" },
        { "foreground": "79b8ff", "fontStyle": "underline", "token": "constant.other.reference.link" },
        { "foreground": "79b8ff", "fontStyle": "underline", "token": "string.other.link" }
    ],
    "colors": {
        "editor.foreground": "#f6f8fa",
        "editor.background": "#24292e",
        "editor.selectionBackground": "#4c2889",
        "editor.inactiveSelectionBackground": "#444d56",
        "editor.lineHighlightBackground": "#444d56",
        "editorCursor.foreground": "#ffffff",
        "editorWhitespace.foreground": "#6a737d",
        "editorIndentGuide.background": "#6a737d",
        "editorIndentGuide.activeBackground": "#f6f8fa",
        "editor.selectionHighlightBorder": "#444d56"
    }
};
let githubLight = {
    "base": "vs",
    "inherit": true,
    "rules": [
        { "background": "ffffff", "token": "" },
        { "foreground": "6a737d", "token": "comment" },
        { "foreground": "6a737d", "token": "punctuation.definition.comment" },
        { "foreground": "6a737d", "token": "string.comment" },
        { "foreground": "005cc5", "token": "constant" },
        { "foreground": "005cc5", "token": "entity.name.constant" },
        { "foreground": "005cc5", "token": "variable.other.constant" },
        { "foreground": "005cc5", "token": "variable.language" },
        { "foreground": "6f42c1", "token": "entity" },
        { "foreground": "6f42c1", "token": "entity.name" },
        { "foreground": "24292e", "token": "variable.parameter.function" },
        { "foreground": "22863a", "token": "entity.name.tag" },
        { "foreground": "d73a49", "token": "keyword" },
        { "foreground": "d73a49", "token": "storage" },
        { "foreground": "d73a49", "token": "storage.type" },
        { "foreground": "24292e", "token": "storage.modifier.package" },
        { "foreground": "24292e", "token": "storage.modifier.import" },
        { "foreground": "24292e", "token": "storage.type.java" },
        { "foreground": "032f62", "token": "string" },
        { "foreground": "032f62", "token": "punctuation.definition.string" },
        { "foreground": "032f62", "token": "string punctuation.section.embedded source" },
        { "foreground": "005cc5", "token": "support" },
        { "foreground": "005cc5", "token": "meta.property-name" },
        { "foreground": "e36209", "token": "variable" },
        { "foreground": "24292e", "token": "variable.other" },
        { "foreground": "b31d28", "fontStyle": "bold italic underline", "token": "invalid.broken" },
        { "foreground": "b31d28", "fontStyle": "bold italic underline", "token": "invalid.deprecated" },
        { "foreground": "fafbfc", "background": "b31d28", "fontStyle": "italic underline", "token": "invalid.illegal" },
        { "foreground": "fafbfc", "background": "d73a49", "fontStyle": "italic underline", "token": "carriage-return" },
        { "foreground": "b31d28", "fontStyle": "bold italic underline", "token": "invalid.unimplemented" },
        { "foreground": "b31d28", "token": "message.error" },
        { "foreground": "24292e", "token": "string source" },
        { "foreground": "005cc5", "token": "string variable" },
        { "foreground": "032f62", "token": "source.regexp" },
        { "foreground": "032f62", "token": "string.regexp" },
        { "foreground": "032f62", "token": "string.regexp.character-class" },
        { "foreground": "032f62", "token": "string.regexp constant.character.escape" },
        { "foreground": "032f62", "token": "string.regexp source.ruby.embedded" },
        { "foreground": "032f62", "token": "string.regexp string.regexp.arbitrary-repitition" },
        { "foreground": "22863a", "fontStyle": "bold", "token": "string.regexp constant.character.escape" },
        { "foreground": "005cc5", "token": "support.constant" },
        { "foreground": "005cc5", "token": "support.variable" },
        { "foreground": "005cc5", "token": "meta.module-reference" },
        { "foreground": "735c0f", "token": "markup.list" },
        { "foreground": "005cc5", "fontStyle": "bold", "token": "markup.heading" },
        { "foreground": "005cc5", "fontStyle": "bold", "token": "markup.heading entity.name" },
        { "foreground": "22863a", "token": "markup.quote" },
        { "foreground": "24292e", "fontStyle": "italic", "token": "markup.italic" },
        { "foreground": "24292e", "fontStyle": "bold", "token": "markup.bold" },
        { "foreground": "005cc5", "token": "markup.raw" },
        { "foreground": "b31d28", "background": "ffeef0", "token": "markup.deleted" },
        { "foreground": "b31d28", "background": "ffeef0", "token": "meta.diff.header.from-file" },
        { "foreground": "b31d28", "background": "ffeef0", "token": "punctuation.definition.deleted" },
        { "foreground": "22863a", "background": "f0fff4", "token": "markup.inserted" },
        { "foreground": "22863a", "background": "f0fff4", "token": "meta.diff.header.to-file" },
        { "foreground": "22863a", "background": "f0fff4", "token": "punctuation.definition.inserted" },
        { "foreground": "e36209", "background": "ffebda", "token": "markup.changed" },
        { "foreground": "e36209", "background": "ffebda", "token": "punctuation.definition.changed" },
        { "foreground": "f6f8fa", "background": "005cc5", "token": "markup.ignored" },
        { "foreground": "f6f8fa", "background": "005cc5", "token": "markup.untracked" },
        { "foreground": "6f42c1", "fontStyle": "bold", "token": "meta.diff.range" },
        { "foreground": "005cc5", "token": "meta.diff.header" },
        { "foreground": "005cc5", "fontStyle": "bold", "token": "meta.separator" },
        { "foreground": "005cc5", "token": "meta.output" },
        { "foreground": "586069", "token": "brackethighlighter.tag" },
        { "foreground": "586069", "token": "brackethighlighter.curly" },
        { "foreground": "586069", "token": "brackethighlighter.round" },
        { "foreground": "586069", "token": "brackethighlighter.square" },
        { "foreground": "586069", "token": "brackethighlighter.angle" },
        { "foreground": "586069", "token": "brackethighlighter.quote" },
        { "foreground": "b31d28", "token": "brackethighlighter.unmatched" },
        { "foreground": "b31d28", "token": "sublimelinter.mark.error" },
        { "foreground": "e36209", "token": "sublimelinter.mark.warning" },
        { "foreground": "959da5", "token": "sublimelinter.gutter-mark" },
        { "foreground": "032f62", "fontStyle": "underline", "token": "constant.other.reference.link" },
        { "foreground": "032f62", "fontStyle": "underline", "token": "string.other.link" }
    ],
    "colors": {
        "editor.foreground": "#24292e",
        "editor.background": "#ffffff",
        "editor.selectionBackground": "#c8c8fa",
        "editor.inactiveSelectionBackground": "#fafbfc",
        "editor.lineHighlightBackground": "#fafbfc",
        "editorCursor.foreground": "#24292e",
        "editorWhitespace.foreground": "#959da5",
        "editorIndentGuide.background": "#959da5",
        "editorIndentGuide.activeBackground": "#24292e",
        "editor.selectionHighlightBorder": "#fafbfc"
    }
};
let github = {
    "base": "vs",
    "inherit": true,
    "rules": [
        { "background": "F8F8FF", "token": "" },
        { "foreground": "999988", "fontStyle": "italic", "token": "comment" },
        { "foreground": "999999", "fontStyle": "bold", "token": "comment.block.preprocessor" },
        { "foreground": "999999", "fontStyle": "bold italic", "token": "comment.documentation" },
        { "foreground": "999999", "fontStyle": "bold italic", "token": "comment.block.documentation" },
        { "foreground": "a61717", "background": "e3d2d2", "token": "invalid.illegal" },
        { "fontStyle": "bold", "token": "keyword" },
        { "fontStyle": "bold", "token": "storage" },
        { "fontStyle": "bold", "token": "keyword.operator" },
        { "fontStyle": "bold", "token": "constant.language" },
        { "fontStyle": "bold", "token": "support.constant" },
        { "foreground": "445588", "fontStyle": "bold", "token": "storage.type" },
        { "foreground": "445588", "fontStyle": "bold", "token": "support.type" },
        { "foreground": "008080", "token": "entity.other.attribute-name" },
        { "foreground": "0086b3", "token": "variable.other" },
        { "foreground": "999999", "token": "variable.language" },
        { "foreground": "445588", "fontStyle": "bold", "token": "entity.name.type" },
        { "foreground": "445588", "fontStyle": "bold", "token": "entity.other.inherited-class" },
        { "foreground": "445588", "fontStyle": "bold", "token": "support.class" },
        { "foreground": "008080", "token": "variable.other.constant" },
        { "foreground": "800080", "token": "constant.character.entity" },
        { "foreground": "990000", "token": "entity.name.exception" },
        { "foreground": "990000", "token": "entity.name.function" },
        { "foreground": "990000", "token": "support.function" },
        { "foreground": "990000", "token": "keyword.other.name-of-parameter" },
        { "foreground": "555555", "token": "entity.name.section" },
        { "foreground": "000080", "token": "entity.name.tag" },
        { "foreground": "008080", "token": "variable.parameter" },
        { "foreground": "008080", "token": "support.variable" },
        { "foreground": "009999", "token": "constant.numeric" },
        { "foreground": "009999", "token": "constant.other" },
        { "foreground": "dd1144", "token": "string - string source" },
        { "foreground": "dd1144", "token": "constant.character" },
        { "foreground": "009926", "token": "string.regexp" },
        { "foreground": "990073", "token": "constant.other.symbol" },
        { "fontStyle": "bold", "token": "punctuation" },
        { "foreground": "000000", "background": "ffdddd", "token": "markup.deleted" },
        { "fontStyle": "italic", "token": "markup.italic" },
        { "foreground": "aa0000", "token": "markup.error" },
        { "foreground": "999999", "token": "markup.heading.1" },
        { "foreground": "000000", "background": "ddffdd", "token": "markup.inserted" },
        { "foreground": "888888", "token": "markup.output" },
        { "foreground": "888888", "token": "markup.raw" },
        { "foreground": "555555", "token": "markup.prompt" },
        { "fontStyle": "bold", "token": "markup.bold" },
        { "foreground": "aaaaaa", "token": "markup.heading" },
        { "foreground": "aa0000", "token": "markup.traceback" },
        { "fontStyle": "underline", "token": "markup.underline" },
        { "foreground": "999999", "background": "eaf2f5", "token": "meta.diff.range" },
        { "foreground": "999999", "background": "eaf2f5", "token": "meta.diff.index" },
        { "foreground": "999999", "background": "eaf2f5", "token": "meta.separator" },
        { "foreground": "999999", "background": "ffdddd", "token": "meta.diff.header.from-file" },
        { "foreground": "999999", "background": "ddffdd", "token": "meta.diff.header.to-file" },
        { "foreground": "4183c4", "token": "meta.link" }
    ],
    "colors": {
        "editor.foreground": "#000000",
        "editor.background": "#F8F8FF",
        "editor.selectionBackground": "#B4D5FE",
        "editor.lineHighlightBackground": "#FFFEEB",
        "editorCursor.foreground": "#666666",
        "editorWhitespace.foreground": "#BBBBBB"
    }
};
let merbivoreSoft = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "161616", "token": "" },
        { "foreground": "ad2ea4", "fontStyle": "italic", "token": "comment" },
        { "foreground": "fc6f09", "token": "keyword" },
        { "foreground": "fc6f09", "token": "storage" },
        { "foreground": "fc83ff", "token": "entity.other.inherited-class" },
        { "foreground": "58c554", "token": "constant.numeric" },
        { "foreground": "1edafb", "token": "constant" },
        { "foreground": "8dff0a", "token": "constant.library" },
        { "foreground": "fc6f09", "token": "support.function" },
        { "foreground": "fdc251", "token": "constant.language" },
        { "foreground": "8dff0a", "token": "string" },
        { "foreground": "1edafb", "token": "support.type" },
        { "foreground": "8dff0a", "token": "support.constant" },
        { "foreground": "fc6f09", "token": "meta.tag" },
        { "foreground": "fc6f09", "token": "declaration.tag" },
        { "foreground": "fc6f09", "token": "entity.name.tag" },
        { "foreground": "ffff89", "token": "entity.other.attribute-name" },
        { "foreground": "ffffff", "background": "990000", "token": "invalid" },
        { "foreground": "519f50", "token": "constant.character.escaped" },
        { "foreground": "519f50", "token": "constant.character.escape" },
        { "foreground": "519f50", "token": "string source" },
        { "foreground": "519f50", "token": "string source.ruby" },
        { "foreground": "e6e1dc", "background": "144212", "token": "markup.inserted" },
        { "foreground": "e6e1dc", "background": "660000", "token": "markup.deleted" },
        { "background": "2f33ab", "token": "meta.diff.header" },
        { "background": "2f33ab", "token": "meta.separator.diff" },
        { "background": "2f33ab", "token": "meta.diff.index" },
        { "background": "2f33ab", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#E6E1DC",
        "editor.background": "#161616",
        "editor.selectionBackground": "#454545",
        "editor.lineHighlightBackground": "#333435",
        "editorCursor.foreground": "#FFFFFF",
        "editorWhitespace.foreground": "#404040"
    }
};
let monokai = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "272822", "token": "" },
        { "foreground": "75715e", "token": "comment" },
        { "foreground": "e6db74", "token": "string" },
        { "foreground": "ae81ff", "token": "constant.numeric" },
        { "foreground": "ae81ff", "token": "constant.language" },
        { "foreground": "ae81ff", "token": "constant.character" },
        { "foreground": "ae81ff", "token": "constant.other" },
        { "foreground": "f92672", "token": "keyword" },
        { "foreground": "f92672", "token": "storage" },
        { "foreground": "66d9ef", "fontStyle": "italic", "token": "storage.type" },
        { "foreground": "a6e22e", "fontStyle": "underline", "token": "entity.name.class" },
        { "foreground": "a6e22e", "fontStyle": "italic underline", "token": "entity.other.inherited-class" },
        { "foreground": "a6e22e", "token": "entity.name.function" },
        { "foreground": "fd971f", "fontStyle": "italic", "token": "variable.parameter" },
        { "foreground": "f92672", "token": "entity.name.tag" },
        { "foreground": "a6e22e", "token": "entity.other.attribute-name" },
        { "foreground": "66d9ef", "token": "support.function" },
        { "foreground": "66d9ef", "token": "support.constant" },
        { "foreground": "66d9ef", "fontStyle": "italic", "token": "support.type" },
        { "foreground": "66d9ef", "fontStyle": "italic", "token": "support.class" },
        { "foreground": "f8f8f0", "background": "f92672", "token": "invalid" },
        { "foreground": "f8f8f0", "background": "ae81ff", "token": "invalid.deprecated" },
        { "foreground": "cfcfc2", "token": "meta.structure.dictionary.json string.quoted.double.json" },
        { "foreground": "75715e", "token": "meta.diff" },
        { "foreground": "75715e", "token": "meta.diff.header" },
        { "foreground": "f92672", "token": "markup.deleted" },
        { "foreground": "a6e22e", "token": "markup.inserted" },
        { "foreground": "e6db74", "token": "markup.changed" },
        { "foreground": "ae81ffa0", "token": "constant.numeric.line-number.find-in-files - match" },
        { "foreground": "e6db74", "token": "entity.name.filename.find-in-files" }
    ],
    "colors": {
        "editor.foreground": "#F8F8F2",
        "editor.background": "#272822",
        "editor.selectionBackground": "#49483E",
        "editor.lineHighlightBackground": "#3E3D32",
        "editorCursor.foreground": "#F8F8F0",
        "editorWhitespace.foreground": "#3B3A32",
        "editorIndentGuide.activeBackground": "#9D550FB0",
        "editor.selectionHighlightBorder": "#222218"
    }
};
let nightOwl = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "011627", "token": "" },
        { "foreground": "637777", "token": "comment" },
        { "foreground": "addb67", "token": "string" },
        { "foreground": "ecc48d", "token": "vstring.quoted" },
        { "foreground": "ecc48d", "token": "variable.other.readwrite.js" },
        { "foreground": "5ca7e4", "token": "string.regexp" },
        { "foreground": "5ca7e4", "token": "string.regexp keyword.other" },
        { "foreground": "5f7e97", "token": "meta.function punctuation.separator.comma" },
        { "foreground": "f78c6c", "token": "constant.numeric" },
        { "foreground": "f78c6c", "token": "constant.character.numeric" },
        { "foreground": "addb67", "token": "variable" },
        { "foreground": "c792ea", "token": "keyword" },
        { "foreground": "c792ea", "token": "punctuation.accessor" },
        { "foreground": "c792ea", "token": "storage" },
        { "foreground": "c792ea", "token": "meta.var.expr" },
        { "foreground": "c792ea", "token": "meta.class meta.method.declaration meta.var.expr storage.type.jsm" },
        { "foreground": "c792ea", "token": "storage.type.property.js" },
        { "foreground": "c792ea", "token": "storage.type.property.ts" },
        { "foreground": "c792ea", "token": "storage.type.property.tsx" },
        { "foreground": "82aaff", "token": "storage.type" },
        { "foreground": "ffcb8b", "token": "entity.name.class" },
        { "foreground": "ffcb8b", "token": "meta.class entity.name.type.class" },
        { "foreground": "addb67", "token": "entity.other.inherited-class" },
        { "foreground": "82aaff", "token": "entity.name.function" },
        { "foreground": "addb67", "token": "punctuation.definition.variable" },
        { "foreground": "d3423e", "token": "punctuation.section.embedded" },
        { "foreground": "d6deeb", "token": "punctuation.terminator.expression" },
        { "foreground": "d6deeb", "token": "punctuation.definition.arguments" },
        { "foreground": "d6deeb", "token": "punctuation.definition.array" },
        { "foreground": "d6deeb", "token": "punctuation.section.array" },
        { "foreground": "d6deeb", "token": "meta.array" },
        { "foreground": "d9f5dd", "token": "punctuation.definition.list.begin" },
        { "foreground": "d9f5dd", "token": "punctuation.definition.list.end" },
        { "foreground": "d9f5dd", "token": "punctuation.separator.arguments" },
        { "foreground": "d9f5dd", "token": "punctuation.definition.list" },
        { "foreground": "d3423e", "token": "string.template meta.template.expression" },
        { "foreground": "d6deeb", "token": "string.template punctuation.definition.string" },
        { "foreground": "c792ea", "fontStyle": "italic", "token": "italic" },
        { "foreground": "addb67", "fontStyle": "bold", "token": "bold" },
        { "foreground": "82aaff", "token": "constant.language" },
        { "foreground": "82aaff", "token": "punctuation.definition.constant" },
        { "foreground": "82aaff", "token": "variable.other.constant" },
        { "foreground": "7fdbca", "token": "support.function.construct" },
        { "foreground": "7fdbca", "token": "keyword.other.new" },
        { "foreground": "82aaff", "token": "constant.character" },
        { "foreground": "82aaff", "token": "constant.other" },
        { "foreground": "f78c6c", "token": "constant.character.escape" },
        { "foreground": "addb67", "token": "entity.other.inherited-class" },
        { "foreground": "d7dbe0", "token": "variable.parameter" },
        { "foreground": "7fdbca", "token": "entity.name.tag" },
        { "foreground": "cc2996", "token": "punctuation.definition.tag.html" },
        { "foreground": "cc2996", "token": "punctuation.definition.tag.begin" },
        { "foreground": "cc2996", "token": "punctuation.definition.tag.end" },
        { "foreground": "addb67", "token": "entity.other.attribute-name" },
        { "foreground": "addb67", "token": "entity.name.tag.custom" },
        { "foreground": "82aaff", "token": "support.function" },
        { "foreground": "82aaff", "token": "support.constant" },
        { "foreground": "7fdbca", "token": "upport.constant.meta.property-value" },
        { "foreground": "addb67", "token": "support.type" },
        { "foreground": "addb67", "token": "support.class" },
        { "foreground": "addb67", "token": "support.variable.dom" },
        { "foreground": "7fdbca", "token": "support.constant" },
        { "foreground": "7fdbca", "token": "keyword.other.special-method" },
        { "foreground": "7fdbca", "token": "keyword.other.new" },
        { "foreground": "7fdbca", "token": "keyword.other.debugger" },
        { "foreground": "7fdbca", "token": "keyword.control" },
        { "foreground": "c792ea", "token": "keyword.operator.comparison" },
        { "foreground": "c792ea", "token": "keyword.control.flow.js" },
        { "foreground": "c792ea", "token": "keyword.control.flow.ts" },
        { "foreground": "c792ea", "token": "keyword.control.flow.tsx" },
        { "foreground": "c792ea", "token": "keyword.control.ruby" },
        { "foreground": "c792ea", "token": "keyword.control.module.ruby" },
        { "foreground": "c792ea", "token": "keyword.control.class.ruby" },
        { "foreground": "c792ea", "token": "keyword.control.def.ruby" },
        { "foreground": "c792ea", "token": "keyword.control.loop.js" },
        { "foreground": "c792ea", "token": "keyword.control.loop.ts" },
        { "foreground": "c792ea", "token": "keyword.control.import.js" },
        { "foreground": "c792ea", "token": "keyword.control.import.ts" },
        { "foreground": "c792ea", "token": "keyword.control.import.tsx" },
        { "foreground": "c792ea", "token": "keyword.control.from.js" },
        { "foreground": "c792ea", "token": "keyword.control.from.ts" },
        { "foreground": "c792ea", "token": "keyword.control.from.tsx" },
        { "foreground": "ffffff", "background": "ff2c83", "token": "invalid" },
        { "foreground": "ffffff", "background": "d3423e", "token": "invalid.deprecated" },
        { "foreground": "7fdbca", "token": "keyword.operator" },
        { "foreground": "c792ea", "token": "keyword.operator.relational" },
        { "foreground": "c792ea", "token": "keyword.operator.assignement" },
        { "foreground": "c792ea", "token": "keyword.operator.arithmetic" },
        { "foreground": "c792ea", "token": "keyword.operator.bitwise" },
        { "foreground": "c792ea", "token": "keyword.operator.increment" },
        { "foreground": "c792ea", "token": "keyword.operator.ternary" },
        { "foreground": "637777", "token": "comment.line.double-slash" },
        { "foreground": "cdebf7", "token": "object" },
        { "foreground": "ff5874", "token": "constant.language.null" },
        { "foreground": "d6deeb", "token": "meta.brace" },
        { "foreground": "c792ea", "token": "meta.delimiter.period" },
        { "foreground": "d9f5dd", "token": "punctuation.definition.string" },
        { "foreground": "ff5874", "token": "constant.language.boolean" },
        { "foreground": "ffffff", "token": "object.comma" },
        { "foreground": "7fdbca", "token": "variable.parameter.function" },
        { "foreground": "80cbc4", "token": "support.type.vendor.property-name" },
        { "foreground": "80cbc4", "token": "support.constant.vendor.property-value" },
        { "foreground": "80cbc4", "token": "support.type.property-name" },
        { "foreground": "80cbc4", "token": "meta.property-list entity.name.tag" },
        { "foreground": "57eaf1", "token": "meta.property-list entity.name.tag.reference" },
        { "foreground": "f78c6c", "token": "constant.other.color.rgb-value punctuation.definition.constant" },
        { "foreground": "ffeb95", "token": "constant.other.color" },
        { "foreground": "ffeb95", "token": "keyword.other.unit" },
        { "foreground": "c792ea", "token": "meta.selector" },
        { "foreground": "fad430", "token": "entity.other.attribute-name.id" },
        { "foreground": "80cbc4", "token": "meta.property-name" },
        { "foreground": "c792ea", "token": "entity.name.tag.doctype" },
        { "foreground": "c792ea", "token": "meta.tag.sgml.doctype" },
        { "foreground": "d9f5dd", "token": "punctuation.definition.parameters" },
        { "foreground": "ecc48d", "token": "string.quoted" },
        { "foreground": "ecc48d", "token": "string.quoted.double" },
        { "foreground": "ecc48d", "token": "string.quoted.single" },
        { "foreground": "addb67", "token": "support.constant.math" },
        { "foreground": "addb67", "token": "support.type.property-name.json" },
        { "foreground": "addb67", "token": "support.constant.json" },
        { "foreground": "c789d6", "token": "meta.structure.dictionary.value.json string.quoted.double" },
        { "foreground": "80cbc4", "token": "string.quoted.double.json punctuation.definition.string.json" },
        { "foreground": "ff5874", "token": "meta.structure.dictionary.json meta.structure.dictionary.value constant.language" },
        { "foreground": "d6deeb", "token": "variable.other.ruby" },
        { "foreground": "ecc48d", "token": "entity.name.type.class.ruby" },
        { "foreground": "ecc48d", "token": "keyword.control.class.ruby" },
        { "foreground": "ecc48d", "token": "meta.class.ruby" },
        { "foreground": "7fdbca", "token": "constant.language.symbol.hashkey.ruby" },
        { "foreground": "e0eddd", "background": "a57706", "fontStyle": "italic", "token": "meta.diff" },
        { "foreground": "e0eddd", "background": "a57706", "fontStyle": "italic", "token": "meta.diff.header" },
        { "foreground": "ef535090", "fontStyle": "italic", "token": "markup.deleted" },
        { "foreground": "a2bffc", "fontStyle": "italic", "token": "markup.changed" },
        { "foreground": "a2bffc", "fontStyle": "italic", "token": "meta.diff.header.git" },
        { "foreground": "a2bffc", "fontStyle": "italic", "token": "meta.diff.header.from-file" },
        { "foreground": "a2bffc", "fontStyle": "italic", "token": "meta.diff.header.to-file" },
        { "foreground": "219186", "background": "eae3ca", "token": "markup.inserted" },
        { "foreground": "d3201f", "token": "other.package.exclude" },
        { "foreground": "d3201f", "token": "other.remove" },
        { "foreground": "269186", "token": "other.add" },
        { "foreground": "ff5874", "token": "constant.language.python" },
        { "foreground": "82aaff", "token": "variable.parameter.function.python" },
        { "foreground": "82aaff", "token": "meta.function-call.arguments.python" },
        { "foreground": "b2ccd6", "token": "meta.function-call.python" },
        { "foreground": "b2ccd6", "token": "meta.function-call.generic.python" },
        { "foreground": "d6deeb", "token": "punctuation.python" },
        { "foreground": "addb67", "token": "entity.name.function.decorator.python" },
        { "foreground": "8eace3", "token": "source.python variable.language.special" },
        { "foreground": "82b1ff", "token": "markup.heading.markdown" },
        { "foreground": "c792ea", "fontStyle": "italic", "token": "markup.italic.markdown" },
        { "foreground": "addb67", "fontStyle": "bold", "token": "markup.bold.markdown" },
        { "foreground": "697098", "token": "markup.quote.markdown" },
        { "foreground": "80cbc4", "token": "markup.inline.raw.markdown" },
        { "foreground": "ff869a", "token": "markup.underline.link.markdown" },
        { "foreground": "ff869a", "token": "markup.underline.link.image.markdown" },
        { "foreground": "d6deeb", "token": "string.other.link.title.markdown" },
        { "foreground": "d6deeb", "token": "string.other.link.description.markdown" },
        { "foreground": "82b1ff", "token": "punctuation.definition.string.markdown" },
        { "foreground": "82b1ff", "token": "punctuation.definition.string.begin.markdown" },
        { "foreground": "82b1ff", "token": "punctuation.definition.string.end.markdown" },
        { "foreground": "82b1ff", "token": "meta.link.inline.markdown punctuation.definition.string" },
        { "foreground": "7fdbca", "token": "punctuation.definition.metadata.markdown" },
        { "foreground": "82b1ff", "token": "beginning.punctuation.definition.list.markdown" }
    ],
    "colors": {
        "editor.foreground": "#d6deeb",
        "editor.background": "#011627",
        "editor.selectionBackground": "#5f7e9779",
        "editor.lineHighlightBackground": "#010E17",
        "editorCursor.foreground": "#80a4c2",
        "editorWhitespace.foreground": "#2e2040",
        "editorIndentGuide.background": "#5e81ce52",
        "editor.selectionHighlightBorder": "#122d42"
    }
};
let nord = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "2E3440", "token": "" },
        { "foreground": "616e88", "token": "comment" },
        { "foreground": "a3be8c", "token": "string" },
        { "foreground": "b48ead", "token": "constant.numeric" },
        { "foreground": "81a1c1", "token": "constant.language" },
        { "foreground": "81a1c1", "token": "keyword" },
        { "foreground": "81a1c1", "token": "storage" },
        { "foreground": "81a1c1", "token": "storage.type" },
        { "foreground": "8fbcbb", "token": "entity.name.class" },
        { "foreground": "8fbcbb", "fontStyle": "  bold", "token": "entity.other.inherited-class" },
        { "foreground": "88c0d0", "token": "entity.name.function" },
        { "foreground": "81a1c1", "token": "entity.name.tag" },
        { "foreground": "8fbcbb", "token": "entity.other.attribute-name" },
        { "foreground": "88c0d0", "token": "support.function" },
        { "foreground": "f8f8f0", "background": "f92672", "token": "invalid" },
        { "foreground": "f8f8f0", "background": "ae81ff", "token": "invalid.deprecated" },
        { "foreground": "b48ead", "token": "constant.color.other.rgb-value" },
        { "foreground": "ebcb8b", "token": "constant.character.escape" },
        { "foreground": "8fbcbb", "token": "variable.other.constant" }
    ],
    "colors": {
        "editor.foreground": "#D8DEE9",
        "editor.background": "#2E3440",
        "editor.selectionBackground": "#434C5ECC",
        "editor.lineHighlightBackground": "#3B4252",
        "editorCursor.foreground": "#D8DEE9",
        "editorWhitespace.foreground": "#434C5ECC"
    }
};
let oceanicNext = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "1B2B34", "token": "" },
        { "foreground": "65737e", "token": "comment" },
        { "foreground": "65737e", "token": "punctuation.definition.comment" },
        { "foreground": "cdd3de", "token": "variable" },
        { "foreground": "c594c5", "token": "keyword" },
        { "foreground": "c594c5", "token": "storage.type" },
        { "foreground": "c594c5", "token": "storage.modifier" },
        { "foreground": "5fb3b3", "token": "keyword.operator" },
        { "foreground": "5fb3b3", "token": "constant.other.color" },
        { "foreground": "5fb3b3", "token": "punctuation" },
        { "foreground": "5fb3b3", "token": "meta.tag" },
        { "foreground": "5fb3b3", "token": "punctuation.definition.tag" },
        { "foreground": "5fb3b3", "token": "punctuation.separator.inheritance.php" },
        { "foreground": "5fb3b3", "token": "punctuation.definition.tag.html" },
        { "foreground": "5fb3b3", "token": "punctuation.definition.tag.begin.html" },
        { "foreground": "5fb3b3", "token": "punctuation.definition.tag.end.html" },
        { "foreground": "5fb3b3", "token": "punctuation.section.embedded" },
        { "foreground": "5fb3b3", "token": "keyword.other.template" },
        { "foreground": "5fb3b3", "token": "keyword.other.substitution" },
        { "foreground": "eb606b", "token": "entity.name.tag" },
        { "foreground": "eb606b", "token": "meta.tag.sgml" },
        { "foreground": "eb606b", "token": "markup.deleted.git_gutter" },
        { "foreground": "6699cc", "token": "entity.name.function" },
        { "foreground": "6699cc", "token": "meta.function-call" },
        { "foreground": "6699cc", "token": "variable.function" },
        { "foreground": "6699cc", "token": "support.function" },
        { "foreground": "6699cc", "token": "keyword.other.special-method" },
        { "foreground": "6699cc", "token": "meta.block-level" },
        { "foreground": "f2777a", "token": "support.other.variable" },
        { "foreground": "f2777a", "token": "string.other.link" },
        { "foreground": "f99157", "token": "constant.numeric" },
        { "foreground": "f99157", "token": "constant.language" },
        { "foreground": "f99157", "token": "support.constant" },
        { "foreground": "f99157", "token": "constant.character" },
        { "foreground": "f99157", "token": "variable.parameter" },
        { "foreground": "f99157", "token": "keyword.other.unit" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "string" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "constant.other.symbol" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "constant.other.key" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "entity.other.inherited-class" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "markup.heading" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "markup.inserted.git_gutter" },
        { "foreground": "99c794", "fontStyle": "normal", "token": "meta.group.braces.curly constant.other.object.key.js string.unquoted.label.js" },
        { "foreground": "fac863", "token": "entity.name.class" },
        { "foreground": "fac863", "token": "entity.name.type.class" },
        { "foreground": "fac863", "token": "support.type" },
        { "foreground": "fac863", "token": "support.class" },
        { "foreground": "fac863", "token": "support.orther.namespace.use.php" },
        { "foreground": "fac863", "token": "meta.use.php" },
        { "foreground": "fac863", "token": "support.other.namespace.php" },
        { "foreground": "fac863", "token": "markup.changed.git_gutter" },
        { "foreground": "ec5f67", "token": "entity.name.module.js" },
        { "foreground": "ec5f67", "token": "variable.import.parameter.js" },
        { "foreground": "ec5f67", "token": "variable.other.class.js" },
        { "foreground": "ec5f67", "fontStyle": "italic", "token": "variable.language" },
        { "foreground": "cdd3de", "token": "meta.group.braces.curly.js constant.other.object.key.js string.unquoted.label.js" },
        { "foreground": "d8dee9", "token": "meta.class-method.js entity.name.function.js" },
        { "foreground": "d8dee9", "token": "variable.function.constructor" },
        { "foreground": "d8dee9", "token": "meta.class.js meta.class.property.js meta.method.js string.unquoted.js entity.name.function.js" },
        { "foreground": "bb80b3", "token": "entity.other.attribute-name" },
        { "foreground": "99c794", "token": "markup.inserted" },
        { "foreground": "ec5f67", "token": "markup.deleted" },
        { "foreground": "bb80b3", "token": "markup.changed" },
        { "foreground": "5fb3b3", "token": "string.regexp" },
        { "foreground": "5fb3b3", "token": "constant.character.escape" },
        { "fontStyle": "underline", "token": "*url*" },
        { "fontStyle": "underline", "token": "*link*" },
        { "fontStyle": "underline", "token": "*uri*" },
        { "foreground": "ab7967", "token": "constant.numeric.line-number.find-in-files - match" },
        { "foreground": "99c794", "token": "entity.name.filename.find-in-files" },
        { "foreground": "6699cc", "fontStyle": "italic", "token": "tag.decorator.js entity.name.tag.js" },
        { "foreground": "6699cc", "fontStyle": "italic", "token": "tag.decorator.js punctuation.definition.tag.js" },
        { "foreground": "ec5f67", "fontStyle": "italic", "token": "source.js constant.other.object.key.js string.unquoted.label.js" },
        { "foreground": "fac863", "token": "source.json meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "fac863", "token": "source.json meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "c594c5", "token": "source.json meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "c594c5", "token": "source.json meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "d8dee9", "token": "source.json meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "d8dee9", "token": "source.json meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "6699cc", "token": "source.json meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "6699cc", "token": "source.json meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "ab7967", "token": "source.json meta meta meta meta meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "ab7967", "token": "source.json meta meta meta meta meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "ec5f67", "token": "source.json meta meta meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "ec5f67", "token": "source.json meta meta meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "f99157", "token": "source.json meta meta meta meta.structure.dictionary.json string.quoted.double.json - meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "f99157", "token": "source.json meta meta meta meta.structure.dictionary.json punctuation.definition.string - meta meta meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "fac863", "token": "source.json meta meta.structure.dictionary.json string.quoted.double.json - meta meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "fac863", "token": "source.json meta meta.structure.dictionary.json punctuation.definition.string - meta meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" },
        { "foreground": "c594c5", "token": "source.json meta.structure.dictionary.json string.quoted.double.json - meta.structure.dictionary.json meta.structure.dictionary.value.json string.quoted.double.json" },
        { "foreground": "c594c5", "token": "source.json meta.structure.dictionary.json punctuation.definition.string - meta.structure.dictionary.json meta.structure.dictionary.value.json punctuation.definition.string" }
    ],
    "colors": {
        "editor.foreground": "#CDD3DE",
        "editor.background": "#1B2B34",
        "editor.selectionBackground": "#4f5b66",
        "editor.lineHighlightBackground": "#65737e55",
        "editorCursor.foreground": "#c0c5ce",
        "editorWhitespace.foreground": "#65737e",
        "editorIndentGuide.background": "#65737F",
        "editorIndentGuide.activeBackground": "#FBC95A"
    }
};
let pastelsOnDark = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "211E1E", "token": "" },
        { "foreground": "555555", "token": "comment" },
        { "foreground": "555555", "token": "comment.block" },
        { "foreground": "ad9361", "token": "string" },
        { "foreground": "cccccc", "token": "constant.numeric" },
        { "foreground": "a1a1ff", "token": "keyword" },
        { "foreground": "2f006e", "token": "meta.preprocessor" },
        { "fontStyle": "bold", "token": "keyword.control.import" },
        { "foreground": "a1a1ff", "token": "support.function" },
        { "foreground": "0000ff", "token": "declaration.function function-result" },
        { "fontStyle": "bold", "token": "declaration.function function-name" },
        { "fontStyle": "bold", "token": "declaration.function argument-name" },
        { "foreground": "0000ff", "token": "declaration.function function-arg-type" },
        { "fontStyle": "italic", "token": "declaration.function function-argument" },
        { "fontStyle": "underline", "token": "declaration.class class-name" },
        { "fontStyle": "italic underline", "token": "declaration.class class-inheritance" },
        { "foreground": "fff9f9", "background": "ff0000", "fontStyle": "bold", "token": "invalid" },
        { "background": "ffd0d0", "token": "invalid.deprecated.trailing-whitespace" },
        { "fontStyle": "italic", "token": "declaration.section section-name" },
        { "foreground": "c10006", "token": "string.interpolation" },
        { "foreground": "666666", "token": "string.regexp" },
        { "foreground": "c1c144", "token": "variable" },
        { "foreground": "6782d3", "token": "constant" },
        { "foreground": "afa472", "token": "constant.character" },
        { "foreground": "de8e30", "fontStyle": "bold", "token": "constant.language" },
        { "fontStyle": "underline", "token": "embedded" },
        { "foreground": "858ef4", "token": "keyword.markup.element-name" },
        { "foreground": "9b456f", "token": "keyword.markup.attribute-name" },
        { "foreground": "9b456f", "token": "meta.attribute-with-value" },
        { "foreground": "c82255", "fontStyle": "bold", "token": "keyword.exception" },
        { "foreground": "47b8d6", "token": "keyword.operator" },
        { "foreground": "6969fa", "fontStyle": "bold", "token": "keyword.control" },
        { "foreground": "68685b", "token": "meta.tag.preprocessor.xml" },
        { "foreground": "888888", "token": "meta.tag.sgml.doctype" },
        { "fontStyle": "italic", "token": "string.quoted.docinfo.doctype.DTD" },
        { "foreground": "909090", "token": "comment.other.server-side-include.xhtml" },
        { "foreground": "909090", "token": "comment.other.server-side-include.html" },
        { "foreground": "858ef4", "token": "text.html declaration.tag" },
        { "foreground": "858ef4", "token": "text.html meta.tag" },
        { "foreground": "858ef4", "token": "text.html entity.name.tag.xhtml" },
        { "foreground": "9b456f", "token": "keyword.markup.attribute-name" },
        { "foreground": "777777", "token": "keyword.other.phpdoc.php" },
        { "foreground": "c82255", "token": "keyword.other.include.php" },
        { "foreground": "de8e20", "fontStyle": "bold", "token": "support.constant.core.php" },
        { "foreground": "de8e10", "fontStyle": "bold", "token": "support.constant.std.php" },
        { "foreground": "b72e1d", "token": "variable.other.global.php" },
        { "foreground": "00ff00", "token": "variable.other.global.safer.php" },
        { "foreground": "bfa36d", "token": "string.quoted.single.php" },
        { "foreground": "6969fa", "token": "keyword.storage.php" },
        { "foreground": "ad9361", "token": "string.quoted.double.php" },
        { "foreground": "ec9e00", "token": "entity.other.attribute-name.id.css" },
        { "foreground": "b8cd06", "fontStyle": "bold", "token": "entity.name.tag.css" },
        { "foreground": "edca06", "token": "entity.other.attribute-name.class.css" },
        { "foreground": "2e759c", "token": "entity.other.attribute-name.pseudo-class.css" },
        { "foreground": "ffffff", "background": "ff0000", "token": "invalid.bad-comma.css" },
        { "foreground": "9b2e4d", "token": "support.constant.property-value.css" },
        { "foreground": "e1c96b", "token": "support.type.property-name.css" },
        { "foreground": "666633", "token": "constant.other.rgb-value.css" },
        { "foreground": "666633", "token": "support.constant.font-name.css" },
        { "foreground": "7171f3", "token": "support.constant.tm-language-def" },
        { "foreground": "7171f3", "token": "support.constant.name.tm-language-def" },
        { "foreground": "6969fa", "token": "keyword.other.unit.css" }
    ],
    "colors": {
        "editor.foreground": "#DADADA",
        "editor.background": "#211E1E",
        "editor.selectionBackground": "#73597E80",
        "editor.lineHighlightBackground": "#353030",
        "editorCursor.foreground": "#FFFFFF",
        "editorWhitespace.foreground": "#4F4D4D"
    }
};
let sunburst = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "000000", "token": "" },
        { "foreground": "aeaeae", "fontStyle": "italic", "token": "comment" },
        { "foreground": "3387cc", "token": "constant" },
        { "foreground": "89bdff", "token": "entity" },
        { "foreground": "e28964", "token": "keyword" },
        { "foreground": "99cf50", "token": "storage" },
        { "foreground": "65b042", "token": "string" },
        { "foreground": "9b859d", "token": "support" },
        { "foreground": "3e87e3", "token": "variable" },
        { "foreground": "fd5ff1", "fontStyle": "italic underline", "token": "invalid.deprecated" },
        { "foreground": "fd5ff1", "background": "562d56bf", "token": "invalid.illegal" },
        { "background": "b1b3ba08", "token": "text source" },
        { "foreground": "9b5c2e", "fontStyle": "italic", "token": "entity.other.inherited-class" },
        { "foreground": "daefa3", "token": "string.quoted source" },
        { "foreground": "ddf2a4", "token": "string constant" },
        { "foreground": "e9c062", "token": "string.regexp" },
        { "foreground": "cf7d34", "token": "string.regexp constant.character.escape" },
        { "foreground": "cf7d34", "token": "string.regexp source.ruby.embedded" },
        { "foreground": "cf7d34", "token": "string.regexp string.regexp.arbitrary-repitition" },
        { "foreground": "8a9a95", "token": "string variable" },
        { "foreground": "dad085", "token": "support.function" },
        { "foreground": "cf6a4c", "token": "support.constant" },
        { "foreground": "8996a8", "token": "meta.preprocessor.c" },
        { "foreground": "afc4db", "token": "meta.preprocessor.c keyword" },
        { "fontStyle": "underline", "token": "entity.name.type" },
        { "foreground": "676767", "fontStyle": "italic", "token": "meta.cast" },
        { "foreground": "494949", "token": "meta.sgml.html meta.doctype" },
        { "foreground": "494949", "token": "meta.sgml.html meta.doctype entity" },
        { "foreground": "494949", "token": "meta.sgml.html meta.doctype string" },
        { "foreground": "494949", "token": "meta.xml-processing" },
        { "foreground": "494949", "token": "meta.xml-processing entity" },
        { "foreground": "494949", "token": "meta.xml-processing string" },
        { "foreground": "89bdff", "token": "meta.tag" },
        { "foreground": "89bdff", "token": "meta.tag entity" },
        { "foreground": "e0c589", "token": "source entity.name.tag" },
        { "foreground": "e0c589", "token": "source entity.other.attribute-name" },
        { "foreground": "e0c589", "token": "meta.tag.inline" },
        { "foreground": "e0c589", "token": "meta.tag.inline entity" },
        { "foreground": "e18964", "token": "entity.name.tag.namespace" },
        { "foreground": "e18964", "token": "entity.other.attribute-name.namespace" },
        { "foreground": "cda869", "token": "meta.selector.css entity.name.tag" },
        { "foreground": "8f9d6a", "token": "meta.selector.css entity.other.attribute-name.tag.pseudo-class" },
        { "foreground": "8b98ab", "token": "meta.selector.css entity.other.attribute-name.id" },
        { "foreground": "9b703f", "token": "meta.selector.css entity.other.attribute-name.class" },
        { "foreground": "c5af75", "token": "support.type.property-name.css" },
        { "foreground": "f9ee98", "token": "meta.property-group support.constant.property-value.css" },
        { "foreground": "f9ee98", "token": "meta.property-value support.constant.property-value.css" },
        { "foreground": "8693a5", "token": "meta.preprocessor.at-rule keyword.control.at-rule" },
        { "foreground": "dd7b3b", "token": "meta.property-value support.constant.named-color.css" },
        { "foreground": "dd7b3b", "token": "meta.property-value constant" },
        { "foreground": "8f9d6a", "token": "meta.constructor.argument.css" },
        { "foreground": "f8f8f8", "background": "0e2231", "fontStyle": "italic", "token": "meta.diff" },
        { "foreground": "f8f8f8", "background": "0e2231", "fontStyle": "italic", "token": "meta.diff.header" },
        { "foreground": "f8f8f8", "background": "420e09", "token": "markup.deleted" },
        { "foreground": "f8f8f8", "background": "4a410d", "token": "markup.changed" },
        { "foreground": "f8f8f8", "background": "253b22", "token": "markup.inserted" },
        { "foreground": "e9c062", "fontStyle": "italic", "token": "markup.italic" },
        { "foreground": "e9c062", "fontStyle": "bold", "token": "markup.bold" },
        { "foreground": "e18964", "fontStyle": "underline", "token": "markup.underline" },
        { "foreground": "e1d4b9", "background": "fee09c12", "fontStyle": "italic", "token": "markup.quote" },
        { "foreground": "fedcc5", "background": "632d04", "token": "markup.heading" },
        { "foreground": "fedcc5", "background": "632d04", "token": "markup.heading entity" },
        { "foreground": "e1d4b9", "token": "markup.list" },
        { "foreground": "578bb3", "background": "b1b3ba08", "token": "markup.raw" },
        { "foreground": "f67b37", "fontStyle": "italic", "token": "markup comment" },
        { "foreground": "60a633", "background": "242424", "token": "meta.separator" },
        { "background": "eeeeee29", "token": "meta.line.entry.logfile" },
        { "background": "eeeeee29", "token": "meta.line.exit.logfile" },
        { "background": "751012", "token": "meta.line.error.logfile" }
    ],
    "colors": {
        "editor.foreground": "#F8F8F8",
        "editor.background": "#000000",
        "editor.selectionBackground": "#DDF0FF33",
        "editor.lineHighlightBackground": "#FFFFFF0D",
        "editorCursor.foreground": "#A7A7A7",
        "editorWhitespace.foreground": "#CAE2FB3D"
    }
};
let tomorrowNightBlue = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "002451", "token": "" },
        { "foreground": "7285b7", "token": "comment" },
        { "foreground": "ffffff", "token": "keyword.operator.class" },
        { "foreground": "ffffff", "token": "keyword.operator" },
        { "foreground": "ffffff", "token": "constant.other" },
        { "foreground": "ffffff", "token": "source.php.embedded.line" },
        { "foreground": "ff9da4", "token": "variable" },
        { "foreground": "ff9da4", "token": "support.other.variable" },
        { "foreground": "ff9da4", "token": "string.other.link" },
        { "foreground": "ff9da4", "token": "string.regexp" },
        { "foreground": "ff9da4", "token": "entity.name.tag" },
        { "foreground": "ff9da4", "token": "entity.other.attribute-name" },
        { "foreground": "ff9da4", "token": "meta.tag" },
        { "foreground": "ff9da4", "token": "declaration.tag" },
        { "foreground": "ff9da4", "token": "markup.deleted.git_gutter" },
        { "foreground": "ffc58f", "token": "constant.numeric" },
        { "foreground": "ffc58f", "token": "constant.language" },
        { "foreground": "ffc58f", "token": "support.constant" },
        { "foreground": "ffc58f", "token": "constant.character" },
        { "foreground": "ffc58f", "token": "variable.parameter" },
        { "foreground": "ffc58f", "token": "punctuation.section.embedded" },
        { "foreground": "ffc58f", "token": "keyword.other.unit" },
        { "foreground": "ffeead", "token": "entity.name.class" },
        { "foreground": "ffeead", "token": "entity.name.type.class" },
        { "foreground": "ffeead", "token": "support.type" },
        { "foreground": "ffeead", "token": "support.class" },
        { "foreground": "d1f1a9", "token": "string" },
        { "foreground": "d1f1a9", "token": "constant.other.symbol" },
        { "foreground": "d1f1a9", "token": "entity.other.inherited-class" },
        { "foreground": "d1f1a9", "token": "markup.heading" },
        { "foreground": "d1f1a9", "token": "markup.inserted.git_gutter" },
        { "foreground": "99ffff", "token": "keyword.operator" },
        { "foreground": "99ffff", "token": "constant.other.color" },
        { "foreground": "bbdaff", "token": "entity.name.function" },
        { "foreground": "bbdaff", "token": "meta.function-call" },
        { "foreground": "bbdaff", "token": "support.function" },
        { "foreground": "bbdaff", "token": "keyword.other.special-method" },
        { "foreground": "bbdaff", "token": "meta.block-level" },
        { "foreground": "bbdaff", "token": "markup.changed.git_gutter" },
        { "foreground": "ebbbff", "token": "keyword" },
        { "foreground": "ebbbff", "token": "storage" },
        { "foreground": "ebbbff", "token": "storage.type" },
        { "foreground": "ebbbff", "token": "entity.name.tag.css" },
        { "foreground": "ffffff", "background": "f99da5", "token": "invalid" },
        { "foreground": "ffffff", "background": "bbdafe", "token": "meta.separator" },
        { "foreground": "ffffff", "background": "ebbbff", "token": "invalid.deprecated" },
        { "foreground": "ffffff", "token": "markup.inserted.diff" },
        { "foreground": "ffffff", "token": "markup.deleted.diff" },
        { "foreground": "ffffff", "token": "meta.diff.header.to-file" },
        { "foreground": "ffffff", "token": "meta.diff.header.from-file" },
        { "foreground": "718c00", "token": "markup.inserted.diff" },
        { "foreground": "718c00", "token": "meta.diff.header.to-file" },
        { "foreground": "c82829", "token": "markup.deleted.diff" },
        { "foreground": "c82829", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.to-file" },
        { "foreground": "3e999f", "fontStyle": "italic", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#FFFFFF",
        "editor.background": "#002451",
        "editor.selectionBackground": "#003F8E",
        "editor.lineHighlightBackground": "#00346E",
        "editorCursor.foreground": "#FFFFFF",
        "editorWhitespace.foreground": "#404F7D"
    }
};
let tomorrowNightBright = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "000000", "token": "" },
        { "foreground": "969896", "token": "comment" },
        { "foreground": "eeeeee", "token": "keyword.operator.class" },
        { "foreground": "eeeeee", "token": "constant.other" },
        { "foreground": "eeeeee", "token": "source.php.embedded.line" },
        { "foreground": "d54e53", "token": "variable" },
        { "foreground": "d54e53", "token": "support.other.variable" },
        { "foreground": "d54e53", "token": "string.other.link" },
        { "foreground": "d54e53", "token": "string.regexp" },
        { "foreground": "d54e53", "token": "entity.name.tag" },
        { "foreground": "d54e53", "token": "entity.other.attribute-name" },
        { "foreground": "d54e53", "token": "meta.tag" },
        { "foreground": "d54e53", "token": "declaration.tag" },
        { "foreground": "d54e53", "token": "markup.deleted.git_gutter" },
        { "foreground": "e78c45", "token": "constant.numeric" },
        { "foreground": "e78c45", "token": "constant.language" },
        { "foreground": "e78c45", "token": "support.constant" },
        { "foreground": "e78c45", "token": "constant.character" },
        { "foreground": "e78c45", "token": "variable.parameter" },
        { "foreground": "e78c45", "token": "punctuation.section.embedded" },
        { "foreground": "e78c45", "token": "keyword.other.unit" },
        { "foreground": "e7c547", "token": "entity.name.class" },
        { "foreground": "e7c547", "token": "entity.name.type.class" },
        { "foreground": "e7c547", "token": "support.type" },
        { "foreground": "e7c547", "token": "support.class" },
        { "foreground": "b9ca4a", "token": "string" },
        { "foreground": "b9ca4a", "token": "constant.other.symbol" },
        { "foreground": "b9ca4a", "token": "entity.other.inherited-class" },
        { "foreground": "b9ca4a", "token": "markup.heading" },
        { "foreground": "b9ca4a", "token": "markup.inserted.git_gutter" },
        { "foreground": "70c0b1", "token": "keyword.operator" },
        { "foreground": "70c0b1", "token": "constant.other.color" },
        { "foreground": "7aa6da", "token": "entity.name.function" },
        { "foreground": "7aa6da", "token": "meta.function-call" },
        { "foreground": "7aa6da", "token": "support.function" },
        { "foreground": "7aa6da", "token": "keyword.other.special-method" },
        { "foreground": "7aa6da", "token": "meta.block-level" },
        { "foreground": "7aa6da", "token": "markup.changed.git_gutter" },
        { "foreground": "c397d8", "token": "keyword" },
        { "foreground": "c397d8", "token": "storage" },
        { "foreground": "c397d8", "token": "storage.type" },
        { "foreground": "c397d8", "token": "entity.name.tag.css" },
        { "foreground": "ced2cf", "background": "df5f5f", "token": "invalid" },
        { "foreground": "ced2cf", "background": "82a3bf", "token": "meta.separator" },
        { "foreground": "ced2cf", "background": "b798bf", "token": "invalid.deprecated" },
        { "foreground": "ffffff", "token": "markup.inserted.diff" },
        { "foreground": "ffffff", "token": "markup.deleted.diff" },
        { "foreground": "ffffff", "token": "meta.diff.header.to-file" },
        { "foreground": "ffffff", "token": "meta.diff.header.from-file" },
        { "foreground": "718c00", "token": "markup.inserted.diff" },
        { "foreground": "718c00", "token": "meta.diff.header.to-file" },
        { "foreground": "c82829", "token": "markup.deleted.diff" },
        { "foreground": "c82829", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.to-file" },
        { "foreground": "3e999f", "fontStyle": "italic", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#DEDEDE",
        "editor.background": "#000000",
        "editor.selectionBackground": "#424242",
        "editor.lineHighlightBackground": "#2A2A2A",
        "editorCursor.foreground": "#9F9F9F",
        "editorWhitespace.foreground": "#343434"
    }
};
let tomorrowNightEighties = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "2D2D2D", "token": "" },
        { "foreground": "999999", "token": "comment" },
        { "foreground": "cccccc", "token": "keyword.operator.class" },
        { "foreground": "cccccc", "token": "constant.other" },
        { "foreground": "cccccc", "token": "source.php.embedded.line" },
        { "foreground": "f2777a", "token": "variable" },
        { "foreground": "f2777a", "token": "support.other.variable" },
        { "foreground": "f2777a", "token": "string.other.link" },
        { "foreground": "f2777a", "token": "entity.name.tag" },
        { "foreground": "f2777a", "token": "entity.other.attribute-name" },
        { "foreground": "f2777a", "token": "meta.tag" },
        { "foreground": "f2777a", "token": "declaration.tag" },
        { "foreground": "f2777a", "token": "markup.deleted.git_gutter" },
        { "foreground": "f99157", "token": "constant.numeric" },
        { "foreground": "f99157", "token": "constant.language" },
        { "foreground": "f99157", "token": "support.constant" },
        { "foreground": "f99157", "token": "constant.character" },
        { "foreground": "f99157", "token": "variable.parameter" },
        { "foreground": "f99157", "token": "punctuation.section.embedded" },
        { "foreground": "f99157", "token": "keyword.other.unit" },
        { "foreground": "ffcc66", "token": "entity.name.class" },
        { "foreground": "ffcc66", "token": "entity.name.type.class" },
        { "foreground": "ffcc66", "token": "support.type" },
        { "foreground": "ffcc66", "token": "support.class" },
        { "foreground": "99cc99", "token": "string" },
        { "foreground": "99cc99", "token": "constant.other.symbol" },
        { "foreground": "99cc99", "token": "entity.other.inherited-class" },
        { "foreground": "99cc99", "token": "markup.heading" },
        { "foreground": "99cc99", "token": "markup.inserted.git_gutter" },
        { "foreground": "66cccc", "token": "keyword.operator" },
        { "foreground": "66cccc", "token": "constant.other.color" },
        { "foreground": "6699cc", "token": "entity.name.function" },
        { "foreground": "6699cc", "token": "meta.function-call" },
        { "foreground": "6699cc", "token": "support.function" },
        { "foreground": "6699cc", "token": "keyword.other.special-method" },
        { "foreground": "6699cc", "token": "meta.block-level" },
        { "foreground": "6699cc", "token": "markup.changed.git_gutter" },
        { "foreground": "cc99cc", "token": "keyword" },
        { "foreground": "cc99cc", "token": "storage" },
        { "foreground": "cc99cc", "token": "storage.type" },
        { "foreground": "cc99cc", "token": "entity.name.tag.css" },
        { "foreground": "cdcdcd", "background": "f2777a", "token": "invalid" },
        { "foreground": "cdcdcd", "background": "99cccc", "token": "meta.separator" },
        { "foreground": "cdcdcd", "background": "cc99cc", "token": "invalid.deprecated" },
        { "foreground": "ffffff", "token": "markup.inserted.diff" },
        { "foreground": "ffffff", "token": "markup.deleted.diff" },
        { "foreground": "ffffff", "token": "meta.diff.header.to-file" },
        { "foreground": "ffffff", "token": "meta.diff.header.from-file" },
        { "foreground": "718c00", "token": "markup.inserted.diff" },
        { "foreground": "718c00", "token": "meta.diff.header.to-file" },
        { "foreground": "c82829", "token": "markup.deleted.diff" },
        { "foreground": "c82829", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.to-file" },
        { "foreground": "3e999f", "fontStyle": "italic", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#CCCCCC",
        "editor.background": "#2D2D2D",
        "editor.selectionBackground": "#515151",
        "editor.lineHighlightBackground": "#393939",
        "editorCursor.foreground": "#CCCCCC",
        "editorWhitespace.foreground": "#6A6A6A"
    }
};
let tomorrowNight = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "1D1F21", "token": "" },
        { "foreground": "969896", "token": "comment" },
        { "foreground": "ced1cf", "token": "keyword.operator.class" },
        { "foreground": "ced1cf", "token": "constant.other" },
        { "foreground": "ced1cf", "token": "source.php.embedded.line" },
        { "foreground": "cc6666", "token": "variable" },
        { "foreground": "cc6666", "token": "support.other.variable" },
        { "foreground": "cc6666", "token": "string.other.link" },
        { "foreground": "cc6666", "token": "string.regexp" },
        { "foreground": "cc6666", "token": "entity.name.tag" },
        { "foreground": "cc6666", "token": "entity.other.attribute-name" },
        { "foreground": "cc6666", "token": "meta.tag" },
        { "foreground": "cc6666", "token": "declaration.tag" },
        { "foreground": "cc6666", "token": "markup.deleted.git_gutter" },
        { "foreground": "de935f", "token": "constant.numeric" },
        { "foreground": "de935f", "token": "constant.language" },
        { "foreground": "de935f", "token": "support.constant" },
        { "foreground": "de935f", "token": "constant.character" },
        { "foreground": "de935f", "token": "variable.parameter" },
        { "foreground": "de935f", "token": "punctuation.section.embedded" },
        { "foreground": "de935f", "token": "keyword.other.unit" },
        { "foreground": "f0c674", "token": "entity.name.class" },
        { "foreground": "f0c674", "token": "entity.name.type.class" },
        { "foreground": "f0c674", "token": "support.type" },
        { "foreground": "f0c674", "token": "support.class" },
        { "foreground": "b5bd68", "token": "string" },
        { "foreground": "b5bd68", "token": "constant.other.symbol" },
        { "foreground": "b5bd68", "token": "entity.other.inherited-class" },
        { "foreground": "b5bd68", "token": "markup.heading" },
        { "foreground": "b5bd68", "token": "markup.inserted.git_gutter" },
        { "foreground": "8abeb7", "token": "keyword.operator" },
        { "foreground": "8abeb7", "token": "constant.other.color" },
        { "foreground": "81a2be", "token": "entity.name.function" },
        { "foreground": "81a2be", "token": "meta.function-call" },
        { "foreground": "81a2be", "token": "support.function" },
        { "foreground": "81a2be", "token": "keyword.other.special-method" },
        { "foreground": "81a2be", "token": "meta.block-level" },
        { "foreground": "81a2be", "token": "markup.changed.git_gutter" },
        { "foreground": "b294bb", "token": "keyword" },
        { "foreground": "b294bb", "token": "storage" },
        { "foreground": "b294bb", "token": "storage.type" },
        { "foreground": "b294bb", "token": "entity.name.tag.css" },
        { "foreground": "ced2cf", "background": "df5f5f", "token": "invalid" },
        { "foreground": "ced2cf", "background": "82a3bf", "token": "meta.separator" },
        { "foreground": "ced2cf", "background": "b798bf", "token": "invalid.deprecated" },
        { "foreground": "ffffff", "token": "markup.inserted.diff" },
        { "foreground": "ffffff", "token": "markup.deleted.diff" },
        { "foreground": "ffffff", "token": "meta.diff.header.to-file" },
        { "foreground": "ffffff", "token": "meta.diff.header.from-file" },
        { "foreground": "718c00", "token": "markup.inserted.diff" },
        { "foreground": "718c00", "token": "meta.diff.header.to-file" },
        { "foreground": "c82829", "token": "markup.deleted.diff" },
        { "foreground": "c82829", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.to-file" },
        { "foreground": "3e999f", "fontStyle": "italic", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#C5C8C6",
        "editor.background": "#1D1F21",
        "editor.selectionBackground": "#373B41",
        "editor.lineHighlightBackground": "#282A2E",
        "editorCursor.foreground": "#AEAFAD",
        "editorWhitespace.foreground": "#4B4E55"
    }
};
let tomorrow = {
    "base": "vs",
    "inherit": true,
    "rules": [
        { "background": "FFFFFF", "token": "" },
        { "foreground": "8e908c", "token": "comment" },
        { "foreground": "666969", "token": "keyword.operator.class" },
        { "foreground": "666969", "token": "constant.other" },
        { "foreground": "666969", "token": "source.php.embedded.line" },
        { "foreground": "c82829", "token": "variable" },
        { "foreground": "c82829", "token": "support.other.variable" },
        { "foreground": "c82829", "token": "string.other.link" },
        { "foreground": "c82829", "token": "string.regexp" },
        { "foreground": "c82829", "token": "entity.name.tag" },
        { "foreground": "c82829", "token": "entity.other.attribute-name" },
        { "foreground": "c82829", "token": "meta.tag" },
        { "foreground": "c82829", "token": "declaration.tag" },
        { "foreground": "c82829", "token": "markup.deleted.git_gutter" },
        { "foreground": "f5871f", "token": "constant.numeric" },
        { "foreground": "f5871f", "token": "constant.language" },
        { "foreground": "f5871f", "token": "support.constant" },
        { "foreground": "f5871f", "token": "constant.character" },
        { "foreground": "f5871f", "token": "variable.parameter" },
        { "foreground": "f5871f", "token": "punctuation.section.embedded" },
        { "foreground": "f5871f", "token": "keyword.other.unit" },
        { "foreground": "c99e00", "token": "entity.name.class" },
        { "foreground": "c99e00", "token": "entity.name.type.class" },
        { "foreground": "c99e00", "token": "support.type" },
        { "foreground": "c99e00", "token": "support.class" },
        { "foreground": "718c00", "token": "string" },
        { "foreground": "718c00", "token": "constant.other.symbol" },
        { "foreground": "718c00", "token": "entity.other.inherited-class" },
        { "foreground": "718c00", "token": "markup.heading" },
        { "foreground": "718c00", "token": "markup.inserted.git_gutter" },
        { "foreground": "3e999f", "token": "keyword.operator" },
        { "foreground": "3e999f", "token": "constant.other.color" },
        { "foreground": "4271ae", "token": "entity.name.function" },
        { "foreground": "4271ae", "token": "meta.function-call" },
        { "foreground": "4271ae", "token": "support.function" },
        { "foreground": "4271ae", "token": "keyword.other.special-method" },
        { "foreground": "4271ae", "token": "meta.block-level" },
        { "foreground": "4271ae", "token": "markup.changed.git_gutter" },
        { "foreground": "8959a8", "token": "keyword" },
        { "foreground": "8959a8", "token": "storage" },
        { "foreground": "8959a8", "token": "storage.type" },
        { "foreground": "ffffff", "background": "c82829", "token": "invalid" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.separator" },
        { "foreground": "ffffff", "background": "8959a8", "token": "invalid.deprecated" },
        { "foreground": "ffffff", "token": "markup.inserted.diff" },
        { "foreground": "ffffff", "token": "markup.deleted.diff" },
        { "foreground": "ffffff", "token": "meta.diff.header.to-file" },
        { "foreground": "ffffff", "token": "meta.diff.header.from-file" },
        { "background": "718c00", "token": "markup.inserted.diff" },
        { "background": "718c00", "token": "meta.diff.header.to-file" },
        { "background": "c82829", "token": "markup.deleted.diff" },
        { "background": "c82829", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.from-file" },
        { "foreground": "ffffff", "background": "4271ae", "token": "meta.diff.header.to-file" },
        { "foreground": "3e999f", "fontStyle": "italic", "token": "meta.diff.range" }
    ],
    "colors": {
        "editor.foreground": "#4D4D4C",
        "editor.background": "#FFFFFF",
        "editor.selectionBackground": "#D6D6D6",
        "editor.lineHighlightBackground": "#EFEFEF",
        "editorCursor.foreground": "#AEAFAD",
        "editorWhitespace.foreground": "#D1D1D1"
    }
};
let twilight = {
    "base": "vs-dark",
    "inherit": true,
    "rules": [
        { "background": "141414", "token": "" },
        { "foreground": "5f5a60", "fontStyle": "italic", "token": "comment" },
        { "foreground": "cf6a4c", "token": "constant" },
        { "foreground": "9b703f", "token": "entity" },
        { "foreground": "cda869", "token": "keyword" },
        { "foreground": "f9ee98", "token": "storage" },
        { "foreground": "8f9d6a", "token": "string" },
        { "foreground": "9b859d", "token": "support" },
        { "foreground": "7587a6", "token": "variable" },
        { "foreground": "d2a8a1", "fontStyle": "italic underline", "token": "invalid.deprecated" },
        { "foreground": "f8f8f8", "background": "562d56bf", "token": "invalid.illegal" },
        { "background": "b0b3ba14", "token": "text source" },
        { "background": "b1b3ba21", "token": "text.html.ruby source" },
        { "foreground": "9b5c2e", "fontStyle": "italic", "token": "entity.other.inherited-class" },
        { "foreground": "daefa3", "token": "string source" },
        { "foreground": "ddf2a4", "token": "string constant" },
        { "foreground": "e9c062", "token": "string.regexp" },
        { "foreground": "cf7d34", "token": "string.regexp constant.character.escape" },
        { "foreground": "cf7d34", "token": "string.regexp source.ruby.embedded" },
        { "foreground": "cf7d34", "token": "string.regexp string.regexp.arbitrary-repitition" },
        { "foreground": "8a9a95", "token": "string variable" },
        { "foreground": "dad085", "token": "support.function" },
        { "foreground": "cf6a4c", "token": "support.constant" },
        { "foreground": "8996a8", "token": "meta.preprocessor.c" },
        { "foreground": "afc4db", "token": "meta.preprocessor.c keyword" },
        { "foreground": "494949", "token": "meta.tag.sgml.doctype" },
        { "foreground": "494949", "token": "meta.tag.sgml.doctype entity" },
        { "foreground": "494949", "token": "meta.tag.sgml.doctype string" },
        { "foreground": "494949", "token": "meta.tag.preprocessor.xml" },
        { "foreground": "494949", "token": "meta.tag.preprocessor.xml entity" },
        { "foreground": "494949", "token": "meta.tag.preprocessor.xml string" },
        { "foreground": "ac885b", "token": "declaration.tag" },
        { "foreground": "ac885b", "token": "declaration.tag entity" },
        { "foreground": "ac885b", "token": "meta.tag" },
        { "foreground": "ac885b", "token": "meta.tag entity" },
        { "foreground": "e0c589", "token": "declaration.tag.inline" },
        { "foreground": "e0c589", "token": "declaration.tag.inline entity" },
        { "foreground": "e0c589", "token": "source entity.name.tag" },
        { "foreground": "e0c589", "token": "source entity.other.attribute-name" },
        { "foreground": "e0c589", "token": "meta.tag.inline" },
        { "foreground": "e0c589", "token": "meta.tag.inline entity" },
        { "foreground": "cda869", "token": "meta.selector.css entity.name.tag" },
        { "foreground": "8f9d6a", "token": "meta.selector.css entity.other.attribute-name.tag.pseudo-class" },
        { "foreground": "8b98ab", "token": "meta.selector.css entity.other.attribute-name.id" },
        { "foreground": "9b703f", "token": "meta.selector.css entity.other.attribute-name.class" },
        { "foreground": "c5af75", "token": "support.type.property-name.css" },
        { "foreground": "f9ee98", "token": "meta.property-group support.constant.property-value.css" },
        { "foreground": "f9ee98", "token": "meta.property-value support.constant.property-value.css" },
        { "foreground": "8693a5", "token": "meta.preprocessor.at-rule keyword.control.at-rule" },
        { "foreground": "ca7840", "token": "meta.property-value support.constant.named-color.css" },
        { "foreground": "ca7840", "token": "meta.property-value constant" },
        { "foreground": "8f9d6a", "token": "meta.constructor.argument.css" },
        { "foreground": "f8f8f8", "background": "0e2231", "fontStyle": "italic", "token": "meta.diff" },
        { "foreground": "f8f8f8", "background": "0e2231", "fontStyle": "italic", "token": "meta.diff.header" },
        { "foreground": "f8f8f8", "background": "0e2231", "fontStyle": "italic", "token": "meta.separator" },
        { "foreground": "f8f8f8", "background": "420e09", "token": "markup.deleted" },
        { "foreground": "f8f8f8", "background": "4a410d", "token": "markup.changed" },
        { "foreground": "f8f8f8", "background": "253b22", "token": "markup.inserted" },
        { "foreground": "f9ee98", "token": "markup.list" },
        { "foreground": "cf6a4c", "token": "markup.heading" }
    ],
    "colors": {
        "editor.foreground": "#F8F8F8",
        "editor.background": "#141414",
        "editor.selectionBackground": "#DDF0FF33",
        "editor.lineHighlightBackground": "#FFFFFF08",
        "editorCursor.foreground": "#A7A7A7",
        "editorWhitespace.foreground": "#FFFFFF40"
    }
};
const editorThemes = {
    "all-hallows-eve": allHallowsEve,
    "amy": amy,
    "birds-of-paradise": birdsOfParadise,
    "blackboard": blackboard,
    "brilliance-black": brillianceBlack,
    "brilliance-dull": brillianceDull,
    "chrome-dev-tools": chromeDevTools,
    "clouds-midnight": cloudsMidnight,
    "clouds": clouds,
    "cobalt": cobalt,
    "dracula": dracula,
    "dreamweaver": dreamweaver,
    "espresso-libre": espressoLibre,
    "github-dark": githubDark,
    "github-light": githubLight,
    "github": github,
    "merbivore-soft": merbivoreSoft,
    "monokai": monokai,
    "night-owl": nightOwl,
    "nord": nord,
    "oceanic-next": oceanicNext,
    "pastels-on-dark": pastelsOnDark,
    "sunburst": sunburst,
    "tomorrow-night-blue": tomorrowNightBlue,
    "tomorrow-night-bright": tomorrowNightBright,
    "tomorrow-night-eighties": tomorrowNightEighties,
    "tomorrow-night": tomorrowNight,
    "tomorrow": tomorrow,
    "twilight": twilight,
};

;// ./node_modules/@monaco-editor/loader/lib/es/_virtual/_rollupPluginBabelHelpers.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _rollupPluginBabelHelpers_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _rollupPluginBabelHelpers_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}



;// ./node_modules/state-local/lib/es/state-local.js
function state_local_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function state_local_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function state_local_objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      state_local_ownKeys(Object(source), true).forEach(function (key) {
        state_local_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      state_local_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (x) {
    return fns.reduceRight(function (y, f) {
      return f(y);
    }, x);
  };
}

function curry(fn) {
  return function curried() {
    var _this = this;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return args.length >= fn.length ? fn.apply(this, args) : function () {
      for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nextArgs[_key3] = arguments[_key3];
      }

      return curried.apply(_this, [].concat(args, nextArgs));
    };
  };
}

function isObject(value) {
  return {}.toString.call(value).includes('Object');
}

function isEmpty(obj) {
  return !Object.keys(obj).length;
}

function isFunction(value) {
  return typeof value === 'function';
}

function state_local_hasOwnProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}

function validateChanges(initial, changes) {
  if (!isObject(changes)) errorHandler('changeType');
  if (Object.keys(changes).some(function (field) {
    return !state_local_hasOwnProperty(initial, field);
  })) errorHandler('changeField');
  return changes;
}

function validateSelector(selector) {
  if (!isFunction(selector)) errorHandler('selectorType');
}

function validateHandler(handler) {
  if (!(isFunction(handler) || isObject(handler))) errorHandler('handlerType');
  if (isObject(handler) && Object.values(handler).some(function (_handler) {
    return !isFunction(_handler);
  })) errorHandler('handlersType');
}

function validateInitial(initial) {
  if (!initial) errorHandler('initialIsRequired');
  if (!isObject(initial)) errorHandler('initialType');
  if (isEmpty(initial)) errorHandler('initialContent');
}

function throwError(errorMessages, type) {
  throw new Error(errorMessages[type] || errorMessages["default"]);
}

var errorMessages = {
  initialIsRequired: 'initial state is required',
  initialType: 'initial state should be an object',
  initialContent: 'initial state shouldn\'t be an empty object',
  handlerType: 'handler should be an object or a function',
  handlersType: 'all handlers should be a functions',
  selectorType: 'selector should be a function',
  changeType: 'provided value of changes should be an object',
  changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
  "default": 'an unknown error accured in `state-local` package'
};
var errorHandler = curry(throwError)(errorMessages);
var validators = {
  changes: validateChanges,
  selector: validateSelector,
  handler: validateHandler,
  initial: validateInitial
};

function create(initial) {
  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  validators.initial(initial);
  validators.handler(handler);
  var state = {
    current: initial
  };
  var didUpdate = curry(didStateUpdate)(state, handler);
  var update = curry(updateState)(state);
  var validate = curry(validators.changes)(initial);
  var getChanges = curry(extractChanges)(state);

  function getState() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (state) {
      return state;
    };
    validators.selector(selector);
    return selector(state.current);
  }

  function setState(causedChanges) {
    compose(didUpdate, update, validate, getChanges)(causedChanges);
  }

  return [getState, setState];
}

function extractChanges(state, causedChanges) {
  return isFunction(causedChanges) ? causedChanges(state.current) : causedChanges;
}

function updateState(state, changes) {
  state.current = state_local_objectSpread2(state_local_objectSpread2({}, state.current), changes);
  return changes;
}

function didStateUpdate(state, handler, changes) {
  isFunction(handler) ? handler(state.current) : Object.keys(changes).forEach(function (field) {
    var _handler$field;

    return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);
  });
  return changes;
}

var index = {
  create: create
};

/* harmony default export */ const state_local = (index);

;// ./node_modules/@monaco-editor/loader/lib/es/config/index.js
var config_config = {
  paths: {
    vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'
  }
};

/* harmony default export */ const es_config = (config_config);

;// ./node_modules/@monaco-editor/loader/lib/es/utils/curry.js
function curry_curry(fn) {
  return function curried() {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args.length >= fn.length ? fn.apply(this, args) : function () {
      for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        nextArgs[_key2] = arguments[_key2];
      }

      return curried.apply(_this, [].concat(args, nextArgs));
    };
  };
}

/* harmony default export */ const utils_curry = (curry_curry);

;// ./node_modules/@monaco-editor/loader/lib/es/utils/isObject.js
function isObject_isObject(value) {
  return {}.toString.call(value).includes('Object');
}

/* harmony default export */ const utils_isObject = (isObject_isObject);

;// ./node_modules/@monaco-editor/loader/lib/es/validators/index.js



/**
 * validates the configuration object and informs about deprecation
 * @param {Object} config - the configuration object 
 * @return {Object} config - the validated configuration object
 */

function validateConfig(config) {
  if (!config) validators_errorHandler('configIsRequired');
  if (!utils_isObject(config)) validators_errorHandler('configType');

  if (config.urls) {
    informAboutDeprecation();
    return {
      paths: {
        vs: config.urls.monacoBase
      }
    };
  }

  return config;
}
/**
 * logs deprecation message
 */


function informAboutDeprecation() {
  console.warn(validators_errorMessages.deprecation);
}

function validators_throwError(errorMessages, type) {
  throw new Error(errorMessages[type] || errorMessages["default"]);
}

var validators_errorMessages = {
  configIsRequired: 'the configuration object is required',
  configType: 'the configuration object should be an object',
  "default": 'an unknown error accured in `@monaco-editor/loader` package',
  deprecation: "Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "
};
var validators_errorHandler = utils_curry(validators_throwError)(validators_errorMessages);
var validators_validators = {
  config: validateConfig
};

/* harmony default export */ const es_validators = (validators_validators);


;// ./node_modules/@monaco-editor/loader/lib/es/utils/compose.js
var compose_compose = function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (x) {
    return fns.reduceRight(function (y, f) {
      return f(y);
    }, x);
  };
};

/* harmony default export */ const utils_compose = (compose_compose);

;// ./node_modules/@monaco-editor/loader/lib/es/utils/deepMerge.js


function merge(target, source) {
  Object.keys(source).forEach(function (key) {
    if (source[key] instanceof Object) {
      if (target[key]) {
        Object.assign(source[key], merge(target[key], source[key]));
      }
    }
  });
  return _objectSpread2(_objectSpread2({}, target), source);
}

/* harmony default export */ const deepMerge = (merge);

;// ./node_modules/@monaco-editor/loader/lib/es/utils/makeCancelable.js
// The source (has been changed) is https://github.com/facebook/react/issues/5465#issuecomment-157888325
var CANCELATION_MESSAGE = {
  type: 'cancelation',
  msg: 'operation is manually canceled'
};

function makeCancelable(promise) {
  var hasCanceled_ = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function (val) {
      return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);
    });
    promise["catch"](reject);
  });
  return wrappedPromise.cancel = function () {
    return hasCanceled_ = true;
  }, wrappedPromise;
}

/* harmony default export */ const utils_makeCancelable = (makeCancelable);


;// ./node_modules/@monaco-editor/loader/lib/es/loader/index.js








/** the local state of the module */

var _state$create = state_local.create({
  config: es_config,
  isInitialized: false,
  resolve: null,
  reject: null,
  monaco: null
}),
    _state$create2 = _slicedToArray(_state$create, 2),
    getState = _state$create2[0],
    setState = _state$create2[1];
/**
 * set the loader configuration
 * @param {Object} config - the configuration object
 */


function loader_config(globalConfig) {
  var _validators$config = es_validators.config(globalConfig),
      monaco = _validators$config.monaco,
      config = _objectWithoutProperties(_validators$config, ["monaco"]);

  setState(function (state) {
    return {
      config: deepMerge(state.config, config),
      monaco: monaco
    };
  });
}
/**
 * handles the initialization of the monaco-editor
 * @return {Promise} - returns an instance of monaco (with a cancelable promise)
 */


function loader_init() {
  var state = getState(function (_ref) {
    var monaco = _ref.monaco,
        isInitialized = _ref.isInitialized,
        resolve = _ref.resolve;
    return {
      monaco: monaco,
      isInitialized: isInitialized,
      resolve: resolve
    };
  });

  if (!state.isInitialized) {
    setState({
      isInitialized: true
    });

    if (state.monaco) {
      state.resolve(state.monaco);
      return utils_makeCancelable(wrapperPromise);
    }

    if (window.monaco && window.monaco.editor) {
      storeMonacoInstance(window.monaco);
      state.resolve(window.monaco);
      return utils_makeCancelable(wrapperPromise);
    }

    utils_compose(injectScripts, getMonacoLoaderScript)(configureLoader);
  }

  return utils_makeCancelable(wrapperPromise);
}
/**
 * injects provided scripts into the document.body
 * @param {Object} script - an HTML script element
 * @return {Object} - the injected HTML script element
 */


function injectScripts(script) {
  return document.body.appendChild(script);
}
/**
 * creates an HTML script element with/without provided src
 * @param {string} [src] - the source path of the script
 * @return {Object} - the created HTML script element
 */


function createScript(src) {
  var script = document.createElement('script');
  return src && (script.src = src), script;
}
/**
 * creates an HTML script element with the monaco loader src
 * @return {Object} - the created HTML script element
 */


function getMonacoLoaderScript(configureLoader) {
  var state = getState(function (_ref2) {
    var config = _ref2.config,
        reject = _ref2.reject;
    return {
      config: config,
      reject: reject
    };
  });
  var loaderScript = createScript("".concat(state.config.paths.vs, "/loader.js"));

  loaderScript.onload = function () {
    return configureLoader();
  };

  loaderScript.onerror = state.reject;
  return loaderScript;
}
/**
 * configures the monaco loader
 */


function configureLoader() {
  var state = getState(function (_ref3) {
    var config = _ref3.config,
        resolve = _ref3.resolve,
        reject = _ref3.reject;
    return {
      config: config,
      resolve: resolve,
      reject: reject
    };
  });
  var require = window.require;

  require.config(state.config);

  require(['vs/editor/editor.main'], function (monaco) {
    storeMonacoInstance(monaco);
    state.resolve(monaco);
  }, function (error) {
    state.reject(error);
  });
}
/**
 * store monaco instance in local state
 */


function storeMonacoInstance(monaco) {
  if (!getState().monaco) {
    setState({
      monaco: monaco
    });
  }
}
/**
 * internal helper function
 * extracts stored monaco instance
 * @return {Object|null} - the monaco instance
 */


function __getMonacoInstance() {
  return getState(function (_ref4) {
    var monaco = _ref4.monaco;
    return monaco;
  });
}

var wrapperPromise = new Promise(function (resolve, reject) {
  return setState({
    resolve: resolve,
    reject: reject
  });
});
var loader = {
  config: loader_config,
  init: loader_init,
  __getMonacoInstance: __getMonacoInstance
};

/* harmony default export */ const es_loader = (loader);

;// ./node_modules/@monaco-editor/loader/lib/es/index.js



;// ./app/Theme.js





let Theme_callbacks = new Set();
let theme = 'dark';
let themeVer = 3;
let editorThemeName = '';
const monospaceSize = "12px";
const monospaceFont = "Consolas, Menlo, 'Roboto Mono', 'DejaVu Sans Mono'";
const monospaceWeight = "500";
function save() {
    return app_Config.save({
        theme: theme + `-${themeVer}`,
        editor_theme: editorThemeName,
    });
}
function themeVer3() {
    const blueprintTheme3 = document.getElementById("blueprint3-theme");
    const blueprintTheme5 = document.getElementById("blueprint5-theme");
    blueprintTheme3.disabled = false;
    blueprintTheme5.disabled = true;
    if (theme === "dark") {
        document.body.className = 'bp3-theme bp5-dark';
        document.documentElement.className = 'dark3-scroll';
    }
    else {
        document.body.className = 'bp3-theme';
        document.documentElement.className = '';
    }
    themeVer = 3;
}
function themeVer5() {
    const blueprintTheme3 = document.getElementById("blueprint3-theme");
    const blueprintTheme5 = document.getElementById("blueprint5-theme");
    blueprintTheme3.disabled = true;
    blueprintTheme5.disabled = false;
    if (theme === "dark") {
        document.body.className = 'bp5-dark';
        document.documentElement.className = 'dark5-scroll';
    }
    else {
        document.body.className = '';
        document.documentElement.className = '';
    }
    themeVer = 5;
}
function light() {
    theme = 'light';
    if (themeVer === 3) {
        document.body.className = 'bp3-theme';
        document.documentElement.className = '';
    }
    else {
        document.body.className = '';
        document.documentElement.className = '';
    }
    Theme_callbacks.forEach((callback) => {
        callback();
    });
}
function dark() {
    theme = 'dark';
    if (themeVer === 3) {
        document.body.className = 'bp3-theme bp5-dark';
        document.documentElement.className = 'dark3-scroll';
    }
    else {
        document.body.className = 'bp5-dark';
        document.documentElement.className = 'dark5-scroll';
    }
    Theme_callbacks.forEach((callback) => {
        callback();
    });
}
function toggle() {
    if (theme === "light") {
        dark();
    }
    else {
        light();
    }
}
function toggleVer() {
    if (themeVer === 5) {
        themeVer3();
    }
    else {
        themeVer5();
    }
}
function getEditorTheme() {
    if (!editorThemeName) {
        if (theme === "light") {
            return "github-light";
        }
        else {
            return "github-dark";
        }
    }
    return editorThemeName;
}
function setEditorTheme(name) {
    editorThemeName = name;
    Theme_callbacks.forEach((callback) => {
        callback();
    });
}
function Theme_addChangeListener(callback) {
    Theme_callbacks.add(callback);
}
function Theme_removeChangeListener(callback) {
    Theme_callbacks.delete(callback);
}
let editorThemeNames = {};
es_loader.config({
    paths: {
        vs: uriFromPath(external_path_default().join(__dirname, "static", "vs")),
    },
});
es_loader.init().then((monaco) => {
    for (let themeName in editorThemes) {
        let editorTheme = editorThemes[themeName];
        monaco.editor.defineTheme(themeName, editorTheme);
        let formattedThemeName = titleCase(themeName.replaceAll("-", " "));
        editorThemeNames[themeName] = formattedThemeName;
    }
});

;// ./app/dispatcher/Base.js
var _prefix = 'ID_';
class DispatcherBase {
    constructor() {
        this._callbacks = {};
        this._isDispatching = false;
        this._isHandled = {};
        this._isPending = {};
        this._lastID = 1;
    }
    register(callback) {
        var id = _prefix + this._lastID++;
        this._callbacks[id] = callback;
        return id;
    }
    unregister(id) {
        console.error(this._callbacks[id], 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id);
        delete this._callbacks[id];
    }
    waitFor(ids) {
        console.error(this._isDispatching, 'Dispatcher.waitFor(...): Must be invoked while dispatching.');
        for (var ii = 0; ii < ids.length; ii++) {
            var id = ids[ii];
            if (this._isPending[id]) {
                console.error(this._isHandled[id], 'Dispatcher.waitFor(...): Circular dependency detected while ' +
                    'waiting for `%s`.', id);
                continue;
            }
            console.error(this._callbacks[id], 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id);
            this._invokeCallback(id);
        }
    }
    dispatch(payload) {
        this._startDispatching(payload);
        try {
            for (var id in this._callbacks) {
                if (this._isPending[id]) {
                    continue;
                }
                this._invokeCallback(id);
            }
        }
        finally {
            this._stopDispatching();
        }
    }
    isDispatching() {
        return this._isDispatching;
    }
    _invokeCallback(id) {
        this._isPending[id] = true;
        this._callbacks[id](this._pendingPayload);
        this._isHandled[id] = true;
    }
    _startDispatching(payload) {
        for (var id in this._callbacks) {
            this._isPending[id] = false;
            this._isHandled[id] = false;
        }
        this._pendingPayload = payload;
        this._isDispatching = true;
    }
    _stopDispatching() {
        delete this._pendingPayload;
        this._isDispatching = false;
    }
}

;// ./app/dispatcher/Dispatcher.js

class Dispatcher_Dispatcher extends DispatcherBase {
}
/* harmony default export */ const dispatcher_Dispatcher = (new Dispatcher_Dispatcher());

;// ./app/dispatcher/EventDispatcher.js

class EventDispatcher extends DispatcherBase {
}
/* harmony default export */ const dispatcher_EventDispatcher = (new EventDispatcher());

;// ./app/types/LoadingTypes.js
const ADD = 'loading.add';
const DONE = 'loading.done';

;// ./app/Loader.js



class Loader {
    constructor() {
        this._id = uuid();
    }
    loading() {
        dispatcher_Dispatcher.dispatch({
            type: ADD,
            data: {
                id: this._id,
            },
        });
        return this;
    }
    done() {
        dispatcher_Dispatcher.dispatch({
            type: DONE,
            data: {
                id: this._id,
            },
        });
        return this;
    }
}

;// ./app/actions/ServiceActions.js





function connect(prfl, noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    return new Promise((resolve) => {
        post('/profile')
            .timeout(120)
            .set('Accept', 'application/json')
            .send(prfl)
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            resolve();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "Profiles: Profile connect failed");
            errorAlert(err);
            resolve();
            return;
        });
    });
}
function disconnect(prfl, noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    return new Promise((resolve) => {
        del('/profile/' + prfl.id)
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            resolve();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "Profiles: Profile disconnect failed");
            errorAlert(err);
            resolve();
            return;
        });
    });
}
async function tokenUpdate(prfl, noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    let valid = false;
    let serverPubKey = "";
    if (prfl.server_public_key) {
        serverPubKey = prfl.server_public_key.join("\n");
    }
    try {
        let resp = await put('/token')
            .set('Accept', 'application/json')
            .send({
            profile: prfl.id,
            server_public_key: serverPubKey,
            server_box_public_key: prfl.server_box_public_key,
            ttl: prfl.token_ttl,
        })
            .end();
        if (resp.status !== 200) {
            let err = new RequestError(null, "Profiles: Token update request error " + resp.status);
            errorAlert(err, 10);
        }
        else {
            let data = resp.jsonPassive();
            if (data) {
                valid = !!data.valid;
            }
        }
    }
    catch (err) {
        err = new RequestError(err, "Profiles: Token update request failed");
        errorAlert(err, 10);
    }
    if (loader) {
        loader.done();
    }
    return valid;
}
async function tokenDelete(prfl, noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    try {
        await del('/token/' + prfl.id)
            .end();
    }
    catch (err) {
        err = new RequestError(err, "Profiles: Token update request failed");
        errorAlert(err, 10);
    }
    if (loader) {
        loader.done();
    }
}
function resetDns(noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    return new Promise((resolve) => {
        post("/network/reset_dns")
            .set("Accept", "application/json")
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            if (resp.status !== 200) {
                let err = new RequestError(null, "System: DNS reset failed", {
                    status: resp.status.toString()
                });
                errorAlert(err);
                return;
            }
            success("System: DNS reset successful");
            resolve();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "System: DNS reset failed");
            errorAlert(err);
            resolve();
            return;
        });
    });
}
function resetAll(noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    return new Promise((resolve) => {
        post("/network/reset_all")
            .set("Accept", "application/json")
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            if (resp.status !== 200) {
                let err = new RequestError(null, "System: Network reset failed", {
                    status: resp.status.toString()
                });
                errorAlert(err);
                return;
            }
            success("System: Network reset successful");
            resolve();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "System: Network reset failed");
            errorAlert(err);
            resolve();
            return;
        });
    });
}
function resetEnclave(noLoading) {
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    return new Promise((resolve) => {
        post("/reset_enclave")
            .set("Accept", "application/json")
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            if (resp.status !== 200) {
                let err = new RequestError(null, "System: Secure Enclave reset failed", {
                    status: resp.status.toString()
                });
                errorAlert(err);
                return;
            }
            success("System: Secure Enclave reset successful");
            resolve();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "System: Secure Enclave reset failed");
            errorAlert(err);
            resolve();
            return;
        });
    });
}

// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
var external_util_default = /*#__PURE__*/__webpack_require__.n(external_util_);
;// ./app/types/ProfileTypes.js














const SYNC = "profile.sync";
const SYNC_STATE = "profile.sync_state";
const SYNC_ALL = "profile.sync_all";
const TRAVERSE = "profile.traverse";
const FILTER = "profile.filter";
const CHANGE = "profile.change";
function New(self) {
    self.formattedName = function () {
        if (this.name) {
            return this.name;
        }
        return this.server + " (" + this.user + ")";
    };
    self.formattedNameShort = function () {
        if (this.name) {
            return this.name;
        }
        return this.server;
    };
    self.formattedStatus = function () {
        if (!this.status) {
            if (this.system && this.state) {
                return "Connecting";
            }
            return "Disconnected";
        }
        switch (this.status) {
            case "connected":
                return "Connected";
            case "connecting":
                return "Connecting";
            case "authenticating":
                return "Authenticating";
            case "reconnecting":
                return "Reconnecting";
            case "disconnecting":
                if (this.system && this.state) {
                    return "Reconnecting";
                }
                return "Disconnecting";
            default:
                return this.status;
        }
    };
    self.formattedUptime = function () {
        if (!this.timestamp || this.status !== "connected") {
            return "";
        }
        let curTime = Math.floor((new Date).getTime() / 1000);
        let uptime = curTime - this.timestamp;
        let units;
        let unitStr;
        let uptimeItems = [];
        let hasDays = false;
        if (uptime > 86400) {
            hasDays = true;
            units = Math.floor(uptime / 86400);
            uptime -= units * 86400;
            unitStr = units + " day";
            if (units > 1) {
                unitStr += "s";
            }
            uptimeItems.push(unitStr);
        }
        if (uptime > 3600) {
            units = Math.floor(uptime / 3600);
            uptime -= units * 3600;
            unitStr = units + " hour";
            if (units > 1) {
                unitStr += "s";
            }
            uptimeItems.push(unitStr);
        }
        if (uptime > 60) {
            units = Math.floor(uptime / 60);
            uptime -= units * 60;
            unitStr = units + " min";
            if (units > 1) {
                unitStr += "s";
            }
            uptimeItems.push(unitStr);
        }
        if (uptime && !hasDays) {
            unitStr = uptime + " sec";
            if (uptime > 1) {
                unitStr += "s";
            }
            uptimeItems.push(unitStr);
        }
        return uptimeItems.join(" ");
    };
    self.formatedHosts = function () {
        let count = 0;
        let hosts = [];
        for (let hostAddr of (this.sync_hosts || [])) {
            count += 1;
            if (count > 8) {
                hosts.push('...');
                break;
            }
            try {
                let url = new URL(hostAddr);
                hosts.push(url.hostname + (url.port ? (":" + url.port) : ""));
            }
            catch { }
        }
        return hosts;
    };
    self.authTypes = function () {
        let passwordMode = this.password_mode;
        if (!passwordMode && this.ovpn_data &&
            this.ovpn_data.indexOf("auth-user-pass") !== -1) {
            if (this.user) {
                passwordMode = "otp";
            }
            else {
                passwordMode = "username_password";
            }
        }
        return passwordMode.split("_");
    };
    self.confPath = function () {
        return external_path_default().join(dataPath, "profiles", this.id + ".conf");
    };
    self.dataPath = function () {
        return external_path_default().join(dataPath, "profiles", this.id + ".ovpn");
    };
    self.encryptKey = async function (data) {
        let encryptionAvailable = await encryptAvailable();
        if (!encryptionAvailable) {
            return data;
        }
        let sIndex;
        let eIndex;
        let keyData = "";
        sIndex = data.indexOf("<tls-auth>");
        eIndex = data.indexOf("</tls-auth>\n");
        if (sIndex > 0 && eIndex > 0) {
            keyData += data.substring(sIndex, eIndex + 12);
            data = data.substring(0, sIndex) + data.substring(eIndex + 12, data.length);
        }
        sIndex = data.indexOf("<tls-crypt>");
        eIndex = data.indexOf("</tls-crypt>\n");
        if (sIndex > 0 && eIndex > 0) {
            keyData += data.substring(sIndex, eIndex + 13);
            data = data.substring(0, sIndex) + data.substring(eIndex + 13, data.length);
        }
        sIndex = data.indexOf("<key>");
        eIndex = data.indexOf("</key>\n");
        if (sIndex > 0 && eIndex > 0) {
            keyData += data.substring(sIndex, eIndex + 7);
            data = data.substring(0, sIndex) + data.substring(eIndex + 7, data.length);
        }
        if (!keyData) {
            if (platform === "darwin") {
                let resp = await exec("/usr/bin/security", "find-generic-password", "-w", "-s", "pritunl", "-a", this.id);
                if (resp.error) {
                    return data;
                }
                keyData = new Buffer(resp.stdout.replace("\n", ""), "base64").toString();
            }
            if (!keyData) {
                return data;
            }
        }
        this.key_data = await encryptString(keyData);
        await this.writeConf();
        if (platform === "darwin") {
            exec("/usr/bin/security", "delete-generic-password", "-s", "pritunl", "-a", this.id);
        }
        return data;
    };
    self.extractKey = async function (data) {
        let sIndex;
        let eIndex;
        let keyData = "";
        sIndex = data.indexOf("<tls-auth>");
        eIndex = data.indexOf("</tls-auth>\n");
        if (sIndex > 0 && eIndex > 0) {
            keyData += data.substring(sIndex, eIndex + 12);
        }
        sIndex = data.indexOf("<tls-crypt>");
        eIndex = data.indexOf("</tls-crypt>\n");
        if (sIndex > 0 && eIndex > 0) {
            keyData += data.substring(sIndex, eIndex + 13);
        }
        sIndex = data.indexOf("<key>");
        eIndex = data.indexOf("</key>\n");
        if (sIndex > 0 && eIndex > 0) {
            keyData += data.substring(sIndex, eIndex + 7);
        }
        if (!keyData) {
            if (this.key_data) {
                return data;
            }
            if (platform === "darwin") {
                let resp = await exec("/usr/bin/security", "find-generic-password", "-w", "-s", "pritunl", "-a", this.id);
                if (resp.error) {
                    let err = new ReadError(resp.error, "Profiles: Failed to get key from keychain");
                    errorAlert(err);
                    return data;
                }
                data += new Buffer(resp.stdout.replace("\n", ""), "base64").toString();
            }
        }
        return data;
    };
    self.exportConf = function () {
        return JSON.stringify({
            name: this.name,
            wg: this.wg,
            last_mode: this.last_mode,
            organization_id: this.organization_id,
            organization: this.organization,
            server_id: this.server_id,
            server: this.server,
            user_id: this.user_id,
            user: this.user,
            pre_connect_msg: this.pre_connect_msg,
            remotes_data: this.remotes_data,
            dynamic_firewall: this.dynamic_firewall,
            geo_sort: this.geo_sort,
            force_connect: this.force_connect,
            device_auth: this.device_auth,
            disable_reconnect_local: this.disable_reconnect_local,
            disable_gateway: this.disable_gateway,
            disable_dns: this.disable_dns,
            force_dns: this.force_dns,
            sso_auth: this.sso_auth,
            password_mode: this.password_mode,
            token: this.token,
            token_ttl: this.token_ttl,
            disable_reconnect: this.disable_reconnect,
            restrict_client: this.restrict_client,
            disabled: this.disabled,
            sync_time: this.sync_time,
            sync_hosts: this.sync_hosts,
            sync_hash: this.sync_hash,
            sync_secret: this.sync_secret,
            sync_token: this.sync_token,
            server_public_key: this.server_public_key,
            server_box_public_key: this.server_box_public_key,
            registration_key: this.registration_key,
            key_data: this.key_data,
        });
    };
    self.importConf = function (data) {
        this.name = data.name;
        this.wg = data.wg;
        this.organization_id = data.organization_id;
        this.organization = data.organization;
        this.server_id = data.server_id;
        this.server = data.server;
        this.user_id = data.user_id;
        this.user = data.user;
        this.pre_connect_msg = data.pre_connect_msg;
        this.remotes_data = data.remotes_data;
        this.dynamic_firewall = data.dynamic_firewall;
        this.geo_sort = data.geo_sort;
        this.force_connect = data.force_connect;
        this.device_auth = data.device_auth;
        this.disable_reconnect_local = data.disable_reconnect_local;
        this.disable_gateway = data.disable_gateway;
        this.disable_dns = data.disable_dns;
        this.force_dns = data.force_dns;
        this.sso_auth = data.sso_auth;
        this.password_mode = data.password_mode;
        this.token = data.token;
        this.token_ttl = data.token_ttl;
        this.disable_reconnect = data.disable_reconnect;
        this.restrict_client = data.restrict_client;
        this.sync_time = data.sync_time;
        this.sync_hosts = data.sync_hosts || [];
        this.sync_hash = data.sync_hash;
        this.sync_secret = data.sync_secret;
        this.sync_token = data.sync_token;
        this.server_public_key = data.server_public_key;
        this.server_box_public_key = data.server_box_public_key;
        this.key_data = data.key_data;
    };
    self.exportSystem = function () {
        return {
            id: this.id,
            name: this.name,
            wg: this.wg,
            last_mode: this.last_mode,
            organization_id: this.organization_id,
            organization: this.organization,
            server_id: this.server_id,
            server: this.server,
            user_id: this.user_id,
            user: this.user,
            pre_connect_msg: this.pre_connect_msg,
            remotes_data: this.remotes_data,
            dynamic_firewall: this.dynamic_firewall,
            geo_sort: this.geo_sort,
            force_connect: this.force_connect,
            device_auth: this.device_auth,
            disable_gateway: this.disable_gateway,
            disable_dns: this.disable_dns,
            force_dns: this.force_dns,
            sso_auth: this.sso_auth,
            password_mode: this.password_mode,
            token: this.token,
            token_ttl: this.token_ttl,
            disable_reconnect: this.disable_reconnect,
            restrict_client: this.restrict_client,
            disabled: this.disabled,
            sync_time: this.sync_time,
            sync_hosts: this.sync_hosts,
            sync_hash: this.sync_hash,
            sync_secret: this.sync_secret,
            sync_token: this.sync_token,
            server_public_key: this.server_public_key,
            server_box_public_key: this.server_box_public_key,
            registration_key: this.registration_key,
            ovpn_data: this.ovpn_data,
        };
    };
    self.upsertConf = function (data) {
        this.name = data.name || this.name;
        this.wg = data.wg || false;
        this.organization_id = data.organization_id || this.organization_id;
        this.organization = data.organization || this.organization;
        this.server_id = data.server_id || this.server_id;
        this.server = data.server || this.server;
        this.user_id = data.user_id || this.user_id;
        this.user = data.user || this.user;
        this.pre_connect_msg = data.pre_connect_msg;
        this.remotes_data = data.remotes_data;
        this.dynamic_firewall = data.dynamic_firewall;
        this.geo_sort = data.geo_sort;
        this.force_connect = data.force_connect;
        this.device_auth = data.device_auth;
        this.disable_reconnect_local = data.disable_reconnect_local;
        this.disable_gateway = data.disable_gateway;
        this.disable_dns = data.disable_dns;
        this.sso_auth = data.sso_auth;
        this.password_mode = data.password_mode;
        this.token = data.token;
        this.token_ttl = data.token_ttl;
        this.disable_reconnect = data.disable_reconnect;
        this.restrict_client = data.restrict_client;
        this.sync_hosts = data.sync_hosts;
        this.sync_hash = data.sync_hash;
        this.server_public_key = data.server_public_key;
        this.server_box_public_key = data.server_box_public_key;
    };
    self.convertSystem = async function () {
        if (this.system) {
            return;
        }
        try {
            await disconnect(this);
        }
        catch { }
        this.ovpn_data = await this.readData();
        try {
            await put('/sprofile')
                .set('Accept', 'application/json')
                .send(this.exportSystem())
                .end();
        }
        catch (err) {
            err = new RequestError(err, "Profiles: Failed to save system profile");
            errorAlert(err);
            sync();
            return;
        }
        await this.delete();
        sync();
    };
    self.convertUser = async function () {
        if (!this.system) {
            return;
        }
        if (this.force_connect) {
            let err = new WriteError(null, "Profiles: Profile autostart enforced by server", { profile_id: this.id });
            errorAlert(err, 10);
            return;
        }
        try {
            await disconnect(this);
        }
        catch { }
        try {
            await del('/sprofile/' + this.id)
                .set('Accept', 'application/json')
                .end();
        }
        catch (err) {
            err = new RequestError(err, "Profiles: Failed to delete system profile");
            errorAlert(err);
            sync();
            return;
        }
        this.system = false;
        await this.writeConf();
        await this.writeData(this.ovpn_data);
        this.ovpn_data = "";
        sync();
    };
    self.writeConf = function () {
        if (this.system) {
            return new Promise((resolve) => {
                put('/sprofile')
                    .set('Accept', 'application/json')
                    .send(this.exportSystem())
                    .end()
                    .then((resp) => {
                    resolve();
                    sync();
                }, (err) => {
                    err = new RequestError(err, "Profiles: Failed to save system profile");
                    errorAlert(err);
                    resolve();
                    return;
                });
            });
        }
        return new Promise((resolve) => {
            let profilePath = this.confPath();
            external_fs_default().writeFile(profilePath, this.exportConf(), (err) => {
                if (err) {
                    err = new ReadError(err, "Profiles: Profile write error", { profile_path: profilePath });
                    errorAlert(err, 10);
                    resolve();
                    return;
                }
                resolve();
            });
        });
    };
    self.readData = async function () {
        if (this.system) {
            return this.ovpn_data;
        }
        let data = "";
        try {
            data = await fileRead(this.dataPath());
        }
        catch (err) {
            errorAlert(err);
            return "";
        }
        for (let line of data.split("\n")) {
            if (line.startsWith("setenv UV_NAME")) {
                let lineSpl = line.split(" ");
                this.device_name = lineSpl[lineSpl.length - 1];
                break;
            }
        }
        if (this.key_data) {
            let decKeyData = await decryptString(this.key_data);
            data += decKeyData;
        }
        else if (platform === "darwin") {
            data = await this.extractKey(data);
        }
        return data;
    };
    self.writeData = function (data) {
        if (this.system) {
            this.ovpn_data = data;
            return new Promise((resolve, reject) => {
                put('/sprofile')
                    .set('Accept', 'application/json')
                    .send(this.exportSystem())
                    .end()
                    .then((resp) => {
                    resolve();
                    sync();
                }, (err) => {
                    err = new RequestError(err, "Profiles: Failed to save system profile");
                    errorAlert(err);
                    resolve();
                    return;
                });
            });
        }
        return new Promise((resolve) => {
            let profilePath = this.dataPath();
            if (!app_Config.safe_storage) {
                this.extractKey(data).then((newData) => {
                    external_fs_default().writeFile(profilePath, newData, (err) => {
                        if (err) {
                            err = new WriteError(err, "Profiles: Profile write error", { profile_path: profilePath });
                            errorAlert(err, 10);
                            resolve();
                            return;
                        }
                        resolve();
                    });
                });
            }
            else {
                this.encryptKey(data).then((newData) => {
                    external_fs_default().writeFile(profilePath, newData, (err) => {
                        if (err) {
                            err = new WriteError(err, "Profiles: Profile write error", { profile_path: profilePath });
                            errorAlert(err, 10);
                            resolve();
                            return;
                        }
                        resolve();
                    });
                });
            }
        });
    };
    self.readLog = async function () {
        let logData = "";
        try {
            let resp = await get('/log/' + this.id)
                .end();
            logData = resp.data;
        }
        catch (err) {
            err = new RequestError(err, "Profiles: Profile log request error");
            errorAlert(err, 10);
        }
        return logData;
    };
    self.clearLog = async function () {
        try {
            await del('/log/' + this.id)
                .end();
        }
        catch (err) {
            err = new RequestError(err, "Profiles: Profile log request error");
            errorAlert(err, 10);
        }
    };
    self.delete = async function () {
        try {
            await disconnect(this);
        }
        catch {
        }
        if (this.system) {
            try {
                await del('/sprofile/' + this.id)
                    .set('Accept', 'application/json')
                    .end();
            }
            catch (err) {
                errorAlert(err, 10);
            }
        }
        if (platform === "darwin") {
            await exec("/usr/bin/security", "delete-generic-password", "-s", "pritunl", "-a", this.id);
        }
        try {
            await del('/log/' + this.id)
                .set('Accept', 'application/json')
                .end();
        }
        catch (err) {
            errorAlert(err, 10);
        }
        try {
            await fileDelete(this.confPath());
        }
        catch { }
        try {
            await fileDelete(this.dataPath());
        }
        catch { }
    };
    self._importSync = async function (data) {
        let sIndex;
        let eIndex;
        let tlsAuth = "";
        let cert = "";
        let key = "";
        let jsonData = "";
        let jsonFound = null;
        let origData = await this.readData();
        let dataLines = origData.split("\n");
        let line;
        let uvId;
        let uvName;
        for (let i = 0; i < dataLines.length; i++) {
            line = dataLines[i];
            if (line.startsWith("setenv UV_ID ")) {
                uvId = line;
            }
            else if (line.startsWith("setenv UV_NAME ")) {
                uvName = line;
            }
        }
        dataLines = data.split("\n");
        data = "";
        for (let i = 0; i < dataLines.length; i++) {
            line = dataLines[i];
            if (jsonFound === null && line === "#{") {
                jsonFound = true;
            }
            if (jsonFound === true && line.startsWith("#")) {
                if (line === "#}") {
                    jsonFound = false;
                }
                jsonData += line.replace("#", "");
            }
            else {
                if (line.startsWith("setenv UV_ID ")) {
                    line = uvId;
                }
                else if (line.startsWith("setenv UV_NAME ")) {
                    line = uvName;
                }
                data += line + '\n';
            }
        }
        let confData;
        try {
            confData = JSON.parse(jsonData);
        }
        catch {
        }
        if (confData) {
            this.sync_time = Math.round(Date.now() / 1000);
            this.upsertConf(confData);
            await this.writeConf();
        }
        let curData = "";
        try {
            curData = await this.readData();
        }
        catch (err) {
            Logger_error(err);
            return;
        }
        if (curData.indexOf("key-direction") >= 0 && data.indexOf("key-direction") < 0) {
            tlsAuth += "key-direction 1\n";
        }
        sIndex = curData.indexOf("<tls-auth>");
        eIndex = curData.indexOf("</tls-auth>");
        if (sIndex >= 0 && eIndex >= 0) {
            tlsAuth += curData.substring(sIndex, eIndex + 11) + "\n";
        }
        sIndex = curData.indexOf("<tls-crypt>");
        eIndex = curData.indexOf("</tls-crypt>");
        if (sIndex >= 0 && eIndex >= 0) {
            tlsAuth += curData.substring(sIndex, eIndex + 12) + "\n";
        }
        sIndex = curData.indexOf("<cert>");
        eIndex = curData.indexOf("</cert>");
        if (sIndex >= 0 && eIndex >= 0) {
            cert = curData.substring(sIndex, eIndex + 7) + "\n";
        }
        sIndex = curData.indexOf("<key>");
        eIndex = curData.indexOf("</key>");
        if (sIndex >= 0 && eIndex >= 0) {
            key = curData.substring(sIndex, eIndex + 6) + "\n";
        }
        try {
            await this.writeData(data + tlsAuth + cert + key);
        }
        catch (err) {
            Logger_error(err);
            return;
        }
    };
    self._sync = function (syncHost) {
        return new Promise((resolve, reject) => {
            let path = external_util_default().format('/key/sync/%s/%s/%s/%s', this.organization_id, this.user_id, this.server_id, this.sync_hash);
            let authTimestamp = Math.floor(new Date().getTime() / 1000).toString();
            let authNonce = nonce();
            let authString = [this.sync_token, authTimestamp,
                authNonce, "GET", path].join("&");
            let authSignature = external_crypto_default().createHmac("sha512", this.sync_secret).update(authString).digest("base64");
            let req = new Request_Request();
            req.get(path)
                .tcp(syncHost)
                .timeout(5)
                .secure(false)
                .set("Auth-Token", token)
                .set("User-Agent", "pritunl")
                .set("Auth-Token", this.sync_token)
                .set("Auth-Timestamp", authTimestamp)
                .set("Auth-Nonce", authNonce)
                .set("Auth-Signature", authSignature)
                .end()
                .then((resp) => {
                if (resp.status !== 200) {
                    let err;
                    switch (resp.status) {
                        case 480:
                            Logger_info("Profiles: Skipping profile sync, requires subscription");
                            break;
                        case 404:
                            err = new RequestError(null, "Profiles: Failed to sync profile, user not found");
                            reject(err);
                            return;
                        case 401:
                            err = new RequestError(null, "Profiles: Failed to sync profile, authentication failed");
                            reject(err);
                            return;
                        default:
                            err = new RequestError(null, "Profiles: Failed to sync profile, status: " + resp.status);
                            reject(err);
                            return;
                    }
                    resolve("");
                    return;
                }
                let syncData;
                try {
                    syncData = resp.json();
                }
                catch (err) {
                    reject(err);
                    return;
                }
                if (!syncData.signature || !syncData.conf) {
                    resolve("");
                    return;
                }
                let confSignature = external_crypto_default().createHmac("sha512", this.sync_secret).update(syncData.conf).digest("base64");
                if (confSignature !== syncData.signature) {
                    let err = new ParseError(null, "Profiles: Failed to sync profile, signature invalid");
                    reject(err);
                    return;
                }
                resolve(syncData.conf);
            }, (err) => {
                err = new RequestError(err, "Profiles: Failed to sync profile configuration");
                reject(err);
                return;
            });
        });
    };
    self.getAuthType = function (data) {
        if (this.password_mode) {
            return this.password_mode || null;
        }
        if (data.indexOf("auth-user-pass") !== -1) {
            if (this.user) {
                return "otp";
            }
            return "username_password";
        }
        else {
            return null;
        }
    };
    self.sync = async function () {
        if (!this.sync_hosts || !this.sync_hosts.length) {
            return;
        }
        let syncHosts = shuffle([...this.sync_hosts]);
        let syncData;
        let syncError;
        for (let syncHost of syncHosts) {
            if (!syncHost) {
                continue;
            }
            try {
                syncData = await this._sync(syncHost);
                syncError = null;
                break;
            }
            catch (err) {
                syncError = err;
            }
        }
        if (syncError) {
            Logger_error(syncError);
            this.sync_time = -1;
            await this.writeConf();
        }
        if (syncData) {
            try {
                await this._importSync(syncData);
            }
            catch (err) {
                err = new ParseError(err, "Profiles: Failed to parse profile sync", { profile_id: this.id });
                Logger_error(err);
                this.sync_time = -1;
                await this.writeConf();
            }
        }
    };
    return self;
}

// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(4434);
;// ./app/EventEmitter.js

class EventEmitter extends external_events_.EventEmitter {
    emitDefer(event, ...args) {
        setTimeout(() => {
            this.emit(event, ...args);
        });
    }
}

;// ./app/types/GlobalTypes.js
const GlobalTypes_CHANGE = 'change';
const RESET = 'reset';
const RELOAD = 'reload';

;// ./app/stores/ProfilesStore.js




class ProfilesStore extends EventEmitter {
    constructor() {
        super(...arguments);
        this._profiles = [];
        this._filter = null;
        this._map = {};
        this._token = dispatcher_Dispatcher.register((this._callback).bind(this));
    }
    _reset() {
        this._profiles = [];
        this._page = undefined;
        this._pageCount = undefined;
        this._filter = null;
        this._count = undefined;
        this._map = {};
        this.emitChange();
    }
    get profiles() {
        return this._profiles;
    }
    get profilesM() {
        let profiles = [];
        this._profiles.forEach((profile) => {
            profiles.push({
                ...profile,
            });
        });
        return profiles;
    }
    get page() {
        return this._page || 0;
    }
    get pageCount() {
        return this._pageCount || 20;
    }
    get pages() {
        return Math.ceil(this.count / this.pageCount);
    }
    get filter() {
        return this._filter;
    }
    get count() {
        return this._count || 0;
    }
    profile(id) {
        let i = this._map[id];
        if (i === undefined) {
            return null;
        }
        return this._profiles[i];
    }
    emitChange() {
        this.emitDefer(GlobalTypes_CHANGE);
    }
    addChangeListener(callback) {
        this.on(GlobalTypes_CHANGE, callback);
    }
    removeChangeListener(callback) {
        this.removeListener(GlobalTypes_CHANGE, callback);
    }
    _traverse(page) {
        this._page = Math.min(this.pages, page);
    }
    _filterCallback(filter) {
        if ((this._filter !== null && filter === null) ||
            (!Object.keys(this._filter).length && filter !== null) || (filter && this._filter && (filter.name !== this._filter.name))) {
            this._traverse(0);
        }
        this._filter = filter;
        this.emitChange();
    }
    _sync(prfls, systemPrfls) {
        for (let prfl of systemPrfls) {
            prfl.system = true;
        }
        let profiles = [];
        let profilesData = prfls.concat(systemPrfls);
        let names = [];
        let namesMap = {};
        for (let prflData of profilesData) {
            let prfl = New(prflData);
            let name = prfl.formattedName();
            let prflsName = namesMap[name];
            if (!prflsName) {
                prflsName = [];
            }
            prflsName.push(prfl);
            names.push(name);
            namesMap[name] = prflsName;
        }
        names.sort();
        this._map = {};
        let count = 0;
        for (let name of names) {
            for (let prlf of namesMap[name]) {
                this._map[prlf.id] = count;
                profiles.push(prlf);
                count += 1;
            }
        }
        this._count = profiles.length;
        this._profiles = profiles;
        this._page = Math.min(this.pages, this.page);
    }
    _syncState(profiles) {
        for (let prflId in profiles) {
            let prflState = profiles[prflId];
            let index = this._map[prflState.id];
            if (index === undefined) {
                continue;
            }
            let prfl = {
                ...this._profiles[index],
            };
            prfl.status = prflState.status;
            prfl.timestamp = prflState.timestamp;
            prfl.server_addr = prflState.server_addr;
            prfl.client_addr = prflState.client_addr;
            prfl.auth_reconnect = prflState.auth_reconnect;
            this._profiles[index] = prfl;
        }
    }
    _callback(action) {
        switch (action.type) {
            case RESET:
                this._reset();
                break;
            case TRAVERSE:
                this._traverse(action.data.page);
                break;
            case FILTER:
                this._filterCallback(action.data.filter);
                break;
            case SYNC:
                this._sync(action.data.profiles, action.data.profilesSystem);
                this.emitChange();
                break;
            case SYNC_STATE:
                this._syncState(action.data.profilesState);
                this.emitChange();
                break;
            case SYNC_ALL:
                this._sync(action.data.profiles, action.data.profilesSystem);
                this._syncState(action.data.profilesState);
                this.emitChange();
                break;
        }
    }
}
/* harmony default export */ const stores_ProfilesStore = (new ProfilesStore());

;// ./app/actions/ProfileActions.js
















const css = {
    updateButton: {
        marginTop: "7px",
    },
};
let syncId;
function loadSystemProfiles() {
    return new Promise((resolve) => {
        get('/sprofile')
            .set('Accept', 'application/json')
            .end()
            .then((resp) => {
            if (resp.status !== 200) {
                let err = new ReadError(null, "Profiles: Failed to load service profiles", { body: resp.data });
                Logger_error(err);
                resolve([]);
                return;
            }
            resolve(resp.json());
        }, (err) => {
            err = new RequestError(err, "Profiles: Service load error");
            errorAlert2(err);
            resolve([]);
            return;
        });
    });
}
function loadProfile(prflId, prflPath) {
    let ovpnPath = prflPath.substring(0, prflPath.length - 5) + ".ovpn";
    let logPath = prflPath.substring(0, prflPath.length - 5) + ".log";
    return new Promise((resolve, reject) => {
        if (external_os_default().platform() !== "win32") {
            external_fs_default().stat(prflPath, function (err, stats) {
                if (err && err.code === "ENOENT") {
                    return;
                }
                let mode;
                try {
                    mode = (stats.mode & 0o777).toString(8);
                }
                catch (err) {
                    err = new ReadError(err, "Profiles: Failed to stat profile", { profile_path: prflPath });
                    errorAlert(err);
                    return;
                }
                if (mode !== "600") {
                    external_fs_default().chmod(prflPath, 0o600, function (err) {
                        if (err) {
                            err = new ReadError(err, "Profiles: Failed to stat profile", { profile_path: prflPath });
                            errorAlert(err);
                        }
                    });
                }
            });
            external_fs_default().stat(ovpnPath, function (err, stats) {
                if (err && err.code === "ENOENT") {
                    return;
                }
                let mode;
                try {
                    mode = (stats.mode & 0o777).toString(8);
                }
                catch (err) {
                    err = new ReadError(err, "Profiles: Failed to stat profile ovpn", { profile_ovpn_path: ovpnPath });
                    errorAlert(err);
                    return;
                }
                if (mode !== "600") {
                    external_fs_default().chmod(ovpnPath, 0o600, function (err) {
                        if (err) {
                            err = new ReadError(err, "Profiles: Failed to stat profile ovpn", { profile_ovpn_path: ovpnPath });
                            errorAlert(err);
                        }
                    });
                }
            });
            external_fs_default().stat(logPath, function (err, stats) {
                if (err && err.code === "ENOENT") {
                    return;
                }
                let mode;
                try {
                    mode = (stats.mode & 0o777).toString(8);
                }
                catch (err) {
                    err = new ReadError(err, "Profiles: Failed to stat profile log", { profile_log_path: logPath });
                    errorAlert(err);
                    return;
                }
                if (mode !== "600") {
                    external_fs_default().chmod(logPath, 0o600, function (err) {
                        if (err) {
                            err = new ReadError(err, "Profiles: Failed to stat profile log", { profile_log_path: logPath });
                            errorAlert(err);
                        }
                    });
                }
            });
        }
        external_fs_default().readFile(prflPath, "utf-8", (err, data) => {
            if (err) {
                err = new ReadError(err, "Profiles: Failed to read profile", { profile_log_path: logPath });
                reject(err);
                return;
            }
            let prfl;
            try {
                prfl = JSON.parse(data);
                prfl.id = prflId;
            }
            catch (err) {
                err = new ParseError(err, "Profiles: Failed to parse profile configuration", { profile_path: prflPath });
                reject(err);
                return;
            }
            external_fs_default().readFile(ovpnPath, "utf-8", (err, data) => {
                if (err) {
                    err = new ReadError(err, "Profiles: Failed to read profile", { profile_log_path: logPath });
                    reject(err);
                    return;
                }
                prfl.ovpn_data = data;
                resolve(prfl);
            });
        });
    });
}
function loadProfiles() {
    return new Promise((resolve) => {
        let profilesPath = profiles();
        external_fs_default().stat(profilesPath, (err, stats) => {
            if (err) {
                if (err.code !== "ENOENT") {
                    err = new ReadError(err, "Profiles: Read error", { profiles_path: profilesPath });
                    errorAlert(err);
                }
                resolve([]);
                return;
            }
            external_fs_default().readdir(profilesPath, async (err, filenames) => {
                if (err) {
                    err = new ReadError(err, "Profiles: Read error", { profiles_path: profilesPath });
                    errorAlert(err);
                    resolve([]);
                    return;
                }
                let prfls = [];
                for (let filename of filenames) {
                    if (!filename.endsWith('.conf')) {
                        continue;
                    }
                    let prflPath = external_path_default().join(profilesPath, filename);
                    let prflId = filename.split(".")[0];
                    let prfl;
                    try {
                        prfl = await loadProfile(prflId, prflPath);
                    }
                    catch (err) {
                        Logger_error(err);
                    }
                    if (prfl) {
                        prfls.push(prfl);
                    }
                }
                resolve(prfls);
                return;
            });
        });
    });
}
function loadProfilesState() {
    return new Promise((resolve) => {
        get('/profile')
            .set('Accept', 'application/json')
            .end()
            .then((resp) => {
            resolve(resp.json());
        }, (err) => {
            err = new RequestError(err, "Profiles: Status error");
            errorAlert2(err);
            resolve({});
            return;
        });
    });
}
function sync(noLoading) {
    let curSyncId = uuid();
    syncId = curSyncId;
    let loader;
    if (!noLoading) {
        loader = new Loader().loading();
    }
    return new Promise((resolve) => {
        loadProfiles().then((prfls) => {
            if (loader) {
                loader.done();
            }
            if (curSyncId !== syncId) {
                resolve();
                return;
            }
            loadSystemProfiles().then((systemPrfls) => {
                loadProfilesState().then((prflsState) => {
                    dispatcher_Dispatcher.dispatch({
                        type: SYNC_ALL,
                        data: {
                            profiles: prfls,
                            profilesState: prflsState,
                            profilesSystem: systemPrfls,
                            count: prfls.length,
                        },
                    });
                    resolve();
                });
            });
        });
    });
}
function traverse(page) {
    Dispatcher.dispatch({
        type: ProfileTypes.TRAVERSE,
        data: {
            page: page,
        },
    });
    return sync();
}
function filter(filt) {
    Dispatcher.dispatch({
        type: ProfileTypes.FILTER,
        data: {
            filter: filt,
        },
    });
    return sync();
}
function commit(prfl) {
    return new Promise((resolve) => {
        prfl.writeConf().then(() => {
            sync();
            resolve();
        });
    });
}
dispatcher_EventDispatcher.register((action) => {
    switch (action.type) {
        case "update":
            sync(true);
            break;
        case "auth_error":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    error("Failed to authenticate to " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Failed to authenticate");
            break;
        case "inactive":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    error("Disconnected due to inactivity on " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Disconnected due to inactivity");
            break;
        case "timeout_error":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    error("Connection timed out on " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Connection timed out");
            break;
        case "offline_error":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    error("Server is offline on " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Connection timed out");
            break;
        case "connection_error":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    error("Failed to connect to " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Failed to connect");
            break;
        case "handshake_timeout":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    error("Handshake timeout on " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Handshake timeout");
            break;
        case "sso_auth":
            let ssoAuthMsg = "Connection requires single sign-on authentication. " +
                "Complete authentication in web browser. Copy the link below if " +
                "the web browser did not open.";
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    ssoAuthMsg = "Connection to \"" +
                        prfl.formattedName() + "\" requires single sign-on " +
                        "authentication. Complete authentication in web browser. " +
                        "Copy the link below if the web browser did not open.";
                }
            }
            let ssoAuthElm = react.createElement("div", null,
                react.createElement("div", null, ssoAuthMsg),
                react.createElement("button", { className: "bp5-button bp5-intent-primary bp5-icon-link", type: "button", style: css.updateButton, onClick: (evt) => {
                        external_electron_default().clipboard.writeText(action.data.url);
                        evt.currentTarget.className = "bp5-button bp5-intent-success " +
                            "bp5-icon-link";
                        evt.currentTarget.innerText = "Link Copied";
                    } }, "Copy Single Sign-On Link"));
            info(ssoAuthElm, 5);
            break;
        case "registration_required":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    if (!prfl.system) {
                        prfl.registration_key = action.data.registration_key;
                        prfl.writeConf();
                    }
                    error("Device registration required for " +
                        prfl.formattedName());
                    return;
                }
            }
            error("Failed to authenticate");
            break;
        case "registration_pass":
            if (action.data) {
                let prfl = stores_ProfilesStore.profile(action.data.id);
                if (prfl) {
                    if (!prfl.system && prfl.registration_key) {
                        prfl.registration_key = "";
                        prfl.writeConf();
                    }
                    return;
                }
            }
            break;
    }
});

;// ./app/types/ConfigTypes.js
const ConfigTypes_SYNC = 'config.sync';
const ConfigTypes_CHANGE = 'config.change';

;// ./app/actions/ConfigActions.js







function ConfigActions_sync() {
    let loader = new Loader().loading();
    return new Promise((resolve) => {
        get("/config")
            .set("Accept", "application/json")
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            dispatcher_Dispatcher.dispatch({
                type: ConfigTypes_SYNC,
                data: resp.json(),
            });
            resolve();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "Actions: Config load error");
            errorAlert(err);
            resolve();
        });
    });
}
function ConfigActions_commit(config) {
    let loader = new Loader().loading();
    return new Promise((resolve) => {
        put("/config")
            .set("Accept", "application/json")
            .send(config)
            .end()
            .then((resp) => {
            if (loader) {
                loader.done();
            }
            resolve();
            ConfigActions_sync();
        }, (err) => {
            if (loader) {
                loader.done();
            }
            err = new RequestError(err, "Actions: Config commit failed");
            errorAlert(err);
            resolve();
            ConfigActions_sync();
        });
    });
}
dispatcher_EventDispatcher.register((action) => {
    switch (action.type) {
        case ConfigTypes_CHANGE:
            ConfigActions_sync();
            break;
    }
});

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/components/small-cross.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var SmallCross = react.forwardRef(function (props, ref) {
    var isLarge = props.size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var translation = "".concat(-1 * pixelGridSize / 0.05 / 2);
    var style = { transformOrigin: "center" };
    return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ iconName: "small-cross", ref: ref }, props),
        react.createElement("path", { d: isLarge ? "M228.2 200L294 265.8C297.8 269.4 300 274.4 300 280C300 291 291 300 280 300C274.4000000000001 300 269.4000000000001 297.8 265.8 294.2L200 228.2L134.2 294.2C130.6 297.8 125.6 300 120 300C109 300 100 291 100 280C100 274.4 102.2 269.4 105.8 265.8L171.8 200L106 134.2000000000001C102.2 130.6 100 125.6 100 120C100 109 109 100 120 100C125.6 100 130.6 102.2 134.2 105.8L200 171.8L265.8 106C269.4000000000001 102.2 274.4000000000001 100 280 100C291 100 300 109 300 120C300 125.6 297.8 130.6 294.2000000000001 134.2000000000001L228.2 200z" : "M188.2 160L234 205.8C237.8 209.4 240 214.4 240 220C240 231 231 240 220 240C214.4 240 209.4 237.8 205.8 234.2L160 188.2L114.2 234.2C110.6 237.8 105.6 240 100 240C89 240 80 231 80 220C80 214.4 82.2 209.4 85.8 205.8L131.8 160L86 114.2C82.2 110.6 80 105.6 80 100C80 89 89 80 100 80C105.6 80 110.6 82.2 114.2 85.8L160 131.8L205.8 86C209.4 82.2 214.4 80 220 80C231 80 240 89 240 100C240 105.6 237.8 110.6 234.2 114.2L188.2 160z", fillRule: "evenodd", transform: "scale(0.05, -0.05) translate(".concat(translation, ", ").concat(translation, ")"), style: style })));
});
SmallCross.defaultProps = {
    size: iconTypes/* IconSize */.l.STANDARD,
};
SmallCross.displayName = "Blueprint5.Icon.SmallCross";
/* harmony default export */ const small_cross = ((/* unused pure expression or super */ null && (SmallCross)));

;// ./node_modules/@blueprintjs/core/lib/esm/components/html/html.js
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function htmlElement(tagName, tagClassName) {
    /* eslint-disable-next-line react/display-name */
    return react.forwardRef(function (props, ref) {
        var className = props.className, children = props.children, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["className", "children"]);
        return react.createElement(tagName, (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, htmlProps), { className: classnames_default()(tagClassName, className), ref: ref }), children);
    });
}
// the following components are linted by blueprint-html-components because
// they should rarely be used without the Blueprint classes/styles:
var H1 = htmlElement("h1", HEADING);
var H2 = htmlElement("h2", HEADING);
var H3 = htmlElement("h3", HEADING);
var H4 = htmlElement("h4", HEADING);
var H5 = htmlElement("h5", HEADING);
var H6 = htmlElement("h6", HEADING);
var Blockquote = htmlElement("blockquote", BLOCKQUOTE);
var Code = htmlElement("code", CODE);
var Pre = htmlElement("pre", CODE_BLOCK);
var Label = htmlElement("label", LABEL);
// these two are not linted by blueprint-html-components because there are valid
// uses of these elements without Blueprint styles:
var OL = htmlElement("ol", LIST);
var UL = htmlElement("ul", LIST);

;// ./node_modules/@blueprintjs/core/lib/esm/components/dialog/dialog.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Dialog component.
 *
 * @see https://blueprintjs.com/docs/#core/components/dialog
 */
var Dialog = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(Dialog, _super);
    function Dialog(props) {
        var _this = _super.call(this, props) || this;
        _this.childRef = react.createRef();
        var id = uniqueId("bp-dialog");
        _this.titleId = "title-".concat(id);
        return _this;
    }
    Dialog.prototype.render = function () {
        var _a;
        var _b = this.props, className = _b.className, children = _b.children, containerRef = _b.containerRef, style = _b.style, title = _b.title, _c = _b.role, role = _c === void 0 ? "dialog" : _c, overlayProps = (0,tslib_es6/* __rest */.Tt)(_b, ["className", "children", "containerRef", "style", "title", "role"]);
        return (react.createElement(Overlay2, (0,tslib_es6/* __assign */.Cl)({}, overlayProps, { className: OVERLAY_SCROLL_CONTAINER, childRef: this.childRef, hasBackdrop: true }),
            react.createElement("div", { className: DIALOG_CONTAINER, ref: mergeRefs(containerRef, this.childRef) },
                react.createElement("div", { className: classnames_default()(DIALOG, className), role: role, "aria-modal": (_a = overlayProps.enforceFocus) !== null && _a !== void 0 ? _a : OVERLAY2_DEFAULT_PROPS.enforceFocus, "aria-labelledby": this.props["aria-labelledby"] || (title ? this.titleId : undefined), "aria-describedby": this.props["aria-describedby"], style: style },
                    this.maybeRenderHeader(),
                    children))));
    };
    Dialog.prototype.validateProps = function (props) {
        if (props.title == null) {
            if (props.icon != null) {
                console.warn(DIALOG_WARN_NO_HEADER_ICON);
            }
            if (props.isCloseButtonShown != null) {
                console.warn(DIALOG_WARN_NO_HEADER_CLOSE_BUTTON);
            }
        }
    };
    Dialog.prototype.maybeRenderCloseButton = function () {
        // show close button if prop is undefined or null
        // this gives us a behavior as if the default value were `true`
        if (this.props.isCloseButtonShown !== false) {
            return (react.createElement(Button, { "aria-label": "Close", className: DIALOG_CLOSE_BUTTON, icon: react.createElement(SmallCross, { size: iconTypes/* IconSize */.l.STANDARD }), onClick: this.props.onClose, variant: "minimal" }));
        }
        else {
            return undefined;
        }
    };
    Dialog.prototype.maybeRenderHeader = function () {
        var _a = this.props, icon = _a.icon, title = _a.title;
        if (title == null) {
            return undefined;
        }
        return (react.createElement("div", { className: DIALOG_HEADER },
            react.createElement(Icon, { icon: icon, size: iconTypes/* IconSize */.l.STANDARD, "aria-hidden": true, tabIndex: -1 }),
            react.createElement(H6, { id: this.titleId }, title),
            this.maybeRenderCloseButton()));
    };
    Dialog.defaultProps = {
        canOutsideClickClose: true,
        isOpen: false,
    };
    Dialog.displayName = "".concat(DISPLAYNAME_PREFIX, ".Dialog");
    return Dialog;
}(AbstractPureComponent));


;// ./app/components/Help.js


const Help_css = {
    box: {
        position: 'relative',
        display: 'inline',
    },
    content: {
        padding: '20px',
    },
    button: {
        position: 'absolute',
        top: '-7px',
        left: '-2px',
        padding: '7px',
        background: 'none',
        opacity: 0.3,
    },
    popover: {
        width: '230px',
    },
    popoverTarget: {
        top: '9px',
        left: '18px',
    },
    dialog: {
        maxWidth: '400px',
        margin: '30px 20px',
    },
};
let dialog = true;
class Help extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.state = {
            popover: false,
        };
    }
    render() {
        let helpElm;
        if (this.state.popover) {
            if (dialog) {
                helpElm = react.createElement(Dialog, { title: this.props.title, style: Help_css.dialog, isOpen: this.state.popover, usePortal: true, portalContainer: document.body, onClose: () => {
                        this.setState({
                            ...this.state,
                            popover: false,
                        });
                    } },
                    react.createElement("div", { className: "bp5-dialog-body" }, this.props.content),
                    react.createElement("div", { className: "bp5-dialog-footer" },
                        react.createElement("div", { className: "bp5-dialog-footer-actions" },
                            react.createElement("button", { className: "bp5-button", type: "button", onClick: () => {
                                    this.setState({
                                        ...this.state,
                                        popover: !this.state.popover,
                                    });
                                } }, "Close"))));
            }
            else {
                helpElm = react.createElement("span", { className: "bp5-popover-target", style: Help_css.popoverTarget },
                    react.createElement("span", { className: "bp5-overlay bp5-overlay-inline" },
                        react.createElement("span", null,
                            react.createElement("div", { className: 'bp5-transition-container ' +
                                    'bp5-tether-element-attached-middle ' +
                                    'bp5-tether-element-attached-left ' +
                                    'bp5-tether-target-attached-middle ' +
                                    'bp5-tether-target-attached-right bp5-overlay-content', style: Help_css.popover },
                                react.createElement("div", { className: "bp5-popover" },
                                    react.createElement("div", { className: "bp5-popover-arrow" },
                                        react.createElement("svg", { viewBox: "0 0 30 30" },
                                            react.createElement("path", { className: "bp5-popover-arrow-border", d: 'M8.11 6.302c1.015-.936 1.887-2.922 ' +
                                                    '1.887-4.297v26c0-1.378-' +
                                                    '.868-3.357-1.888-4.297L.925 ' +
                                                    '17.09c-1.237-1.14-1.233-3.034 0-4.17L8.11 6.302z' }),
                                            react.createElement("path", { className: "bp5-popover-arrow-fill", d: 'M8.787 7.036c1.22-1.125 2.21-3.376 ' +
                                                    '2.21-5.03V0v30-2.005c0-1.654-' +
                                                    '.983-3.9-2.21-5.03l-7.183-6.616c-' +
                                                    '.81-.746-.802-1.96 0-2.7l7.183-6.614z' }))),
                                    react.createElement("div", { className: "bp5-popover-content", style: Help_css.content },
                                        react.createElement("h5", null, this.props.title),
                                        react.createElement("div", null, this.props.content)))))));
            }
        }
        return react.createElement("div", { style: Help_css.box },
            react.createElement("div", { className: "bp5-button bp5-minimal bp5-icon-help", style: Help_css.button, onClick: () => {
                    this.setState({
                        ...this.state,
                        popover: !this.state.popover,
                    });
                } }),
            helpElm);
    }
}

;// ./app/components/PageInput.js


const PageInput_css = {
    label: {
        width: '100%',
        maxWidth: '280px',
    },
    input: {
        width: '100%',
    },
};
class PageInput extends react.Component {
    constructor() {
        super(...arguments);
        this.autoSelect = (evt) => {
            evt.currentTarget.select();
        };
    }
    render() {
        let value = this.props.value;
        value = isNaN(value) ? this.props.value || '' : this.props.value;
        return react.createElement("label", { className: "bp5-label", style: PageInput_css.label, hidden: this.props.hidden },
            this.props.label,
            react.createElement(Help, { title: this.props.label, content: this.props.help }),
            react.createElement("input", { className: "bp5-input", style: PageInput_css.input, type: this.props.type, disabled: this.props.disabled, readOnly: this.props.readOnly, autoFocus: this.props.autoFocus, autoCapitalize: "off", spellCheck: false, placeholder: this.props.placeholder, value: value, onClick: this.props.autoSelect ? this.autoSelect : null, onKeyUp: (evt) => {
                    if (this.props.onKeyUp) {
                        this.props.onKeyUp(evt.key);
                    }
                }, onChange: (evt) => {
                    if (this.props.onChange) {
                        this.props.onChange(evt.target.value);
                    }
                } }));
    }
}

;// ./app/components/PageInputFile.js



const PageInputFile_css = {
    label: {
        width: "100%",
        maxWidth: "280px",
        marginBottom: "5px",
    },
    input: {
        width: "100%",
    },
    inputBox: {
        display: "block",
        maxWidth: "280px",
        width: "100%",
    },
};
class PageInputFile extends react.Component {
    render() {
        let label = this.props.value || "Choose profile file...";
        return react.createElement("div", null,
            react.createElement("label", { className: "bp5-label", style: PageInputFile_css.label, hidden: this.props.hidden },
                this.props.label,
                react.createElement(Help, { title: this.props.label, content: this.props.help })),
            react.createElement("label", { className: "bp5-file-input", style: PageInputFile_css.inputBox },
                react.createElement("input", { style: PageInputFile_css.input, type: "file", accept: this.props.accept, disabled: this.props.disabled, onChange: (evt) => {
                        let file;
                        if (evt.target.files && evt.target.files.length) {
                            file = evt.target.files[0];
                        }
                        else if (evt.currentTarget.files &&
                            evt.currentTarget.files.length) {
                            file = evt.currentTarget.files[0];
                        }
                        let pth = external_electron_default().webUtils.getPathForFile(file);
                        if (this.props.onChange) {
                            this.props.onChange(pth);
                        }
                    } }),
                react.createElement("span", { className: "bp5-file-upload-input" }, label)));
    }
}

;// ./app/utils/Importer.js









class Importer {
    constructor() {
        this.files = {};
    }
    addData(pth, data) {
        this.files[pth] = data;
    }
    async addPath(pth) {
        this.files[pth] = await fileRead(pth);
    }
    async addTar(pth) {
        let files = await tarRead(pth);
        for (let file of files) {
            this.addData(file.path, file.data);
        }
    }
    async import(pth, data) {
        data = data.replace(/\r/g, "");
        let line;
        let lines = data.split("\n");
        let jsonFound = null;
        let jsonData = "";
        let ovpnData = "";
        let keyData = "";
        let filePth;
        let split;
        let fileName = external_path_default().basename(pth);
        let fileNames = fileName.split(".");
        fileNames.pop();
        fileName = fileNames.join(".");
        for (let i = 0; i < lines.length; i++) {
            line = lines[i];
            if (jsonFound === null && line === "#{") {
                jsonFound = true;
            }
            if (jsonFound === true && line.startsWith("#")) {
                if (line === "#}") {
                    jsonFound = false;
                }
                jsonData += line.replace("#", "");
            }
            else if (line.startsWith("ca ")) {
                split = line.split(" ");
                split.shift();
                filePth = split.join(" ");
                if (this.files[filePth]) {
                    keyData += "<ca>\n" + this.files[filePth] + "</ca>\n";
                }
                else {
                    filePth = external_path_default().join(external_path_default().dirname(pth), external_path_default().normalize(filePth));
                    let data = await fileRead(filePth);
                    keyData += "<ca>\n" + data + "</ca>\n";
                }
            }
            else if (line.startsWith("cert ")) {
                split = line.split(" ");
                split.shift();
                filePth = split.join(" ");
                if (this.files[filePth]) {
                    keyData += "<cert>\n" + this.files[filePth] + "</cert>\n";
                }
                else {
                    filePth = external_path_default().join(external_path_default().dirname(pth), external_path_default().normalize(filePth));
                    let data = await fileRead(filePth);
                    keyData += "<cert>\n" + data + "</cert>\n";
                }
            }
            else if (line.startsWith("key ")) {
                split = line.split(" ");
                split.shift();
                filePth = split.join(" ");
                if (this.files[filePth]) {
                    keyData += "<key>\n" + this.files[filePth] + "</key>\n";
                }
                else {
                    filePth = external_path_default().join(external_path_default().dirname(pth), external_path_default().normalize(filePth));
                    let data = await fileRead(filePth);
                    keyData += "<key>\n" + data + "</key>\n";
                }
            }
            else if (line.startsWith("tls-auth ")) {
                split = line.split(" ");
                split.shift();
                if (Number(split[split.length - 1])) {
                    keyData += "key-direction " + split.pop() + "\n";
                }
                filePth = split.join(" ");
                if (this.files[filePth]) {
                    keyData += "<tls-auth>\n" + this.files[filePth] + "</tls-auth>\n";
                }
                else {
                    filePth = external_path_default().join(external_path_default().dirname(pth), external_path_default().normalize(filePth));
                    let data = await fileRead(filePth);
                    keyData += "<tls-auth>\n" + data + "</tls-auth>\n";
                }
            }
            else if (line.startsWith("tls-crypt ")) {
                split = line.split(" ");
                split.shift();
                filePth = split.join(" ");
                if (this.files[filePth]) {
                    keyData += "<tls-crypt>\n" + this.files[filePth] + "</tls-crypt>\n";
                }
                else {
                    filePth = external_path_default().join(external_path_default().dirname(pth), external_path_default().normalize(filePth));
                    let data = await fileRead(filePth);
                    keyData += "<tls-crypt>\n" + data + "</tls-crypt>\n";
                }
            }
            else {
                ovpnData += line + "\n";
            }
        }
        ovpnData = ovpnData.trim() + "\n" + keyData;
        let confData;
        try {
            confData = JSON.parse(jsonData);
        }
        catch (e) {
            let err = new ParseError(null, "Importer: Json parse error", { path: pth });
            Logger_error(err);
            confData = null;
        }
        if (!confData) {
            confData = {
                name: fileName
            };
        }
        let exists = false;
        let prfl = New(confData);
        prfl.id = uuidRand();
        if (prfl.organization_id && prfl.server_id && prfl.user_id) {
            let prfls = stores_ProfilesStore.profiles;
            for (let curPrfl of prfls) {
                if (prfl.organization_id === curPrfl.organization_id &&
                    prfl.server_id === curPrfl.server_id &&
                    prfl.user_id === curPrfl.user_id) {
                    curPrfl.importConf(prfl);
                    await curPrfl.writeConf();
                    await curPrfl.writeData(ovpnData);
                    prfl = curPrfl;
                    exists = true;
                    break;
                }
            }
        }
        if (!exists) {
            await prfl.writeConf();
            await prfl.writeData(ovpnData);
        }
        if (prfl.force_connect && !prfl.system) {
            await prfl.convertSystem();
        }
        await sync();
    }
    async parse() {
        for (let pth in this.files) {
            let ext = external_path_default().extname(pth);
            let data = this.files[pth];
            if (ext !== ".ovpn" && ext !== ".conf") {
                continue;
            }
            await this.import(pth, data);
        }
    }
}
async function importFile(pth) {
    try {
        let imptr = new Importer();
        let size = await fileSize(pth);
        if (size > 3000000) {
            error("Importer: File too large");
            return;
        }
        switch (external_path_default().extname(pth)) {
            case ".ovpn":
            case ".conf":
                await imptr.addPath(pth);
                break;
            case ".tar":
                await imptr.addTar(pth);
                break;
            default:
                let err = new ParseError(null, "Importer: Unsupported file type", { path: pth });
                errorAlert(err);
                return;
        }
        await imptr.parse();
    }
    catch (err) {
        errorAlert(err);
    }
}
async function importUri(prflUri) {
    if (!prflUri) {
        return;
    }
    if (prflUri.startsWith("pritunl:")) {
        prflUri = prflUri.replace("pritunl:", "https:");
    }
    else if (prflUri.startsWith("pts:")) {
        prflUri = prflUri.replace("pts:", "https:");
    }
    else if (prflUri.startsWith("http:")) {
        prflUri = prflUri.replace("http:", "https");
    }
    else if (prflUri.startsWith("https:")) {
    }
    else {
        prflUri = "https://" + prflUri;
    }
    prflUri = prflUri.replace("/k/", "/ku/");
    let strictSsl = !prflUri.match(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) &&
        !prflUri.match(/\[[a-fA-F0-9:]*\]/);
    let prflUrl = new URL(prflUri);
    let resp;
    try {
        resp = await new Request_Request()
            .tcp(prflUrl.protocol + "//" + prflUrl.host)
            .get(prflUrl.pathname)
            .set("User-Agent", "pritunl")
            .set("Accept", "application/json")
            .secure(strictSsl)
            .timeout(12)
            .end();
    }
    catch (err) {
        errorAlert(err);
        return;
    }
    if (resp.status === 404) {
        error("Invalid or expired profile URI", 15);
        return;
    }
    if (resp.status !== 200) {
        error("HTTP error status " + resp.status + " received", 15);
        return;
    }
    let data = resp.jsonPassive();
    if (!data) {
        error("No data received from server", 15);
        return;
    }
    for (let name in data) {
        let imptr = new Importer();
        let prflData = data[name];
        imptr.addData(name, prflData);
        try {
            await imptr.parse();
        }
        catch (err) {
            errorAlert(err);
        }
    }
}

;// ./app/components/ProfileImport.js






const ProfileImport_css = {
    box: {
        display: "inline-block"
    },
    button: {
        marginRight: "10px",
    },
    dialog: {
        width: "340px",
        position: "absolute",
    },
    label: {
        width: "100%",
        maxWidth: "220px",
        margin: "18px 0 0 0",
    },
    input: {
        width: "100%",
    },
};
class ProfileImport extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onImport = () => {
            this.setState({
                ...this.state,
                disabled: true,
            });
            if (this.state.fullPath !== "") {
                importFile(this.state.fullPath).then(() => {
                    this.setState({
                        ...this.state,
                        dialog: false,
                        disabled: false,
                        changed: false,
                        uri: "",
                        path: "",
                        fullPath: "",
                    });
                });
            }
            else {
                importUri(this.state.uri).then(() => {
                    this.setState({
                        ...this.state,
                        dialog: false,
                        disabled: false,
                        changed: false,
                        uri: "",
                        path: "",
                        fullPath: "",
                    });
                });
            }
        };
        this.openDialog = () => {
            this.setState({
                ...this.state,
                dialog: true,
            });
        };
        this.closeDialog = () => {
            this.setState({
                ...this.state,
                dialog: false,
            });
        };
        this.state = {
            disabled: false,
            changed: false,
            dialog: false,
            uri: "",
            path: "",
            fullPath: "",
        };
    }
    render() {
        return react.createElement("div", { style: ProfileImport_css.box },
            react.createElement("button", { className: "bp5-button bp5-minimal bp5-icon-import", style: this.props.style, type: "button", disabled: this.state.disabled, onClick: this.openDialog }, "Import"),
            react.createElement(Dialog, { title: "Import Profile", style: ProfileImport_css.dialog, isOpen: this.state.dialog, usePortal: true, portalContainer: document.body, onClose: this.closeDialog },
                react.createElement("div", { className: "bp5-dialog-body" },
                    react.createElement(PageInput, { disabled: this.state.disabled, label: "Profile URI", help: "Profile URI as shown in the Pritunl server web console.", type: "text", placeholder: "Enter URI", value: this.state.uri, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                uri: val,
                                path: "",
                                fullPath: "",
                            });
                        } }),
                    react.createElement(PageInputFile, { disabled: this.state.disabled, label: "Import Profile", help: "Select profile file in tar, zip, ovpn or conf format.", accept: ".ovpn,.conf,.tar,.zip", value: this.state.path, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                uri: "",
                                path: external_path_default().basename(val),
                                fullPath: val,
                            });
                        } })),
                react.createElement("div", { className: "bp5-dialog-footer" },
                    react.createElement("div", { className: "bp5-dialog-footer-actions" },
                        react.createElement("button", { className: "bp5-button bp5-intent-danger bp5-icon-cross", type: "button", disabled: this.state.disabled, onClick: this.closeDialog }, "Cancel"),
                        react.createElement("button", { className: "bp5-button bp5-intent-success bp5-icon-tick", type: "button", disabled: this.state.disabled || !this.state.changed, onClick: this.onImport }, "Import")))));
    }
}

;// ./app/stores/LoadingStore.js




class LoadingStore extends EventEmitter {
    constructor() {
        super(...arguments);
        this._loaders = new Set();
        this._token = dispatcher_Dispatcher.register((this._callback).bind(this));
    }
    get loading() {
        return !!this._loaders.size;
    }
    emitChange() {
        this.emitDefer(GlobalTypes_CHANGE);
    }
    addChangeListener(callback) {
        this.on(GlobalTypes_CHANGE, callback);
    }
    removeChangeListener(callback) {
        this.removeListener(GlobalTypes_CHANGE, callback);
    }
    _add(id) {
        this._loaders.add(id);
        this.emitChange();
    }
    _done(id) {
        this._loaders.delete(id);
        this.emitChange();
    }
    _callback(action) {
        switch (action.type) {
            case ADD:
                this._add(action.data.id);
                break;
            case DONE:
                this._done(action.data.id);
                break;
        }
    }
}
/* harmony default export */ const stores_LoadingStore = (new LoadingStore());

;// ./app/components/LoadingBar.js


const LoadingBar_css = {
    progress: {
        width: '100%',
        height: '4px',
        borderRadius: 0,
    },
    progressBar: {
        width: '50%',
        borderRadius: 0,
    },
};
class LoadingBar extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onChange = () => {
            this.setState({
                loading: stores_LoadingStore.loading,
            });
        };
        this.state = {
            loading: stores_LoadingStore.loading,
        };
    }
    componentDidMount() {
        stores_LoadingStore.addChangeListener(this.onChange);
    }
    componentWillUnmount() {
        stores_LoadingStore.removeChangeListener(this.onChange);
    }
    render() {
        let progress;
        if (!this.state.loading) {
            progress = react.createElement("div", { style: LoadingBar_css.progress });
        }
        else {
            let className = 'bp5-progress-bar bp5-no-stripes bp5-no-animation ';
            if (this.props.intent) {
                className += ' bp5-intent-' + this.props.intent;
            }
            progress = react.createElement("div", { className: className, style: LoadingBar_css.progress },
                react.createElement("div", { className: "bp5-progress-meter bp5-loading-bar", style: LoadingBar_css.progressBar }));
        }
        return react.createElement("div", { style: this.props.style }, progress);
    }
}

;// ./app/components/ConfirmButton.js



const ConfirmButton_css = {
    box: {
        display: 'inline-flex',
        verticalAlign: 'middle',
    },
    actionProgress: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        borderRadius: 0,
        borderBottomLeftRadius: '3px',
        borderBottomRightRadius: '3px',
        width: '100%',
        height: '4px',
    },
    squareActionProgress: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        borderRadius: 0,
        borderBottomLeftRadius: '1px',
        borderBottomRightRadius: '3px',
        width: '100%',
        height: '4px',
    },
    dialog: {
        width: '340px',
        position: 'absolute',
    },
    label: {
        width: '100%',
        maxWidth: '220px',
        margin: '18px 0 0 0',
    },
    input: {
        width: '100%',
    },
};
class ConfirmButton extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.openDialog = () => {
            this.setState({
                ...this.state,
                dialog: true,
            });
        };
        this.closeDialog = () => {
            this.setState({
                ...this.state,
                dialog: false,
            });
        };
        this.closeDialogConfirm = () => {
            this.setState({
                ...this.state,
                dialog: false,
            });
            if (this.props.onConfirm) {
                this.props.onConfirm();
            }
        };
        this.confirm = (evt) => {
            let confirmId = uuid();
            if (evt.shiftKey) {
                if (this.props.onConfirm) {
                    this.props.onConfirm();
                }
                return;
            }
            this.setState({
                ...this.state,
                confirming: confirmId,
            });
            let i = 10;
            let id = setInterval(() => {
                if (i > 100) {
                    clearInterval(id);
                    setTimeout(() => {
                        if (this.state.confirming === confirmId) {
                            this.setState({
                                ...this.state,
                                confirm: 0,
                                confirming: null,
                            });
                            if (this.props.onConfirm) {
                                this.props.onConfirm();
                            }
                        }
                    }, 250);
                    return;
                }
                else if (!this.state.confirming) {
                    clearInterval(id);
                    this.setState({
                        ...this.state,
                        confirm: 0,
                        confirming: null,
                    });
                    return;
                }
                if (i % 10 === 0) {
                    this.setState({
                        ...this.state,
                        confirm: i / 10,
                    });
                }
                i += 2;
            }, 8);
        };
        this.clearConfirm = () => {
            this.setState({
                ...this.state,
                confirm: 0,
                confirming: null,
            });
        };
        this.state = {
            input: '',
            dialog: false,
            confirm: 0,
            confirming: null,
        };
    }
    render() {
        let dialog = this.props.safe;
        let style = {
            ...this.props.style,
        };
        style.position = 'relative';
        let className = this.props.className || '';
        if (!this.props.label) {
            className += ' bp5-button-empty';
        }
        let dialogClassName = this.props.dialogClassName ||
            this.props.className || '';
        if (!this.props.label && !this.props.dialogLabel) {
            dialogClassName += ' bp5-button-empty';
        }
        let confirmInput;
        if (this.props.confirmInput) {
            confirmInput = react.createElement("label", { className: "bp5-label", style: ConfirmButton_css.label },
                "Enter \"delete\" to confirm:",
                react.createElement("input", { className: "bp5-input", style: ConfirmButton_css.input, disabled: this.props.disabled, autoCapitalize: "off", spellCheck: false, placeholder: 'Enter "delete" to confirm', value: this.state.input, onChange: (evt) => {
                        this.setState({
                            ...this.state,
                            input: evt.target.value,
                        });
                    } }));
        }
        if (dialog) {
            let confirmMsg = this.props.confirmMsg ? this.props.confirmMsg :
                'Confirm ' + (this.props.label || '');
            let itemsList;
            if (this.props.items) {
                let items = [];
                for (let item of this.props.items) {
                    items.push(react.createElement("li", { key: item }, item));
                }
                itemsList = react.createElement("ul", null, items);
            }
            return react.createElement("div", { style: ConfirmButton_css.box },
                react.createElement("button", { className: 'bp5-button ' + className, style: style, type: "button", hidden: this.props.hidden, disabled: this.props.disabled, onMouseDown: dialog ? undefined : this.confirm, onMouseUp: dialog ? undefined : this.clearConfirm, onMouseLeave: dialog ? undefined : this.clearConfirm, onClick: dialog ? this.openDialog : undefined }, this.props.label),
                react.createElement(Dialog, { title: "Confirm", style: ConfirmButton_css.dialog, isOpen: this.state.dialog, usePortal: true, portalContainer: document.body, onClose: this.closeDialog },
                    react.createElement("div", { className: "bp5-dialog-body" },
                        confirmMsg,
                        itemsList,
                        confirmInput),
                    react.createElement("div", { className: "bp5-dialog-footer" },
                        react.createElement("div", { className: "bp5-dialog-footer-actions" },
                            react.createElement("button", { className: "bp5-button", type: "button", onClick: this.closeDialog }, "Cancel"),
                            react.createElement("button", { className: 'bp5-button ' + dialogClassName, type: "button", disabled: this.props.confirmInput &&
                                    this.state.input !== 'delete', onClick: this.closeDialogConfirm }, this.props.dialogLabel || this.props.label)))));
        }
        else {
            let confirmElem;
            if (this.state.confirming) {
                let confirmStyle = {
                    width: this.state.confirm * 10 + '%',
                    backgroundColor: style.color,
                    borderRadius: 0,
                    left: 0,
                };
                let progressStyle;
                if (this.props.grouped) {
                    progressStyle = ConfirmButton_css.squareActionProgress;
                }
                else {
                    progressStyle = ConfirmButton_css.actionProgress;
                }
                confirmElem = react.createElement("div", { className: 'bp5-progress-bar bp5-no-stripes ' + (this.props.progressClassName || ''), style: progressStyle },
                    react.createElement("div", { className: "bp5-progress-meter", style: confirmStyle }));
            }
            return react.createElement("button", { className: 'bp5-button ' + className, style: style, type: "button", hidden: this.props.hidden, disabled: this.props.disabled, onMouseDown: dialog ? undefined : this.confirm, onMouseUp: dialog ? undefined : this.clearConfirm, onMouseLeave: dialog ? undefined : this.clearConfirm, onClick: dialog ? this.openDialog : undefined },
                this.props.label,
                confirmElem);
        }
    }
}

;// ./app/components/CopyButton.js

const CopyButton_css = {
    copy: {
        cursor: 'pointer',
        marginLeft: '3px',
    },
    copyHover: {
        cursor: 'pointer',
        marginLeft: '3px',
        opacity: 0.7,
    },
    copyClicked: {
        cursor: 'pointer',
        marginLeft: '3px',
        opacity: 0.5,
    },
};
class CopyButton extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.state = {
            hover: false,
            click: false,
            copied: false,
        };
    }
    render() {
        let style;
        if (this.state.click && !this.state.copied) {
            style = CopyButton_css.copyClicked;
        }
        else if (this.state.hover && !this.state.copied) {
            style = CopyButton_css.copyHover;
        }
        else {
            style = CopyButton_css.copy;
        }
        let className = 'bp5-icon-standard';
        if (this.state.copied) {
            className += ' bp5-icon-tick bp5-intent-success';
        }
        else {
            className += ' bp5-icon-clipboard';
        }
        return react.createElement("span", { ref: (elem) => this.elem = elem, className: className, style: style, onMouseEnter: () => {
                this.setState({
                    ...this.state,
                    hover: true,
                });
            }, onMouseLeave: () => {
                this.setState({
                    ...this.state,
                    hover: false,
                    click: false,
                });
            }, onMouseDown: () => {
                this.setState({
                    ...this.state,
                    click: true,
                });
            }, onMouseUp: () => {
                this.setState({
                    ...this.state,
                    click: false,
                });
            }, onClick: () => {
                this.setState({
                    ...this.state,
                    copied: true,
                });
                setTimeout(() => {
                    this.setState({
                        ...this.state,
                        copied: false,
                    });
                }, 1200);
                let elem = document.createElement('input');
                elem.contentEditable = 'true';
                elem.readOnly = true;
                elem.style.position = 'absolute';
                elem.style.width = '1px';
                elem.style.height = '1px';
                elem.style.padding = '0px';
                elem.style.border = 'none';
                elem.style.opacity = '0';
                elem.value = this.props.value;
                this.elem.parentElement.append(elem);
                elem.select();
                document.execCommand('copy');
                elem.remove();
            } });
    }
}

;// ./app/components/PageInfo.js


const PageInfo_css = {
    label: {
        width: '100%',
        maxWidth: '320px',
    },
    value: {
        wordWrap: 'break-word',
    },
    item: {
        marginBottom: '5px',
    },
    bar: {
        maxWidth: '280px',
    },
    copy: {
        cursor: 'pointer',
        marginLeft: '3px',
    },
    copyHover: {
        cursor: 'pointer',
        marginLeft: '3px',
        opacity: 0.7,
    },
};
class PageInfo extends react.Component {
    render() {
        let fields = [];
        let bars = [];
        for (let field of this.props.fields || []) {
            if (field == null) {
                continue;
            }
            let value;
            let copyBtn;
            if (typeof field.value === 'string') {
                value = field.value;
                if (field.copy) {
                    copyBtn = react.createElement(CopyButton, { value: field.value });
                }
            }
            else if (typeof field.value === 'number') {
                value = field.value.toString();
                if (field.copy) {
                    copyBtn = react.createElement(CopyButton, { value: field.value.toString() });
                }
            }
            else if (typeof field.value === 'boolean') {
                value = field.value.toString();
                if (field.copy) {
                    copyBtn = react.createElement(CopyButton, { value: field.value.toString() });
                }
            }
            else if (field.value === undefined || field.value === null) {
                value = 'null';
                if (field.copy) {
                    copyBtn = react.createElement(CopyButton, { value: value });
                }
            }
            else {
                value = [];
                for (let i = 0; i < field.value.length; i++) {
                    let copyItemBtn;
                    if (field.copy) {
                        copyItemBtn = react.createElement(CopyButton, { value: field.value[i] });
                    }
                    value.push(react.createElement("div", { key: i, className: field.valueClasses ?
                            field.valueClasses[i] :
                            (field.valueClass || 'bp5-text-muted') },
                        field.value[i],
                        copyItemBtn));
                }
            }
            fields.push(react.createElement("div", { key: field.label, style: PageInfo_css.item },
                field.label,
                react.createElement("div", { className: field.valueClass || 'bp5-text-muted', style: PageInfo_css.value },
                    value,
                    copyBtn)));
        }
        for (let bar of this.props.bars || []) {
            let style = {
                width: (bar.value || 0) + '%',
            };
            if (bar.color) {
                style.backgroundColor = bar.color;
            }
            bars.push(react.createElement("div", { key: bar.label, style: PageInfo_css.item },
                bar.label,
                react.createElement("div", { className: 'bp5-progress-bar ' + (bar.progressClass || ''), style: PageInfo_css.bar },
                    react.createElement("div", { className: "bp5-progress-meter", style: style }))));
        }
        let labelStyle;
        if (this.props.style) {
            labelStyle = {
                ...PageInfo_css.label,
                ...this.props.style,
            };
        }
        else {
            labelStyle = PageInfo_css.label;
        }
        return react.createElement("label", { className: "bp5-label", style: labelStyle, hidden: this.props.hidden },
            fields,
            bars);
    }
}

;// ./app/components/ProfileConnect.js






const ProfileConnect_css = {
    box: {
        display: "inline-block"
    },
    button: {
        marginTop: "10px",
        marginRight: "5px",
    },
    buttonMinimal: {
        marginTop: "0",
        marginRight: "5px",
    },
    dialog: {
        width: "340px",
        position: "absolute",
    },
    label: {
        width: "100%",
        maxWidth: "220px",
        margin: "18px 0 0 0",
    },
    input: {
        width: "100%",
    },
    header: {
        margin: "0 0 15px 0",
    },
    preConnect: {
        margin: "0 0 15px 0",
    },
};
class ProfileConnect extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onConnect = (mode) => {
            this.setState({
                ...this.state,
                disabled: true,
            });
            if (this.connected()) {
                this.disconnect();
            }
            else {
                this.preConnect(mode);
            }
        };
        this.closeDialog = () => {
            this.setState({
                ...this.state,
                disabled: false,
                dialog: false,
                autoFocus: "",
                username: "",
                hasUsername: false,
                password: "",
                hasPassword: false,
                pin: "",
                hasPin: false,
                duo: "",
                hasDuo: false,
                onelogin: "",
                hasOnelogin: false,
                okta: "",
                hasOkta: false,
                otp: "",
                hasOtp: false,
                yubikey: "",
                hasYubikey: false,
                hasToken: false,
                mode: "",
                preConnMsgOnly: false,
                changed: false,
            });
        };
        this.closeDialogConfirm = () => {
            let username = this.state.username || "pritunl";
            let password = "";
            password += this.state.password;
            password += this.state.pin;
            password += this.state.duo;
            password += this.state.onelogin;
            password += this.state.okta;
            password += this.state.otp;
            password += this.state.yubikey;
            if (!this.state.hasToken && password === "") {
                username = "";
            }
            this.connect(this.state.mode, username, password);
            this.closeDialog();
        };
        this.connected = () => {
            let prfl = this.props.profile;
            if (prfl.system) {
                return prfl.state;
            }
            else {
                return !!prfl.status && prfl.status !== "disconnected";
            }
        };
        this.state = {
            disabled: false,
            autoFocus: "",
            username: "",
            hasUsername: false,
            password: "",
            hasPassword: false,
            pin: "",
            hasPin: false,
            duo: "",
            hasDuo: false,
            onelogin: "",
            hasOnelogin: false,
            okta: "",
            hasOkta: false,
            otp: "",
            hasOtp: false,
            yubikey: "",
            hasYubikey: false,
            hasToken: false,
            mode: "",
            preConnMsgOnly: false,
            changed: false,
            dialog: false,
            confirm: 0,
            confirming: null,
        };
    }
    async preConnect(mode) {
        let prfl = this.props.profile;
        await prfl.sync();
        let tokenValid = false;
        if (prfl.token) {
            tokenValid = await tokenUpdate(prfl);
        }
        else {
            await tokenDelete(prfl);
        }
        let data = await prfl.readData();
        let authType = prfl.getAuthType(data);
        let authTypes = [];
        if (authType) {
            authTypes = authType.split("_");
        }
        if (authTypes && tokenValid) {
            if (authTypes.indexOf("pin") !== -1) {
                authTypes.splice(authTypes.indexOf("pin"), 1);
            }
            if (authTypes.indexOf("duo") !== -1) {
                authTypes.splice(authTypes.indexOf("duo"), 1);
            }
            if (authTypes.indexOf("onelogin") !== -1) {
                authTypes.splice(authTypes.indexOf("onelogin"), 1);
            }
            if (authTypes.indexOf("okta") !== -1) {
                authTypes.splice(authTypes.indexOf("okta"), 1);
            }
            if (authTypes.indexOf("yubikey") !== -1) {
                authTypes.splice(authTypes.indexOf("yubikey"), 1);
            }
            if (authTypes.indexOf("otp") !== -1) {
                authTypes.splice(authTypes.indexOf("otp"), 1);
            }
        }
        let autoFocus = "";
        let hasUsername = false;
        let hasPassword = false;
        let hasPin = false;
        let hasDuo = false;
        let hasOnelogin = false;
        let hasOkta = false;
        let hasOtp = false;
        let hasYubikey = false;
        if (authTypes.indexOf("username") !== -1) {
            hasUsername = true;
        }
        if (authTypes.indexOf("password") !== -1) {
            if (!autoFocus) {
                autoFocus = "password";
            }
            hasPassword = true;
        }
        if (authTypes.indexOf("pin") !== -1) {
            if (!autoFocus) {
                autoFocus = "pin";
            }
            hasPin = true;
        }
        if (authTypes.indexOf("otp") !== -1) {
            if (!autoFocus) {
                autoFocus = "otp";
            }
            hasOtp = true;
        }
        if (authTypes.indexOf("duo") !== -1) {
            if (!autoFocus) {
                autoFocus = "duo";
            }
            hasDuo = true;
            hasOtp = false;
        }
        if (authTypes.indexOf("onelogin") !== -1) {
            if (!autoFocus) {
                autoFocus = "onelogin";
            }
            hasOnelogin = true;
            hasOtp = false;
        }
        if (authTypes.indexOf("okta") !== -1) {
            if (!autoFocus) {
                autoFocus = "okta";
            }
            hasOkta = true;
            hasOtp = false;
        }
        if (authTypes.indexOf("yubikey") !== -1) {
            if (!autoFocus) {
                autoFocus = "yubikey";
            }
            hasYubikey = true;
        }
        if (authTypes.length || this.props.profile.pre_connect_msg) {
            this.setState({
                ...this.state,
                disabled: false,
                dialog: true,
                autoFocus: autoFocus,
                hasUsername: hasUsername,
                hasPassword: hasPassword,
                hasPin: hasPin,
                hasDuo: hasDuo,
                hasOnelogin: hasOnelogin,
                hasOkta: hasOkta,
                hasOtp: hasOtp,
                hasYubikey: hasYubikey,
                hasToken: tokenValid,
                preConnMsgOnly: !authTypes.length,
                mode: mode,
            });
        }
        else {
            await this.connect(mode, "", "");
        }
    }
    async connect(mode, username, password) {
        let prfl = this.props.profile;
        let data = await prfl.readData();
        if (!data) {
            this.setState({
                ...this.state,
                disabled: false,
            });
            return;
        }
        if (!prfl.system) {
            Logger_info("Profiles: Updating profile '" + prfl.id + "'");
            await prfl.writeData(data);
        }
        let serverPubKey = "";
        if (prfl.server_public_key) {
            serverPubKey = prfl.server_public_key.join("\n");
        }
        let connData = {
            id: prfl.id,
            mode: mode,
            org_id: prfl.organization_id,
            user_id: prfl.user_id,
            server_id: prfl.server_id,
            sync_hosts: prfl.sync_hosts,
            sync_token: prfl.sync_token,
            sync_secret: prfl.sync_secret,
            username: username,
            password: password,
            remotes_data: prfl.remotes_data,
            dynamic_firewall: prfl.dynamic_firewall,
            geo_sort: prfl.geo_sort,
            force_connect: prfl.force_connect,
            device_auth: prfl.device_auth,
            disable_gateway: prfl.disable_gateway,
            disable_dns: prfl.disable_dns,
            force_dns: prfl.force_dns,
            restrict_client: prfl.restrict_client,
            sso_auth: prfl.sso_auth,
            server_public_key: serverPubKey,
            server_box_public_key: prfl.server_box_public_key,
            token_ttl: prfl.token_ttl,
            timeout: true,
            reconnect: !(prfl.disable_reconnect || prfl.disable_reconnect_local),
            data: data,
        };
        await connect(connData);
        this.closeDialog();
    }
    disconnect() {
        let prfl = this.props.profile;
        let disconnData = {
            id: prfl.id,
        };
        disconnect(disconnData).then(() => {
            this.setState({
                ...this.state,
                disabled: false,
            });
        });
    }
    render() {
        let connected = this.connected();
        let hasWg = state.wg && this.props.profile.wg;
        let buttonClass = "";
        let buttonLabel = "";
        if (connected) {
            buttonClass = "bp5-intent-danger bp5-icon-delete";
            buttonLabel = "Disconnect";
        }
        else {
            buttonClass = "bp5-intent-success bp5-icon-link";
            buttonLabel = "Connect";
        }
        let cssButton = ProfileConnect_css.button;
        let minimalButton = "";
        if (this.props.minimal) {
            cssButton = ProfileConnect_css.buttonMinimal;
            minimalButton = " bp5-minimal";
        }
        return react.createElement("div", { style: ProfileConnect_css.box, hidden: this.props.hidden },
            react.createElement("button", { className: "bp5-button " + buttonClass + minimalButton, style: cssButton, type: "button", hidden: hasWg && !connected, disabled: this.state.disabled, onClick: () => {
                    this.onConnect("ovpn");
                } }, buttonLabel),
            react.createElement("button", { className: "bp5-button bp5-intent-success bp5-icon-link" + minimalButton, style: cssButton, type: "button", hidden: !hasWg || connected, disabled: this.state.disabled, onClick: () => {
                    this.onConnect("ovpn");
                } }, this.props.minimal ? "OVPN" : "OpenVPN"),
            react.createElement("button", { className: "bp5-button bp5-intent-primary bp5-icon-link" + minimalButton, style: cssButton, type: "button", hidden: !hasWg || connected, disabled: this.state.disabled, onClick: () => {
                    this.onConnect("wg");
                } }, this.props.minimal ? "WG" : "WireGuard"),
            react.createElement(Dialog, { title: "Profile Connect", style: ProfileConnect_css.dialog, isOpen: this.state.dialog, usePortal: true, portalContainer: document.body, onClose: this.closeDialog },
                react.createElement("div", { className: "bp5-dialog-body" },
                    react.createElement("h3", { style: ProfileConnect_css.header },
                        "Connecting to ",
                        this.props.profile.formattedName()),
                    react.createElement("div", { style: ProfileConnect_css.preConnect, hidden: !this.props.profile.pre_connect_msg }, this.props.profile.pre_connect_msg),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasUsername, label: "Username", help: "Enter profile username.", type: "text", placeholder: "Enter username", value: this.state.username, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                username: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasPassword, autoFocus: this.state.autoFocus === "password", label: "Password", help: "Enter profile password.", type: "password", placeholder: "Enter password", value: this.state.password, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                password: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasPin, autoFocus: this.state.autoFocus === "pin", label: "Pin", help: "Enter profile pin.", type: "password", placeholder: "Enter pin", value: this.state.pin, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                pin: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasDuo, autoFocus: this.state.autoFocus === "duo", label: "Duo Passcode", help: "Enter profile Duo passcode from Duo authenticator.", type: "text", placeholder: "Enter passcode", value: this.state.duo, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                duo: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasOnelogin, autoFocus: this.state.autoFocus === "onelogin", label: "OneLogin Passcode", help: "Enter profile OneLogin passcode from OneLogin authenticator app.", type: "text", placeholder: "Enter passcode", value: this.state.onelogin, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                onelogin: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasOkta, autoFocus: this.state.autoFocus === "okta", label: "Okta Passcode", help: "Enter profile Okta passcode from Okta authenticator app.", type: "text", placeholder: "Enter passcode", value: this.state.okta, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                okta: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasOtp, autoFocus: this.state.autoFocus === "otp", label: "Authenticator Passcode", help: "Enter profile passcode from authenticator app.", type: "text", placeholder: "Enter passcode", value: this.state.otp, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                otp: val,
                            });
                        } }),
                    react.createElement(PageInput, { disabled: this.state.disabled, hidden: !this.state.hasYubikey, autoFocus: this.state.autoFocus === "yubikey", label: "YubiKey", help: "Select field and push button on YubiKey device to fill passcode.", type: "text", placeholder: "Activate YubiKey", value: this.state.yubikey, onKeyUp: (key) => {
                            if (key === "Enter") {
                                this.closeDialogConfirm();
                            }
                        }, onChange: (val) => {
                            this.setState({
                                ...this.state,
                                changed: true,
                                yubikey: val,
                            });
                        } })),
                react.createElement("div", { className: "bp5-dialog-footer" },
                    react.createElement("div", { className: "bp5-dialog-footer-actions" },
                        react.createElement("button", { className: "bp5-button bp5-intent-danger bp5-icon-cross", type: "button", onClick: this.closeDialog }, "Cancel"),
                        react.createElement("button", { className: "bp5-button bp5-intent-success bp5-icon-link", type: "button", disabled: this.state.disabled || (!this.state.changed &&
                                !this.state.preConnMsgOnly), onClick: this.closeDialogConfirm }, "Connect")))));
    }
}

;// ./app/components/PageSwitch.js


const PageSwitch_css = {
    label: {
        display: 'inline-block',
    },
};
class PageSwitch extends react.Component {
    render() {
        return react.createElement("div", { hidden: this.props.hidden },
            react.createElement("label", { className: "bp5-control bp5-switch", style: PageSwitch_css.label },
                react.createElement("input", { type: "checkbox", disabled: this.props.disabled, checked: !!this.props.checked, onChange: this.props.onToggle }),
                react.createElement("span", { className: "bp5-control-indicator" }),
                this.props.label),
            react.createElement(Help, { title: this.props.label, content: this.props.help }));
    }
}

;// ./app/components/ProfileSettings.js










const ProfileSettings_css = {
    box: {
        display: "inline-block"
    },
    button: {
        marginTop: "10px",
        marginRight: "10px",
    },
    dialog: {
        width: "340px",
        position: "absolute",
    },
    label: {
        width: "100%",
        maxWidth: "220px",
        margin: "18px 0 0 0",
    },
    input: {
        width: "100%",
    },
    toggleDataBtn: {
        opacity: "0.5",
    },
    dataInfoBox: {
        height: "100px",
        overflowY: "scroll",
        border: "1px solid rgba(16, 22, 26, 0.4)",
        borderRadius: "2px",
    },
};
class ProfileSettings extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onSave = () => {
            let prfl = this.state.profile;
            this.setState({
                ...this.state,
                disabled: true,
            });
            if (prfl) {
                if (this.state.setAutoStart !== null) {
                    prfl.disabled = !this.state.setAutoStart;
                }
                if (prfl.force_connect && prfl.disabled) {
                    let err = new WriteError(null, "Profiles: Profile autostart enforced by server", { profile_id: prfl.id });
                    errorAlert(err, 10);
                    prfl.disabled = false;
                    this.setState({
                        ...this.state,
                        setAutoStart: null,
                    });
                    return;
                }
                commit(prfl).then(() => {
                    if (this.state.setSystem !== null) {
                        this.onSaveSystem();
                    }
                    else {
                        this.setState({
                            ...this.state,
                            changed: false,
                            disabled: false,
                            profile: null,
                        });
                        this.closeDialog();
                    }
                });
            }
            else {
                if (this.state.setSystem !== null) {
                    this.onSaveSystem();
                }
                else {
                    this.setState({
                        ...this.state,
                        changed: false,
                        disabled: false,
                        profile: null,
                    });
                    this.closeDialog();
                }
            }
        };
        this.onSaveSystem = () => {
            let prfl = this.state.profile ||
                this.props.profile;
            if (this.state.setSystem && !prfl.system) {
                prfl.disabled = !this.state.setAutoStart;
                prfl.convertSystem().then(() => {
                    this.setState({
                        ...this.state,
                        changed: false,
                        disabled: false,
                        profile: null,
                    });
                    this.closeDialog();
                });
            }
            else if (!this.state.setSystem && !!prfl.system) {
                prfl.convertUser().then(() => {
                    this.setState({
                        ...this.state,
                        changed: false,
                        disabled: false,
                        profile: null,
                    });
                    this.closeDialog();
                });
            }
        };
        this.openDialog = () => {
            this.setState({
                ...this.state,
                dialog: true,
            });
        };
        this.closeDialog = () => {
            this.setState({
                ...this.state,
                dialog: false,
                changed: false,
                profile: null,
                setAutoStart: null,
                setSystem: null,
            });
        };
        this.toggleData = () => {
            this.setState({
                ...this.state,
                showData: !this.state.showData,
            });
        };
        this.state = {
            disabled: false,
            changed: false,
            dialog: false,
            profile: null,
            setAutoStart: null,
            setSystem: null,
            showData: false,
        };
    }
    set(name, val) {
        let profile;
        if (this.state.changed) {
            profile = {
                ...this.state.profile,
            };
        }
        else {
            profile = {
                ...this.props.profile,
            };
        }
        profile[name] = val;
        if (name === "disabled") {
            this.setState({
                ...this.state,
                changed: true,
                profile: profile,
                setAutoStart: !profile.disabled,
            });
        }
        else {
            this.setState({
                ...this.state,
                changed: true,
                profile: profile,
            });
        }
    }
    render() {
        let profile = this.state.profile ||
            this.props.profile;
        let system = !!profile.system;
        if (this.state.setSystem !== null) {
            system = this.state.setSystem;
        }
        let autostart = !profile.disabled && !!profile.system;
        if (this.state.setAutoStart !== null) {
            autostart = this.state.setAutoStart;
        }
        let syncHosts = profile.formatedHosts();
        let lastSync = "";
        if (profile.sync_time === -1) {
            lastSync = "Failed to sync";
        }
        else if (profile.sync_time) {
            lastSync = formatDateLess(profile.sync_time);
        }
        else {
            lastSync = "Never";
        }
        let dataInfo;
        if (this.state.showData) {
            dataInfo = react.createElement("div", { style: ProfileSettings_css.dataInfoBox },
                react.createElement(PageInfo, { fields: [
                        {
                            label: 'System',
                            value: profile.system,
                        },
                        {
                            label: 'UV Name',
                            value: profile.uv_name,
                        },
                        {
                            label: 'State',
                            value: profile.state,
                        },
                        {
                            label: 'WireGuard',
                            value: profile.wg,
                        },
                        {
                            label: 'Last Mode',
                            value: profile.last_mode,
                        },
                        {
                            label: 'Organization ID',
                            value: profile.organization_id,
                        },
                        {
                            label: 'Organization',
                            value: profile.organization,
                        },
                        {
                            label: 'Server ID',
                            value: profile.server_id,
                        },
                        {
                            label: 'Server',
                            value: profile.server,
                        },
                        {
                            label: 'User ID',
                            value: profile.user_id,
                        },
                        {
                            label: 'User',
                            value: profile.user,
                        },
                        {
                            label: 'Pre Connect Message',
                            value: profile.pre_connect_msg,
                        },
                        {
                            label: 'Disable Reconnect',
                            value: profile.disable_reconnect,
                        },
                        {
                            label: 'Disable Reconnect Local',
                            value: profile.disable_reconnect_local,
                        },
                        {
                            label: 'Restrict Client',
                            value: profile.restrict_client,
                        },
                        {
                            label: 'Remotes Data',
                            value: JSON.stringify(profile.remotes_data),
                        },
                        {
                            label: 'Dynamic Firewall',
                            value: profile.dynamic_firewall,
                        },
                        {
                            label: 'Geo Sort',
                            value: profile.geo_sort,
                        },
                        {
                            label: 'Force Connect',
                            value: profile.force_connect,
                        },
                        {
                            label: 'Device Auth',
                            value: profile.device_auth,
                        },
                        {
                            label: 'Disable Gateway',
                            value: profile.disable_gateway,
                        },
                        {
                            label: 'Disable DNS',
                            value: profile.disable_dns,
                        },
                        {
                            label: 'Force DNS',
                            value: profile.force_dns,
                        },
                        {
                            label: 'SSO Auth',
                            value: profile.sso_auth,
                        },
                        {
                            label: 'Password Mode',
                            value: profile.password_mode,
                        },
                        {
                            label: 'Token',
                            value: profile.token,
                        },
                        {
                            label: 'Token TTL',
                            value: profile.token_ttl,
                        },
                        {
                            label: 'Sync Hash',
                            value: profile.sync_hash,
                        },
                    ] }));
        }
        return react.createElement("div", { style: ProfileSettings_css.box },
            react.createElement("button", { className: "bp5-button bp5-icon-cog", style: ProfileSettings_css.button, type: "button", disabled: this.state.disabled, onClick: this.openDialog }, "Settings"),
            react.createElement(Dialog, { title: "Profile Settings", style: ProfileSettings_css.dialog, isOpen: this.state.dialog, usePortal: true, portalContainer: document.body, onClose: this.closeDialog },
                react.createElement("div", { className: "bp5-dialog-body" },
                    react.createElement(PageInput, { disabled: this.state.disabled, label: "Name", help: "Profile name.", type: "text", placeholder: "Enter name", value: profile.name || "", onChange: (val) => {
                            this.set("name", val);
                        } }),
                    react.createElement(PageSwitch, { disabled: this.state.disabled, label: "System Profile", help: "Automatically start profile with system service. Autostart profiles will run for all users.", checked: system, onToggle: () => {
                            let profile;
                            if (this.state.changed) {
                                profile = {
                                    ...this.state.profile,
                                };
                            }
                            else {
                                profile = {
                                    ...this.props.profile,
                                };
                            }
                            if (!system && this.state.setAutoStart === null) {
                                this.setState({
                                    ...this.state,
                                    changed: true,
                                    profile: profile,
                                    setSystem: !system,
                                    setAutoStart: true,
                                });
                            }
                            else {
                                this.setState({
                                    ...this.state,
                                    changed: true,
                                    profile: profile,
                                    setSystem: !system,
                                });
                            }
                        } }),
                    react.createElement(PageSwitch, { disabled: this.state.disabled || !system, label: "Autostart", help: "Automatically start profile with system service. Autostart profiles will run for all users. Must be system profile to use autostart.", checked: autostart && system, onToggle: () => {
                            this.set("disabled", !!autostart);
                        } }),
                    react.createElement(PageSwitch, { label: "Disable Auto Reconnect", help: "Disable automatically reconnecting on disconnect.", hidden: !!system || profile.restrict_client, checked: !!profile.disable_reconnect_local, onToggle: () => {
                            this.set("disable_reconnect_local", !profile.disable_reconnect_local);
                        } }),
                    react.createElement(PageSwitch, { label: "Disable Default Gateway", help: "Disable routing internet traffic through the VPN connection.", hidden: profile.restrict_client, checked: !!profile.disable_gateway, onToggle: () => {
                            this.set("disable_gateway", !profile.disable_gateway);
                        } }),
                    react.createElement(PageSwitch, { label: "Disable DNS", help: "Disable configuring the DNS configuration provided by the server on this profile.", hidden: profile.restrict_client, checked: !!profile.disable_dns, onToggle: () => {
                            this.set("disable_dns", !profile.disable_dns);
                        } }),
                    react.createElement(PageSwitch, { label: "Force DNS configuration", help: "Configure only one DNS server to correct issues with macOS DNS server priority.", hidden: platform !== "darwin", checked: !!profile.force_dns, onToggle: () => {
                            this.set("force_dns", !profile.force_dns);
                        } }),
                    react.createElement(PageInfo, { fields: [
                            {
                                label: 'ID',
                                value: profile.id || '-',
                            },
                            {
                                label: 'Configuration Sync Hosts',
                                value: syncHosts,
                            },
                            {
                                label: 'Last Configuration Sync',
                                value: lastSync,
                            },
                        ] }),
                    dataInfo),
                react.createElement("div", { className: "bp5-dialog-footer" },
                    react.createElement("div", { className: "bp5-dialog-footer-actions" },
                        react.createElement("button", { className: "bp5-button bp5-icon-console", type: "button", style: ProfileSettings_css.toggleDataBtn, disabled: this.state.disabled, onClick: this.toggleData }, "Debugging"),
                        react.createElement("button", { className: "bp5-button bp5-intent-danger bp5-icon-cross", type: "button", disabled: this.state.disabled, onClick: this.closeDialog }, "Cancel"),
                        react.createElement("button", { className: "bp5-button bp5-intent-success bp5-icon-tick", type: "button", disabled: this.state.disabled || !this.state.changed, onClick: this.onSave }, "Save")))));
    }
}

;// ./app/components/Profile.js







const Profile_css = {
    box: {
        paddingTop: "31px",
    },
    message: {
        margin: '0 0 6px 0',
    },
    toast: {
        margin: '0 20px 10px 0',
    },
    toastHeader: {
        fontWeight: "bold",
    },
    label: {
        marginBottom: '0',
    },
    labelLast: {
        marginBottom: '-5px',
    },
    card: {
        position: "relative",
        margin: '8px',
        paddingRight: 0,
    },
    progress: {
        width: '100%',
        height: '4px',
        borderRadius: 0,
    },
    progressBar: {
        width: '50%',
        borderRadius: 0,
    },
    button: {
        marginRight: '10px',
    },
    deleteButton: {},
    deleteButtonBox: {
        marginTop: "-1px",
    },
    buttons: {},
    editor: {
        margin: '10px 0 0 0',
    },
    header: {
        userSelect: 'none',
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        padding: '4px',
        height: '39px',
        color: 'inherit',
        border: 'none',
        font: 'inherit',
        cursor: 'default',
        outline: 'inherit',
    },
    headerOpen: {
        userSelect: 'none',
        position: 'absolute',
        top: '0',
        left: '0',
        right: '0',
        padding: '4px',
        height: '36px',
        color: 'inherit',
        border: 'none',
        font: 'inherit',
        cursor: 'pointer',
        outline: 'none',
    },
    headerClosed: {
        userSelect: 'none',
        position: 'absolute',
        top: '1px',
        left: '1px',
        right: '2px',
        padding: '4px',
        height: '36px',
        color: 'inherit',
        border: 'none',
        font: 'inherit',
        cursor: 'pointer',
        backgroundColor: 'inherit',
        outline: 'none',
    },
    headerLabel: {
        fontSize: "1.09em",
        margin: "4px 34px 0 6px",
        overflow: "hidden",
        whiteSpace: "nowrap",
    },
    body: {},
    regBox: {
        padding: "0 20px 10px 0",
    },
    reg: {
        textAlign: "center",
    },
    regTitle: {
        margin: "3px 0 0 0",
    },
    regName: {
        margin: "1px 0 0 0",
        fontSize: "14px",
        fontWeight: "normal",
    },
    regKey: {
        margin: "1px 0",
        fontWeight: "bold",
    },
};
class Profile extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onChange = () => {
            this.setState({
                ...this.state,
            });
        };
        this.onDelete = () => {
            this.setState({
                ...this.state,
                disabled: true,
            });
            let profile = this.props.profile;
            profile.delete().then(() => {
                this.setState({
                    ...this.state,
                    disabled: false,
                });
                sync();
            });
        };
        this.state = {
            open: false,
            message: '',
            disabled: false,
            changed: false,
            value: 'test',
        };
    }
    componentDidMount() {
        Constants_addChangeListener(this.onChange);
    }
    componentWillUnmount() {
        Constants_removeChangeListener(this.onChange);
    }
    render() {
        let profile = this.props.profile;
        let statusLabel = "Online For";
        let statusVal = profile.formattedUptime();
        if (statusVal === "") {
            statusLabel = "Status";
            statusVal = profile.formattedStatus();
        }
        let open = this.state.open || !!profile.registration_key;
        let fieldsLeft = [
            {
                label: 'User',
                value: profile.user || '-',
            },
            {
                label: 'Server',
                value: profile.server || '-',
            },
        ];
        let fieldsRight = [
            {
                label: statusLabel,
                value: statusVal,
            },
            {
                label: 'Organization',
                value: profile.organization || '-',
            },
        ];
        let fieldsLong = [];
        let longIp = false;
        if ((profile.server_addr && profile.server_addr.length >= 16) ||
            (profile.client_addr && profile.client_addr.length >= 16)) {
            fieldsLong.push({
                label: 'Server Address',
                value: profile.server_addr || '-',
                copy: !!profile.server_addr,
            });
            fieldsLong.push({
                label: 'Client Address',
                value: profile.client_addr || '-',
                copy: !!profile.client_addr,
            });
            longIp = true;
        }
        else if (profile.server_addr || profile.client_addr) {
            fieldsLeft.push({
                label: 'Server Address',
                value: profile.server_addr || '-',
                copy: !!profile.server_addr,
            });
            fieldsRight.push({
                label: 'Client Address',
                value: profile.client_addr || '-',
                copy: !!profile.client_addr,
            });
        }
        let header;
        if (this.props.minimal) {
            header = react.createElement("button", { className: (open ? "bp5-card-header " : "") +
                    "layout horizontal tab-toggle", style: open ? Profile_css.headerOpen : Profile_css.headerClosed, onClick: (evt) => {
                    let target = evt.target;
                    if (this.props.minimal &&
                        target.className && target.className.indexOf &&
                        target.className.indexOf('tab-toggle') !== -1) {
                        this.setState({
                            ...this.state,
                            open: !open,
                        });
                    }
                } },
                react.createElement("h3", { className: "tab-toggle", style: Profile_css.headerLabel }, profile.formattedNameShort() || 'Profile'),
                react.createElement("div", { className: "flex tab-toggle" }),
                react.createElement(ProfileConnect, { profile: this.props.profile, minimal: true, hidden: !this.props.minimal || open }),
                react.createElement("div", { style: Profile_css.deleteButtonBox, hidden: this.props.minimal && !open },
                    react.createElement(ConfirmButton, { className: "bp5-minimal bp5-intent-danger bp5-icon-trash", style: Profile_css.deleteButton, safe: true, progressClassName: "bp5-intent-danger", dialogClassName: "bp5-intent-danger bp5-icon-delete", dialogLabel: "Delete Profile", confirmMsg: "Permanently delete this profile", items: [profile.formattedName()], disabled: this.state.disabled, onConfirm: this.onDelete })));
        }
        else {
            header = react.createElement("div", { className: "bp5-card-header layout horizontal tab-toggle", style: Profile_css.header },
                react.createElement("h3", { className: "tab-toggle", style: Profile_css.headerLabel }, profile.formattedNameShort() || 'Profile'),
                react.createElement("div", { className: "flex tab-toggle" }),
                react.createElement("div", { style: Profile_css.deleteButtonBox, hidden: this.props.minimal && !open },
                    react.createElement(ConfirmButton, { className: "bp5-minimal bp5-intent-danger bp5-icon-trash", style: Profile_css.deleteButton, safe: true, progressClassName: "bp5-intent-danger", dialogClassName: "bp5-intent-danger bp5-icon-delete", dialogLabel: "Delete Profile", confirmMsg: "Permanently delete this profile", items: [profile.formattedName()], disabled: this.state.disabled, onConfirm: this.onDelete })));
        }
        return react.createElement("div", { className: "bp5-card layout vertical", style: Profile_css.card },
            header,
            react.createElement("div", { style: Profile_css.box, hidden: this.props.minimal && !open },
                react.createElement("div", { style: Profile_css.toast, hidden: !profile.auth_reconnect, className: "bp5-toast bp5-intent-primary bp5-overlay-content" },
                    react.createElement("span", { className: "bp5-toast-message" },
                        react.createElement("span", { style: Profile_css.toastHeader }, "Connection Lost"),
                        react.createElement("br", null),
                        "Authentication required to reconnect")),
                react.createElement("div", { className: "layout vertical", style: Profile_css.regBox, hidden: !profile.registration_key },
                    react.createElement("div", { className: "bp5-card layout vertical", style: Profile_css.reg },
                        react.createElement("h3", { className: "bp5-text-intent-danger", style: Profile_css.regTitle }, "Device Registration Required"),
                        "Contact Server Administrator with Code:",
                        react.createElement("h3", { className: "bp5-text-intent-primary", style: Profile_css.regName }, hostname),
                        react.createElement("h1", { className: "bp5-text-intent-primary", style: Profile_css.regKey }, profile.registration_key))),
                react.createElement("div", { className: "layout horizontal", style: Profile_css.body },
                    react.createElement(PageInfo, { style: Profile_css.label, fields: fieldsLeft }),
                    react.createElement(PageInfo, { style: Profile_css.label, fields: fieldsRight })),
                react.createElement(PageInfo, { style: Profile_css.labelLast, hidden: !longIp, fields: fieldsLong }),
                react.createElement("div", { style: Profile_css.message, hidden: !this.state.message }, this.state.message),
                react.createElement("div", { className: "layout horizontal" },
                    react.createElement("div", { style: Profile_css.buttons },
                        react.createElement(ProfileConnect, { profile: this.props.profile }),
                        react.createElement(ProfileSettings, { profile: this.props.profile })))));
    }
}

;// ./app/components/Profiles.js




const Profiles_css = {};
class Profiles extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onChange = () => {
            this.setState({
                profiles: stores_ProfilesStore.profiles,
            });
        };
        this.state = {
            profiles: stores_ProfilesStore.profiles,
        };
    }
    componentDidMount() {
        stores_ProfilesStore.addChangeListener(this.onChange);
        sync();
        this.interval = setInterval(() => {
            sync(true);
        }, 1000);
    }
    componentWillUnmount() {
        stores_ProfilesStore.removeChangeListener(this.onChange);
        clearInterval(this.interval);
    }
    render() {
        let profilesDom = [];
        let minimal = this.state.profiles.length > 3;
        let prflIds = new Set();
        this.state.profiles.forEach((prfl) => {
            if (prflIds.has(prfl.id)) {
                return;
            }
            prflIds.add(prfl.id);
            profilesDom.push(react.createElement(Profile, { key: prfl.id, profile: prfl, minimal: minimal }));
        });
        return react.createElement("div", null, profilesDom);
    }
}

;// ./app/utils/LogUtils.js





async function readServiceLog() {
    let logData = "";
    try {
        let resp = await get('/log/service')
            .end();
        logData = resp.data;
    }
    catch (err) {
        err = new RequestError(err, "Logs: Service log request error");
        errorAlert2(err, 10);
    }
    return logData;
}
async function clearServiceLog() {
    try {
        await del('/log/service')
            .end();
    }
    catch (err) {
        err = new RequestError(err, "Logs: Service log request error");
        errorAlert2(err, 10);
    }
}
async function readClientLog() {
    let logData = "";
    let logPath = log();
    try {
        let exists = await fileExists(logPath);
        if (exists) {
            logData = await fileRead(logPath);
        }
    }
    catch (err) {
        errorAlert2(err, 10);
    }
    return logData;
}
async function clearClientLog() {
    try {
        await fileWrite(log(), "");
    }
    catch (err) {
        errorAlert2(err, 10);
    }
}

;// ./node_modules/@monaco-editor/react/dist/index.mjs
var le={wrapper:{display:"flex",position:"relative",textAlign:"initial"},fullWidth:{width:"100%"},hide:{display:"none"}},v=le;var ae={container:{display:"flex",height:"100%",width:"100%",justifyContent:"center",alignItems:"center"}},Y=ae;function Me({children:e}){return react.createElement("div",{style:Y.container},e)}var Z=Me;var $=Z;function Ee({width:e,height:r,isEditorReady:n,loading:t,_ref:a,className:m,wrapperProps:E}){return react.createElement("section",{style:{...v.wrapper,width:e,height:r},...E},!n&&react.createElement($,null,t),react.createElement("div",{ref:a,style:{...v.fullWidth,...!n&&v.hide},className:m}))}var ee=Ee;var H=(0,react.memo)(ee);function Ce(e){(0,react.useEffect)(e,[])}var k=Ce;function he(e,r,n=!0){let t=(0,react.useRef)(!0);(0,react.useEffect)(t.current||!n?()=>{t.current=!1}:e,r)}var l=he;function D(){}function h(e,r,n,t){return De(e,t)||be(e,r,n,t)}function De(e,r){return e.editor.getModel(te(e,r))}function be(e,r,n,t){return e.editor.createModel(r,n,t?te(e,t):void 0)}function te(e,r){return e.Uri.parse(r)}function Oe({original:e,modified:r,language:n,originalLanguage:t,modifiedLanguage:a,originalModelPath:m,modifiedModelPath:E,keepCurrentOriginalModel:g=!1,keepCurrentModifiedModel:N=!1,theme:x="light",loading:P="Loading...",options:y={},height:V="100%",width:z="100%",className:F,wrapperProps:j={},beforeMount:A=D,onMount:q=D}){let[M,O]=(0,react.useState)(!1),[T,s]=(0,react.useState)(!0),u=(0,react.useRef)(null),c=(0,react.useRef)(null),w=(0,react.useRef)(null),d=(0,react.useRef)(q),o=(0,react.useRef)(A),b=(0,react.useRef)(!1);k(()=>{let i=es_loader.init();return i.then(f=>(c.current=f)&&s(!1)).catch(f=>f?.type!=="cancelation"&&console.error("Monaco initialization: error:",f)),()=>u.current?I():i.cancel()}),l(()=>{if(u.current&&c.current){let i=u.current.getOriginalEditor(),f=h(c.current,e||"",t||n||"text",m||"");f!==i.getModel()&&i.setModel(f)}},[m],M),l(()=>{if(u.current&&c.current){let i=u.current.getModifiedEditor(),f=h(c.current,r||"",a||n||"text",E||"");f!==i.getModel()&&i.setModel(f)}},[E],M),l(()=>{let i=u.current.getModifiedEditor();i.getOption(c.current.editor.EditorOption.readOnly)?i.setValue(r||""):r!==i.getValue()&&(i.executeEdits("",[{range:i.getModel().getFullModelRange(),text:r||"",forceMoveMarkers:!0}]),i.pushUndoStop())},[r],M),l(()=>{u.current?.getModel()?.original.setValue(e||"")},[e],M),l(()=>{let{original:i,modified:f}=u.current.getModel();c.current.editor.setModelLanguage(i,t||n||"text"),c.current.editor.setModelLanguage(f,a||n||"text")},[n,t,a],M),l(()=>{c.current?.editor.setTheme(x)},[x],M),l(()=>{u.current?.updateOptions(y)},[y],M);let L=(0,react.useCallback)(()=>{if(!c.current)return;o.current(c.current);let i=h(c.current,e||"",t||n||"text",m||""),f=h(c.current,r||"",a||n||"text",E||"");u.current?.setModel({original:i,modified:f})},[n,r,a,e,t,m,E]),U=(0,react.useCallback)(()=>{!b.current&&w.current&&(u.current=c.current.editor.createDiffEditor(w.current,{automaticLayout:!0,...y}),L(),c.current?.editor.setTheme(x),O(!0),b.current=!0)},[y,x,L]);(0,react.useEffect)(()=>{M&&d.current(u.current,c.current)},[M]),(0,react.useEffect)(()=>{!T&&!M&&U()},[T,M,U]);function I(){let i=u.current?.getModel();g||i?.original?.dispose(),N||i?.modified?.dispose(),u.current?.dispose()}return react.createElement(H,{width:z,height:V,isEditorReady:M,loading:P,_ref:w,className:F,wrapperProps:j})}var ie=Oe;var we=(0,react.memo)(ie);function Pe(){let[e,r]=Ie(ce.__getMonacoInstance());return k(()=>{let n;return e||(n=ce.init(),n.then(t=>{r(t)})),()=>n?.cancel()}),e}var Le=(/* unused pure expression or super */ null && (Pe));function He(e){let r=(0,react.useRef)();return (0,react.useEffect)(()=>{r.current=e},[e]),r.current}var se=He;var _=new Map;function Ve({defaultValue:e,defaultLanguage:r,defaultPath:n,value:t,language:a,path:m,theme:E="light",line:g,loading:N="Loading...",options:x={},overrideServices:P={},saveViewState:y=!0,keepCurrentModel:V=!1,width:z="100%",height:F="100%",className:j,wrapperProps:A={},beforeMount:q=D,onMount:M=D,onChange:O,onValidate:T=D}){let[s,u]=(0,react.useState)(!1),[c,w]=(0,react.useState)(!0),d=(0,react.useRef)(null),o=(0,react.useRef)(null),b=(0,react.useRef)(null),L=(0,react.useRef)(M),U=(0,react.useRef)(q),I=(0,react.useRef)(),i=(0,react.useRef)(t),f=se(m),Q=(0,react.useRef)(!1),B=(0,react.useRef)(!1);k(()=>{let p=es_loader.init();return p.then(R=>(d.current=R)&&w(!1)).catch(R=>R?.type!=="cancelation"&&console.error("Monaco initialization: error:",R)),()=>o.current?pe():p.cancel()}),l(()=>{let p=h(d.current,e||t||"",r||a||"",m||n||"");p!==o.current?.getModel()&&(y&&_.set(f,o.current?.saveViewState()),o.current?.setModel(p),y&&o.current?.restoreViewState(_.get(m)))},[m],s),l(()=>{o.current?.updateOptions(x)},[x],s),l(()=>{!o.current||t===void 0||(o.current.getOption(d.current.editor.EditorOption.readOnly)?o.current.setValue(t):t!==o.current.getValue()&&(B.current=!0,o.current.executeEdits("",[{range:o.current.getModel().getFullModelRange(),text:t,forceMoveMarkers:!0}]),o.current.pushUndoStop(),B.current=!1))},[t],s),l(()=>{let p=o.current?.getModel();p&&a&&d.current?.editor.setModelLanguage(p,a)},[a],s),l(()=>{g!==void 0&&o.current?.revealLine(g)},[g],s),l(()=>{d.current?.editor.setTheme(E)},[E],s);let X=(0,react.useCallback)(()=>{if(!(!b.current||!d.current)&&!Q.current){U.current(d.current);let p=m||n,R=h(d.current,t||e||"",r||a||"",p||"");o.current=d.current?.editor.create(b.current,{model:R,automaticLayout:!0,...x},P),y&&o.current.restoreViewState(_.get(p)),d.current.editor.setTheme(E),g!==void 0&&o.current.revealLine(g),u(!0),Q.current=!0}},[e,r,n,t,a,m,x,P,y,E,g]);(0,react.useEffect)(()=>{s&&L.current(o.current,d.current)},[s]),(0,react.useEffect)(()=>{!c&&!s&&X()},[c,s,X]),i.current=t,(0,react.useEffect)(()=>{s&&O&&(I.current?.dispose(),I.current=o.current?.onDidChangeModelContent(p=>{B.current||O(o.current.getValue(),p)}))},[s,O]),(0,react.useEffect)(()=>{if(s){let p=d.current.editor.onDidChangeMarkers(R=>{let G=o.current.getModel()?.uri;if(G&&R.find(J=>J.path===G.path)){let J=d.current.editor.getModelMarkers({resource:G});T?.(J)}});return()=>{p?.dispose()}}return()=>{}},[s,T]);function pe(){I.current?.dispose(),V?y&&_.set(m,o.current.saveViewState()):o.current.getModel()?.dispose(),o.current.dispose()}return react.createElement(H,{width:z,height:F,isEditorReady:s,loading:N,_ref:b,className:j,wrapperProps:A})}var fe=Ve;var de=(0,react.memo)(fe);var Ft=(/* unused pure expression or super */ null && (de));
//# sourceMappingURL=index.mjs.map
;// ./app/components/Editor.js



const Editor_css = {
    editorBox: {
        margin: "10px 0",
    },
    editor: {
        margin: "11px 0 10px 0",
        borderRadius: "3px",
        overflow: "hidden",
        width: "100%",
    },
};
class Editor extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.state = {};
    }
    render() {
        return react.createElement("div", { className: "layout horizontal flex", style: Editor_css.editorBox },
            react.createElement("div", { style: Editor_css.editor },
                react.createElement(de, { height: this.props.height, width: this.props.width, defaultLanguage: "markdown", theme: getEditorTheme(), value: this.props.value, options: {
                        folding: false,
                        fontSize: this.props.fontSize,
                        fontFamily: monospaceFont,
                        fontWeight: monospaceWeight,
                        tabSize: 4,
                        detectIndentation: false,
                        readOnly: this.props.readOnly,
                        scrollBeyondLastLine: false,
                        minimap: {
                            enabled: false,
                        },
                        wordWrap: "on",
                    }, onChange: (val) => {
                        if (this.props.onChange) {
                            this.props.onChange(val);
                        }
                    } })));
    }
}

;// ./app/components/Logs.js







const Logs_css = {
    message: {
        margin: '0 0 6px 0',
    },
    header: {
        margin: '0 0 5px 0',
    },
    label: {
        marginBottom: '0',
    },
    card: {
        position: "relative",
        margin: '8px',
    },
    layout: {
        height: '100%',
    },
    progress: {
        width: '100%',
        height: '4px',
        borderRadius: 0,
    },
    progressBar: {
        width: '50%',
        borderRadius: 0,
    },
    button: {
        marginRight: '10px',
    },
    deleteButton: {},
    deleteButtonBox: {
        position: "absolute",
        top: "5px",
        right: "5px",
    },
    buttons: {
        flexShrink: 0,
    },
    editor: {
        margin: '10px 0 0 0',
    },
};
class Logs extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onChange = () => {
            if (this.state.view === "service") {
                readServiceLog().then((data) => {
                    this.setState({
                        ...this.state,
                        log: data,
                        profiles: stores_ProfilesStore.profiles,
                    });
                });
            }
            else if (this.state.view === "client") {
                readClientLog().then((data) => {
                    this.setState({
                        ...this.state,
                        log: data,
                        profiles: stores_ProfilesStore.profiles,
                    });
                });
            }
            else if (this.state.curProfile) {
                this.state.curProfile.readLog().then((data) => {
                    this.setState({
                        ...this.state,
                        log: data,
                        profiles: stores_ProfilesStore.profiles,
                    });
                });
            }
        };
        this.onChangeView = (view) => {
            if (view === "service") {
                readServiceLog().then((data) => {
                    this.setState({
                        ...this.state,
                        log: data,
                        view: view,
                        profiles: stores_ProfilesStore.profiles,
                    });
                });
            }
            else if (view === "client") {
                readClientLog().then((data) => {
                    this.setState({
                        ...this.state,
                        log: data,
                        view: view,
                        profiles: stores_ProfilesStore.profiles,
                    });
                });
            }
            else {
                let prfl = stores_ProfilesStore.profile(view);
                prfl.readLog().then((data) => {
                    this.setState({
                        ...this.state,
                        log: data,
                        view: view,
                        curProfile: prfl,
                        profiles: stores_ProfilesStore.profiles,
                    });
                });
            }
        };
        this.onDelete = () => {
            this.setState({
                ...this.state,
                disabled: true,
            });
            if (this.state.view === "service") {
                clearServiceLog().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                    this.onChange();
                });
            }
            else if (this.state.view === "client") {
                clearClientLog().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                    this.onChange();
                });
            }
            else if (this.state.curProfile) {
                this.state.curProfile.clearLog().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                    sync();
                });
            }
        };
        this.state = {
            profiles: stores_ProfilesStore.profiles,
            curProfile: null,
            view: "service",
            log: "",
            disabled: false,
        };
    }
    componentDidMount() {
        Constants_addChangeListener(this.onChange);
        stores_ProfilesStore.addChangeListener(this.onChange);
        sync();
        this.onChange();
    }
    componentWillUnmount() {
        Constants_removeChangeListener(this.onChange);
        stores_ProfilesStore.removeChangeListener(this.onChange);
    }
    render() {
        let label = "";
        if (this.state.view === "service") {
            label = "Service";
        }
        else if (this.state.view === "client") {
            label = "Client";
        }
        else if (this.state.curProfile) {
            label = this.state.curProfile.formattedName();
        }
        let viewsDom = [
            react.createElement("option", { value: "service" }, "Service logs"),
            react.createElement("option", { value: "client" }, "Client logs"),
        ];
        this.state.profiles.forEach((prfl) => {
            viewsDom.push(react.createElement("option", { value: prfl.id }, prfl.formattedName() + " logs"));
        });
        return react.createElement("div", { className: "bp5-card layout vertical flex", style: Logs_css.card },
            react.createElement("div", { style: Logs_css.deleteButtonBox },
                react.createElement(ConfirmButton, { className: "bp5-minimal bp5-intent-danger bp5-icon-trash", style: Logs_css.deleteButton, safe: true, progressClassName: "bp5-intent-danger", dialogClassName: "bp5-intent-danger bp5-icon-delete", dialogLabel: "Clear Logs", confirmMsg: "Confirm clearing " + label + " logs", disabled: this.state.disabled, onConfirm: this.onDelete })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement("h3", { style: Logs_css.header }, "Log Viewer")),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement("div", { className: "bp5-select" },
                    react.createElement("select", { disabled: this.state.disabled, value: this.state.view, onChange: (evt) => {
                            this.onChangeView(evt.target.value);
                        } }, viewsDom))),
            react.createElement("div", { className: "layout horizontal flex" },
                react.createElement("label", { className: "bp5-label flex", style: Logs_css.editor },
                    react.createElement(Editor, { disabled: this.state.disabled, value: this.state.log, readOnly: true, mode: "text", fontSize: 10, height: "500px", width: "100%" }))));
    }
}

;// ./app/stores/ConfigStore.js




class ConfigStore extends EventEmitter {
    constructor() {
        super(...arguments);
        this._token = dispatcher_Dispatcher.register((this._callback).bind(this));
    }
    get config() {
        return this._config || {};
    }
    get configM() {
        if (this._config) {
            return {
                ...this._config || {},
            };
        }
        return undefined;
    }
    emitChange() {
        this.emitDefer(GlobalTypes_CHANGE);
    }
    addChangeListener(callback) {
        this.on(GlobalTypes_CHANGE, callback);
    }
    removeChangeListener(callback) {
        this.removeListener(GlobalTypes_CHANGE, callback);
    }
    _sync(config) {
        this._config = Object.freeze(config);
        this.emitChange();
    }
    _callback(action) {
        switch (action.type) {
            case ConfigTypes_SYNC:
                this._sync(action.data);
                break;
        }
    }
}
/* harmony default export */ const stores_ConfigStore = (new ConfigStore());

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/components/chevron-up.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var ChevronUp = react.forwardRef(function (props, ref) {
    var isLarge = props.size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var translation = "".concat(-1 * pixelGridSize / 0.05 / 2);
    var style = { transformOrigin: "center" };
    return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ iconName: "chevron-up", ref: ref }, props),
        react.createElement("path", { d: isLarge ? "M334.2000000000001 154.2L214.2 274.2000000000001C210.6 277.8 205.6 280 200 280S189.4 277.8 185.8 274.2L65.8 154.2C62.2 150.6 60 145.6 60 140C60 129 69 120 80 120C85.6 120 90.6 122.2 94.2 125.8L200 231.8L305.8 126C309.4000000000001 122.2 314.4000000000001 120 320 120C331 120 340 129 340 140C340 145.6 337.8 150.6 334.2000000000001 154.2z" : "M254.2 134.2L174.2 214.2C170.6 217.8 165.6 220 160 220S149.4 217.8 145.8 214.2L65.8 134.2C62.2 130.6 60 125.6 60 120C60 109 69 100 80 100C85.6 100 90.6 102.2 94.2 105.8L160 171.8L225.8 106C229.4 102.2 234.4 100 240 100C251 100 260 109 260 120C260 125.6 257.8 130.6 254.2 134.2z", fillRule: "evenodd", transform: "scale(0.05, -0.05) translate(".concat(translation, ", ").concat(translation, ")"), style: style })));
});
ChevronUp.defaultProps = {
    size: iconTypes/* IconSize */.l.STANDARD,
};
ChevronUp.displayName = "Blueprint5.Icon.ChevronUp";
/* harmony default export */ const chevron_up = ((/* unused pure expression or super */ null && (ChevronUp)));

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/components/chevron-down.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var ChevronDown = react.forwardRef(function (props, ref) {
    var isLarge = props.size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var translation = "".concat(-1 * pixelGridSize / 0.05 / 2);
    var style = { transformOrigin: "center" };
    return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ iconName: "chevron-down", ref: ref }, props),
        react.createElement("path", { d: isLarge ? "M320 280C314.4000000000001 280 309.4000000000001 277.8 305.8 274.2L200 168.2L94.2 274.2C90.6 277.8 85.6 280 80 280C69 280 60 271 60 260C60 254.4 62.2 249.4 65.8 245.8L185.8 125.8C189.4 122.2 194.4 120 200 120S210.6 122.2 214.2 125.8L334.2000000000001 245.8C337.8 249.4 340 254.4 340 260C340 271 331 280 320 280z" : "M240 220C234.4 220 229.4 217.8 225.8 214.2L160 148.2L94.2 214.2C90.6 217.8 85.6 220 80 220C69 220 60 211 60 200C60 194.4 62.2 189.4 65.8 185.8L145.8 105.8C149.4 102.2 154.4 100 160 100S170.6 102.2 174.2 105.8L254.2 185.8C257.8 189.4 260 194.4 260 200C260 211 251 220 240 220z", fillRule: "evenodd", transform: "scale(0.05, -0.05) translate(".concat(translation, ", ").concat(translation, ")"), style: style })));
});
ChevronDown.defaultProps = {
    size: iconTypes/* IconSize */.l.STANDARD,
};
ChevronDown.displayName = "Blueprint5.Icon.ChevronDown";
/* harmony default export */ const chevron_down = ((/* unused pure expression or super */ null && (ChevronDown)));

;// ./node_modules/@blueprintjs/core/lib/esm/components/forms/controlGroup.js
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * Control group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/control-group
 */
var ControlGroup = react.forwardRef(function (props, ref) {
    var _a;
    var children = props.children, className = props.className, fill = props.fill, vertical = props.vertical, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["children", "className", "fill", "vertical"]);
    var rootClasses = classnames_default()(CONTROL_GROUP, (_a = {},
        _a[FILL] = fill,
        _a[VERTICAL] = vertical,
        _a), className);
    return (react.createElement("div", (0,tslib_es6/* __assign */.Cl)({ role: "group" }, htmlProps, { ref: ref, className: rootClasses }), children));
});
ControlGroup.displayName = "".concat(DISPLAYNAME_PREFIX, ".ControlGroup");

;// ./node_modules/@blueprintjs/core/lib/esm/components/forms/asyncControllableInput.js
/* !
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * A stateful wrapper around the low-level <input> component which works around a
 * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input
 * receives CompositionEvents (for example, through IME composition) and has its value prop updated
 * asychronously. This might happen if a component chooses to do async validation of a value
 * returned by the input's `onChange` callback.
 *
 * Note: this component does not apply any Blueprint-specific styling.
 */
var AsyncControllableInput = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(AsyncControllableInput, _super);
    function AsyncControllableInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            hasPendingUpdate: false,
            isComposing: false,
            nextValue: _this.props.value,
            value: _this.props.value,
        };
        _this.cancelPendingCompositionEnd = null;
        _this.handleCompositionStart = function (e) {
            var _a, _b, _c;
            (_a = _this.cancelPendingCompositionEnd) === null || _a === void 0 ? void 0 : _a.call(_this);
            _this.setState({ isComposing: true });
            (_c = (_b = _this.props).onCompositionStart) === null || _c === void 0 ? void 0 : _c.call(_b, e);
        };
        _this.handleCompositionEnd = function (e) {
            var _a, _b;
            // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.
            // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we
            // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.
            // `this.state.nextValue` will become "locked" (it cannot be overwritten by the `value` prop) until a delay (10ms) has
            // passed without a new composition event starting.
            _this.cancelPendingCompositionEnd = _this.setTimeout(function () { return _this.setState({ isComposing: false }); }, AsyncControllableInput.COMPOSITION_END_DELAY);
            (_b = (_a = _this.props).onCompositionEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        _this.handleChange = function (e) {
            var _a, _b;
            var value = e.target.value;
            _this.setState({ nextValue: value });
            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        return _this;
    }
    AsyncControllableInput.getDerivedStateFromProps = function (nextProps, nextState) {
        if (nextState.isComposing || nextProps.value === undefined) {
            // don't derive anything from props if:
            // - in uncontrolled mode, OR
            // - currently composing, since we'll do that after composition ends
            return null;
        }
        var userTriggeredUpdate = nextState.nextValue !== nextState.value;
        if (userTriggeredUpdate) {
            if (nextProps.value === nextState.nextValue) {
                // parent has processed and accepted our update
                if (nextState.hasPendingUpdate) {
                    return { hasPendingUpdate: false, value: nextProps.value };
                }
                else {
                    return { value: nextState.nextValue };
                }
            }
            else {
                if (nextProps.value === nextState.value) {
                    // we have sent the update to our parent, but it has not been processed yet. just wait.
                    // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,
                    // causing the cursor to jump once the new value is accepted
                    return { hasPendingUpdate: true };
                }
                // accept controlled update overriding user action
                return { hasPendingUpdate: false, nextValue: nextProps.value, value: nextProps.value };
            }
        }
        else {
            // accept controlled update, could be confirming or denying user action
            return { hasPendingUpdate: false, nextValue: nextProps.value, value: nextProps.value };
        }
    };
    AsyncControllableInput.prototype.render = function () {
        var _a = this.state, isComposing = _a.isComposing, hasPendingUpdate = _a.hasPendingUpdate, value = _a.value, nextValue = _a.nextValue;
        var _b = this.props, inputRef = _b.inputRef, restProps = (0,tslib_es6/* __rest */.Tt)(_b, ["inputRef"]);
        return (react.createElement("input", (0,tslib_es6/* __assign */.Cl)({}, restProps, { ref: inputRef, 
            // render the pending value even if it is not confirmed by a parent's async controlled update
            // so that the cursor does not jump to the end of input as reported in
            // https://github.com/palantir/blueprint/issues/4298
            value: isComposing || hasPendingUpdate ? nextValue : value, onCompositionStart: this.handleCompositionStart, onCompositionEnd: this.handleCompositionEnd, onChange: this.handleChange })));
    };
    AsyncControllableInput.displayName = "".concat(DISPLAYNAME_PREFIX, ".AsyncControllableInput");
    /**
     * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before
     * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.
     */
    AsyncControllableInput.COMPOSITION_END_DELAY = 10;
    return AsyncControllableInput;
}(AbstractPureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/components/forms/inputGroup.js
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var NON_HTML_PROPS = ["inputSize", "onValueChange"];
/**
 * Input group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/input-group
 */
var InputGroup = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(InputGroup, _super);
    function InputGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {};
        _this.leftElement = null;
        _this.rightElement = null;
        _this.refHandlers = {
            leftElement: function (ref) { return (_this.leftElement = ref); },
            rightElement: function (ref) { return (_this.rightElement = ref); },
        };
        _this.handleInputChange = function (event) {
            var _a, _b, _c, _d;
            var value = event.target.value;
            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, event);
            (_d = (_c = _this.props).onValueChange) === null || _d === void 0 ? void 0 : _d.call(_c, value, event.target);
        };
        return _this;
    }
    InputGroup.prototype.render = function () {
        var _a;
        var _b = this.props, _c = _b.asyncControl, asyncControl = _c === void 0 ? false : _c, className = _b.className, disabled = _b.disabled, fill = _b.fill, inputClassName = _b.inputClassName, inputRef = _b.inputRef, inputSize = _b.inputSize, intent = _b.intent, 
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        large = _b.large, readOnly = _b.readOnly, round = _b.round, _d = _b.size, size = _d === void 0 ? "medium" : _d, 
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        small = _b.small, _e = _b.tagName, tagName = _e === void 0 ? "div" : _e;
        var inputGroupClasses = classnames_default()(INPUT_GROUP, classes_intentClass(intent), (_a = {},
            _a[DISABLED] = disabled,
            _a[READ_ONLY] = readOnly,
            _a[FILL] = fill,
            _a[ROUND] = round,
            _a), sizeClass(size, { large: large, small: small }), className);
        var style = (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, this.props.style), { paddingLeft: this.state.leftElementWidth, paddingRight: this.state.rightElementWidth });
        var inputProps = (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ type: "text" }, removeNonHTMLProps(this.props, NON_HTML_PROPS, true)), { "aria-disabled": disabled, className: classnames_default()(INPUT, inputClassName), onChange: this.handleInputChange, size: inputSize !== null && inputSize !== void 0 ? inputSize : (typeof size === "number" ? size : undefined), style: style });
        var inputElement = asyncControl ? (react.createElement(AsyncControllableInput, (0,tslib_es6/* __assign */.Cl)({}, inputProps, { inputRef: inputRef }))) : (react.createElement("input", (0,tslib_es6/* __assign */.Cl)({}, inputProps, { ref: inputRef })));
        return react.createElement(tagName, { className: inputGroupClasses }, this.maybeRenderLeftElement(), inputElement, this.maybeRenderRightElement());
    };
    InputGroup.prototype.componentDidMount = function () {
        this.updateInputWidth();
    };
    InputGroup.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, leftElement = _a.leftElement, rightElement = _a.rightElement;
        if (prevProps.leftElement !== leftElement || prevProps.rightElement !== rightElement) {
            this.updateInputWidth();
        }
    };
    InputGroup.prototype.validateProps = function (props) {
        if (props.leftElement != null && props.leftIcon != null) {
            console.warn(INPUT_WARN_LEFT_ELEMENT_LEFT_ICON_MUTEX);
        }
    };
    InputGroup.prototype.maybeRenderLeftElement = function () {
        var _a = this.props, leftElement = _a.leftElement, leftIcon = _a.leftIcon;
        if (leftElement != null) {
            return (react.createElement("span", { className: INPUT_LEFT_CONTAINER, ref: this.refHandlers.leftElement }, leftElement));
        }
        else if (leftIcon != null) {
            return react.createElement(Icon, { icon: leftIcon, "aria-hidden": true, tabIndex: -1 });
        }
        return undefined;
    };
    InputGroup.prototype.maybeRenderRightElement = function () {
        var rightElement = this.props.rightElement;
        if (rightElement == null) {
            return undefined;
        }
        return (react.createElement("span", { className: INPUT_ACTION, ref: this.refHandlers.rightElement }, rightElement));
    };
    InputGroup.prototype.updateInputWidth = function () {
        var _a = this.state, leftElementWidth = _a.leftElementWidth, rightElementWidth = _a.rightElementWidth;
        if (this.leftElement != null) {
            var clientWidth = this.leftElement.clientWidth;
            // small threshold to prevent infinite loops
            if (leftElementWidth === undefined || Math.abs(clientWidth - leftElementWidth) > 2) {
                this.setState({ leftElementWidth: clientWidth });
            }
        }
        else {
            this.setState({ leftElementWidth: undefined });
        }
        if (this.rightElement != null) {
            var clientWidth = this.rightElement.clientWidth;
            // small threshold to prevent infinite loops
            if (rightElementWidth === undefined || Math.abs(clientWidth - rightElementWidth) > 2) {
                this.setState({ rightElementWidth: clientWidth });
            }
        }
        else {
            this.setState({ rightElementWidth: undefined });
        }
    };
    InputGroup.displayName = "".concat(DISPLAYNAME_PREFIX, ".InputGroup");
    return InputGroup;
}(AbstractPureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/components/forms/numericInputUtils.js
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Returns the `decimal` number separator based on locale */
function getDecimalSeparator(locale) {
    var testNumber = 1.9;
    var testText = testNumber.toLocaleString(locale);
    var one = (1).toLocaleString(locale);
    var nine = (9).toLocaleString(locale);
    var pattern = "".concat(one, "(.+)").concat(nine);
    var result = new RegExp(pattern).exec(testText);
    return (result && result[1]) || ".";
}
function toLocaleString(num, locale) {
    if (locale === void 0) { locale = "en-US"; }
    // HACKHACK: roundingPriority is not supported yet in TypeScript https://github.com/microsoft/TypeScript/issues/43336
    return sanitizeNumericInput(num.toLocaleString(locale, { roundingPriority: "morePrecision" }), locale);
}
function clampValue(value, min, max) {
    // defaultProps won't work if the user passes in null, so just default
    // to +/- infinity here instead, as a catch-all.
    var adjustedMin = min != null ? min : -Infinity;
    var adjustedMax = max != null ? max : Infinity;
    return clamp(value, adjustedMin, adjustedMax);
}
function getValueOrEmptyValue(value) {
    if (value === void 0) { value = ""; }
    return value.toString();
}
/** Transform the localized character (ex. "") to a javascript recognizable string number (ex. "10.99")  */
function transformLocalizedNumberToStringNumber(character, locale) {
    var charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (value) { return value.toLocaleString(locale); });
    var jsNumber = charactersMap.indexOf(character);
    if (jsNumber !== -1) {
        return jsNumber;
    }
    else {
        return character;
    }
}
/** Transforms the localized number (ex. "10,99") to a javascript recognizable string number (ex. "10.99")  */
function parseStringToStringNumber(value, locale) {
    var valueAsString = "" + value;
    if (parseFloat(valueAsString).toString() === value.toString()) {
        return value.toString();
    }
    if (locale !== undefined) {
        var decimalSeparator = getDecimalSeparator(locale);
        var sanitizedString = sanitizeNumericInput(valueAsString, locale);
        return sanitizedString
            .split("")
            .map(function (character) { return transformLocalizedNumberToStringNumber(character, locale); })
            .join("")
            .replace(decimalSeparator, ".");
    }
    return value.toString();
}
/** Returns `true` if the string represents a valid numeric value, like "1e6". */
function isValueNumeric(value, locale) {
    // checking if a string is numeric in Typescript is a big pain, because
    // we can't simply toss a string parameter to isFinite. below is the
    // essential approach that jQuery uses, which involves subtracting a
    // parsed numeric value from the string representation of the value. we
    // need to cast the value to the `any` type to allow this operation
    // between dissimilar types.
    var stringToStringNumber = parseStringToStringNumber(value, locale);
    return value != null && stringToStringNumber - parseFloat(stringToStringNumber) + 1 >= 0;
}
function isValidNumericKeyboardEvent(e, locale) {
    // unit tests may not include e.key. don't bother disabling those events.
    if (e.key == null) {
        return true;
    }
    // allow modified key strokes that may involve letters and other
    // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).
    if (e.ctrlKey || e.altKey || e.metaKey) {
        return true;
    }
    // keys that print a single character when pressed have a `key` name of
    // length 1. every other key has a longer `key` name (e.g. "Backspace",
    // "ArrowUp", "Shift"). since none of those keys can print a character
    // to the field--and since they may have important native behaviors
    // beyond printing a character--we don't want to disable their effects.
    var isSingleCharKey = e.key.length === 1;
    if (!isSingleCharKey) {
        return true;
    }
    // now we can simply check that the single character that wants to be printed
    // is a floating-point number character that we're allowed to print.
    return isFloatingPointNumericCharacter(e.key, locale);
}
/**
 * A regex that matches a string of length 1 (i.e. a standalone character)
 * if and only if it is a floating-point number character as defined by W3C:
 * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float
 *
 * Floating-point number characters are the only characters that can be
 * printed within a default input[type="number"]. This component should
 * behave the same way when this.props.allowNumericCharactersOnly = true.
 * See here for the input[type="number"].value spec:
 * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value
 */
function isFloatingPointNumericCharacter(character, locale) {
    if (locale !== undefined) {
        var decimalSeparator = getDecimalSeparator(locale).replace(".", "\\.");
        var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (value) { return value.toLocaleString(locale); }).join("");
        var localeFloatingPointNumericCharacterRegex = new RegExp("^[Ee" + numbers + "\\+\\-" + decimalSeparator + "]$");
        return localeFloatingPointNumericCharacterRegex.test(character);
    }
    else {
        var floatingPointNumericCharacterRegex = /^[Ee0-9\+\-\.]$/;
        return floatingPointNumericCharacterRegex.test(character);
    }
}
/**
 * Round the value to have _up to_ the specified maximum precision.
 *
 * This differs from `toFixed(5)` in that trailing zeroes are not added on
 * more precise values, resulting in shorter strings.
 */
function toMaxPrecision(value, maxPrecision) {
    // round the value to have the specified maximum precision (toFixed is the wrong choice,
    // because it would show trailing zeros in the decimal part out to the specified precision)
    // source: http://stackoverflow.com/a/18358056/5199574
    var scaleFactor = Math.pow(10, maxPrecision);
    return Math.round(value * scaleFactor) / scaleFactor;
}
/**
 * Convert Japanese full-width numbers, e.g. '', to ASCII, e.g. '5'
 * This should be called before performing any other numeric string input validation.
 */
function convertFullWidthNumbersToAscii(value) {
    return value.replace(/[\uFF10-\uFF19]/g, function (m) { return String.fromCharCode(m.charCodeAt(0) - 0xfee0); });
}
/**
 * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters
 */
function sanitizeNumericInput(value, locale) {
    var valueChars = convertFullWidthNumbersToAscii(value).split("");
    var sanitizedValueChars = valueChars.filter(function (valueChar) { return isFloatingPointNumericCharacter(valueChar, locale); });
    return sanitizedValueChars.join("");
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/forms/numericInput.js
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var IncrementDirection;
(function (IncrementDirection) {
    IncrementDirection[IncrementDirection["DOWN"] = -1] = "DOWN";
    IncrementDirection[IncrementDirection["UP"] = 1] = "UP";
})(IncrementDirection || (IncrementDirection = {}));
var numericInput_NON_HTML_PROPS = [
    "allowNumericCharactersOnly",
    "buttonPosition",
    "clampValueOnBlur",
    "className",
    "defaultValue",
    "majorStepSize",
    "minorStepSize",
    "onButtonClick",
    "onValueChange",
    "selectAllOnFocus",
    "selectAllOnIncrement",
    "stepSize",
];
/**
 * Numeric input component.
 *
 * @see https://blueprintjs.com/docs/#core/components/numeric-input
 */
var NumericInput = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(NumericInput, _super);
    function NumericInput() {
        var _a;
        var _this = _super.apply(this, arguments) || this;
        _this.numericInputId = uniqueId("numericInput");
        _this.state = {
            currentImeInputInvalid: false,
            shouldSelectAfterUpdate: false,
            stepMaxPrecision: NumericInput.getStepMaxPrecision(_this.props),
            value: getValueOrEmptyValue((_a = _this.props.value) !== null && _a !== void 0 ? _a : _this.props.defaultValue),
        };
        // updating these flags need not trigger re-renders, so don't include them in this.state.
        _this.didPasteEventJustOccur = false;
        _this.delta = 0;
        _this.inputElement = null;
        _this.inputRef = refHandler(_this, "inputElement", _this.props.inputRef);
        _this.incrementButtonHandlers = _this.getButtonEventHandlers(IncrementDirection.UP);
        _this.decrementButtonHandlers = _this.getButtonEventHandlers(IncrementDirection.DOWN);
        _this.getCurrentValueAsNumber = function () { return Number(parseStringToStringNumber(_this.state.value, _this.props.locale)); };
        _this.handleButtonClick = function (e, direction) {
            var _a, _b;
            var delta = _this.updateDelta(direction, e);
            var nextValue = _this.incrementValue(delta);
            (_b = (_a = _this.props).onButtonClick) === null || _b === void 0 ? void 0 : _b.call(_a, Number(parseStringToStringNumber(nextValue, _this.props.locale)), nextValue);
        };
        _this.stopContinuousChange = function () {
            _this.delta = 0;
            _this.clearTimeouts();
            clearInterval(_this.intervalId);
            document.removeEventListener("mouseup", _this.stopContinuousChange);
        };
        _this.handleContinuousChange = function () {
            var _a, _b, _c, _d;
            // If either min or max prop is set, when reaching the limit
            // the button will be disabled and stopContinuousChange will be never fired,
            // hence the need to check on each iteration to properly clear the timeout
            if (_this.props.min !== undefined || _this.props.max !== undefined) {
                var min = (_a = _this.props.min) !== null && _a !== void 0 ? _a : -Infinity;
                var max = (_b = _this.props.max) !== null && _b !== void 0 ? _b : Infinity;
                var valueAsNumber = _this.getCurrentValueAsNumber();
                if (valueAsNumber <= min || valueAsNumber >= max) {
                    _this.stopContinuousChange();
                    return;
                }
            }
            var nextValue = _this.incrementValue(_this.delta);
            (_d = (_c = _this.props).onButtonClick) === null || _d === void 0 ? void 0 : _d.call(_c, Number(parseStringToStringNumber(nextValue, _this.props.locale)), nextValue);
        };
        // Callbacks - Input
        // =================
        _this.handleInputFocus = function (e) {
            var _a, _b;
            // update this state flag to trigger update for input selection (see componentDidUpdate)
            _this.setState({ shouldSelectAfterUpdate: _this.props.selectAllOnFocus });
            (_b = (_a = _this.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        _this.handleInputBlur = function (e) {
            var _a, _b;
            // always disable this flag on blur so it's ready for next time.
            _this.setState({ shouldSelectAfterUpdate: false });
            if (_this.props.clampValueOnBlur) {
                var value = e.target.value;
                _this.handleNextValue(_this.roundAndClampValue(value));
            }
            (_b = (_a = _this.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        _this.handleInputKeyDown = function (e) {
            var _a, _b;
            if (_this.props.disabled || _this.props.readOnly) {
                return;
            }
            var direction = getArrowKeyDirection(e, ["ArrowDown"], ["ArrowUp"]);
            if (direction !== undefined) {
                // when the input field has focus, some key combinations will modify
                // the field's selection range. we'll actually want to select all
                // text in the field after we modify the value on the following
                // lines. preventing the default selection behavior lets us do that
                // without interference.
                e.preventDefault();
                var delta = _this.updateDelta(direction, e);
                _this.incrementValue(delta);
            }
            (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        _this.handleCompositionEnd = function (e) {
            if (_this.props.allowNumericCharactersOnly) {
                _this.handleNextValue(sanitizeNumericInput(e.data, _this.props.locale));
                _this.setState({ currentImeInputInvalid: false });
            }
        };
        _this.handleCompositionUpdate = function (e) {
            if (_this.props.allowNumericCharactersOnly) {
                var data = e.data;
                var sanitizedValue = sanitizeNumericInput(data, _this.props.locale);
                if (sanitizedValue.length === 0 && data.length > 0) {
                    _this.setState({ currentImeInputInvalid: true });
                }
                else {
                    _this.setState({ currentImeInputInvalid: false });
                }
            }
        };
        _this.handleInputKeyPress = function (e) {
            var _a, _b;
            // we prohibit keystrokes in onKeyPress instead of onKeyDown, because
            // e.key is not trustworthy in onKeyDown in all browsers.
            if (_this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e, _this.props.locale)) {
                e.preventDefault();
            }
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            (_b = (_a = _this.props).onKeyPress) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        _this.handleInputPaste = function (e) {
            var _a, _b;
            _this.didPasteEventJustOccur = true;
            (_b = (_a = _this.props).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        _this.handleInputChange = function (value) {
            var nextValue = value;
            if (_this.props.allowNumericCharactersOnly && _this.didPasteEventJustOccur) {
                _this.didPasteEventJustOccur = false;
                nextValue = sanitizeNumericInput(value, _this.props.locale);
            }
            _this.handleNextValue(nextValue);
            _this.setState({ shouldSelectAfterUpdate: false });
        };
        return _this;
    }
    NumericInput.getDerivedStateFromProps = function (props, state) {
        var _a, _b;
        var nextState = {
            prevMaxProp: props.max,
            prevMinProp: props.min,
        };
        var didMinChange = props.min !== state.prevMinProp;
        var didMaxChange = props.max !== state.prevMaxProp;
        var didBoundsChange = didMinChange || didMaxChange;
        // in controlled mode, use props.value
        // in uncontrolled mode, if state.value has not been assigned yet (upon initial mount), use props.defaultValue
        var value = (_b = (_a = props.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : state.value;
        var stepMaxPrecision = NumericInput.getStepMaxPrecision(props);
        var sanitizedValue = value !== NumericInput.VALUE_EMPTY
            ? NumericInput.roundAndClampValue(value, stepMaxPrecision, props.min, props.max, 0, props.locale)
            : NumericInput.VALUE_EMPTY;
        // if a new min and max were provided that cause the existing value to fall
        // outside of the new bounds, then clamp the value to the new valid range.
        if (didBoundsChange && sanitizedValue !== state.value) {
            return (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, nextState), { stepMaxPrecision: stepMaxPrecision, value: sanitizedValue });
        }
        return (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, nextState), { stepMaxPrecision: stepMaxPrecision, value: value });
    };
    // Value Helpers
    // =============
    NumericInput.getStepMaxPrecision = function (props) {
        if (props.minorStepSize != null) {
            return countDecimalPlaces(props.minorStepSize);
        }
        else {
            return countDecimalPlaces(props.stepSize);
        }
    };
    NumericInput.roundAndClampValue = function (value, stepMaxPrecision, min, max, delta, locale) {
        if (delta === void 0) { delta = 0; }
        if (!isValueNumeric(value, locale)) {
            return NumericInput.VALUE_EMPTY;
        }
        var currentValue = parseStringToStringNumber(value, locale);
        var nextValue = toMaxPrecision(Number(currentValue) + delta, stepMaxPrecision);
        var clampedValue = clampValue(nextValue, min, max);
        return toLocaleString(clampedValue, locale);
    };
    NumericInput.prototype.render = function () {
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        var _a = this.props, buttonPosition = _a.buttonPosition, className = _a.className, fill = _a.fill, large = _a.large, _b = _a.size, size = _b === void 0 ? "medium" : _b, small = _a.small;
        var containerClasses = classnames_default()(NUMERIC_INPUT, sizeClass(size, { large: large, small: small }), className);
        var buttons = this.renderButtons();
        return (react.createElement(ControlGroup, { className: containerClasses, fill: fill },
            buttonPosition === Position.LEFT && buttons,
            this.renderInput(),
            buttonPosition === Position.RIGHT && buttons));
    };
    NumericInput.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _a, _b, _c;
        _super.prototype.componentDidUpdate.call(this, prevProps, prevState);
        if (prevProps.inputRef !== this.props.inputRef) {
            setRef(prevProps.inputRef, null);
            this.inputRef = refHandler(this, "inputElement", this.props.inputRef);
            setRef(this.props.inputRef, this.inputElement);
        }
        if (this.state.shouldSelectAfterUpdate) {
            (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.setSelectionRange(0, this.state.value.length);
        }
        var didMinChange = this.props.min !== prevProps.min;
        var didMaxChange = this.props.max !== prevProps.max;
        var didBoundsChange = didMinChange || didMaxChange;
        var didLocaleChange = this.props.locale !== prevProps.locale;
        var didValueChange = this.state.value !== prevState.value;
        if ((didBoundsChange && didValueChange) || (didLocaleChange && prevState.value !== NumericInput.VALUE_EMPTY)) {
            // we clamped the value due to a bounds change, so we should fire the change callback
            var valueToParse = didLocaleChange ? prevState.value : this.state.value;
            var valueAsString = parseStringToStringNumber(valueToParse, prevProps.locale);
            var localizedValue = toLocaleString(+valueAsString, this.props.locale);
            (_c = (_b = this.props).onValueChange) === null || _c === void 0 ? void 0 : _c.call(_b, +valueAsString, localizedValue, this.inputElement);
        }
    };
    NumericInput.prototype.validateProps = function (nextProps) {
        var majorStepSize = nextProps.majorStepSize, max = nextProps.max, min = nextProps.min, minorStepSize = nextProps.minorStepSize, stepSize = nextProps.stepSize, value = nextProps.value;
        if (min != null && max != null && min > max) {
            console.error(NUMERIC_INPUT_MIN_MAX);
        }
        if (stepSize <= 0) {
            console.error(NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);
        }
        if (minorStepSize && minorStepSize <= 0) {
            console.error(NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);
        }
        if (majorStepSize && majorStepSize <= 0) {
            console.error(NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);
        }
        if (minorStepSize && minorStepSize > stepSize) {
            console.error(NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);
        }
        if (majorStepSize && majorStepSize < stepSize) {
            console.error(NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);
        }
        // controlled mode
        if (value != null) {
            var stepMaxPrecision = NumericInput.getStepMaxPrecision(nextProps);
            var sanitizedValue = NumericInput.roundAndClampValue(value.toString(), stepMaxPrecision, min, max, 0, this.props.locale);
            var valueDoesNotMatch = sanitizedValue !== value.toString();
            var localizedValue = toLocaleString(Number(parseStringToStringNumber(value, this.props.locale)), this.props.locale);
            var isNotLocalized = sanitizedValue !== localizedValue;
            if (valueDoesNotMatch && isNotLocalized) {
                console.warn(NUMERIC_INPUT_CONTROLLED_VALUE_INVALID);
            }
        }
    };
    // Render Helpers
    // ==============
    NumericInput.prototype.renderButtons = function () {
        var _a = this.props, intent = _a.intent, max = _a.max, min = _a.min, locale = _a.locale;
        var value = parseStringToStringNumber(this.state.value, locale);
        var disabled = this.props.disabled || this.props.readOnly;
        var isIncrementDisabled = max !== undefined && value !== "" && +value >= max;
        var isDecrementDisabled = min !== undefined && value !== "" && +value <= min;
        return (react.createElement(ButtonGroup, { className: FIXED, key: "button-group", vertical: true },
            react.createElement(Button, (0,tslib_es6/* __assign */.Cl)({ "aria-label": "increment", "aria-controls": this.numericInputId, disabled: disabled || isIncrementDisabled, icon: react.createElement(ChevronUp, null), intent: intent }, this.incrementButtonHandlers)),
            react.createElement(Button, (0,tslib_es6/* __assign */.Cl)({ "aria-label": "decrement", "aria-controls": this.numericInputId, disabled: disabled || isDecrementDisabled, icon: react.createElement(ChevronDown, null), intent: intent }, this.decrementButtonHandlers))));
    };
    NumericInput.prototype.renderInput = function () {
        var inputGroupHtmlProps = removeNonHTMLProps(this.props, numericInput_NON_HTML_PROPS, true);
        var valueAsNumber = this.getCurrentValueAsNumber();
        return (react.createElement(InputGroup, (0,tslib_es6/* __assign */.Cl)({ asyncControl: this.props.asyncControl, autoComplete: "off", id: this.numericInputId, role: this.props.allowNumericCharactersOnly ? "spinbutton" : undefined }, inputGroupHtmlProps, { "aria-valuemax": this.props.max, "aria-valuemin": this.props.min, "aria-valuenow": valueAsNumber, intent: this.state.currentImeInputInvalid ? Intent.DANGER : this.props.intent, inputClassName: this.props.inputClassName, inputRef: this.inputRef, inputSize: this.props.inputSize, 
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            large: this.props.large, leftElement: this.props.leftElement, leftIcon: this.props.leftIcon, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur, onCompositionEnd: this.handleCompositionEnd, onCompositionUpdate: this.handleCompositionUpdate, onKeyDown: this.handleInputKeyDown, 
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            onKeyPress: this.handleInputKeyPress, onPaste: this.handleInputPaste, onValueChange: this.handleInputChange, rightElement: this.props.rightElement, size: this.props.size, 
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            small: this.props.small, value: this.state.value })));
    };
    // Callbacks - Buttons
    // ===================
    NumericInput.prototype.getButtonEventHandlers = function (direction) {
        var _this = this;
        return {
            // keydown is fired repeatedly when held so it's implicitly continuous
            onKeyDown: function (evt) {
                if (!_this.props.disabled && keyboardUtils_isKeyboardClick(evt)) {
                    _this.handleButtonClick(evt, direction);
                }
            },
            onMouseDown: function (evt) {
                if (!_this.props.disabled) {
                    _this.handleButtonClick(evt, direction);
                    _this.startContinuousChange();
                }
            },
        };
    };
    NumericInput.prototype.startContinuousChange = function () {
        var _this = this;
        // The button's onMouseUp event handler doesn't fire if the user
        // releases outside of the button, so we need to watch all the way
        // from the top.
        document.addEventListener("mouseup", this.stopContinuousChange);
        // Initial delay is slightly longer to prevent the user from
        // accidentally triggering the continuous increment/decrement.
        this.setTimeout(function () {
            _this.intervalId = window.setInterval(_this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);
        }, NumericInput.CONTINUOUS_CHANGE_DELAY);
    };
    // Data logic
    // ==========
    NumericInput.prototype.handleNextValue = function (valueAsString) {
        var _a, _b;
        if (this.props.value == null) {
            this.setState({ value: valueAsString });
        }
        (_b = (_a = this.props).onValueChange) === null || _b === void 0 ? void 0 : _b.call(_a, Number(parseStringToStringNumber(valueAsString, this.props.locale)), valueAsString, this.inputElement);
    };
    NumericInput.prototype.incrementValue = function (delta) {
        // pretend we're incrementing from 0 if currValue is empty
        var currValue = this.state.value === NumericInput.VALUE_EMPTY ? NumericInput.VALUE_ZERO : this.state.value;
        var nextValue = this.roundAndClampValue(currValue, delta);
        if (nextValue !== this.state.value) {
            this.handleNextValue(nextValue);
            this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnIncrement });
        }
        // return value used in continuous change updates
        return nextValue;
    };
    NumericInput.prototype.getIncrementDelta = function (direction, isShiftKeyPressed, isAltKeyPressed) {
        var _a = this.props, majorStepSize = _a.majorStepSize, minorStepSize = _a.minorStepSize, stepSize = _a.stepSize;
        if (isShiftKeyPressed && majorStepSize != null) {
            return direction * majorStepSize;
        }
        else if (isAltKeyPressed && minorStepSize != null) {
            return direction * minorStepSize;
        }
        else {
            return direction * stepSize;
        }
    };
    NumericInput.prototype.roundAndClampValue = function (value, delta) {
        if (delta === void 0) { delta = 0; }
        return NumericInput.roundAndClampValue(value, this.state.stepMaxPrecision, this.props.min, this.props.max, delta, this.props.locale);
    };
    NumericInput.prototype.updateDelta = function (direction, e) {
        this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);
        return this.delta;
    };
    NumericInput.displayName = "".concat(DISPLAYNAME_PREFIX, ".NumericInput");
    NumericInput.VALUE_EMPTY = "";
    NumericInput.VALUE_ZERO = "0";
    NumericInput.defaultProps = {
        allowNumericCharactersOnly: true,
        buttonPosition: Position.RIGHT,
        clampValueOnBlur: false,
        defaultValue: NumericInput.VALUE_EMPTY,
        large: false,
        majorStepSize: 10,
        minorStepSize: 0.1,
        selectAllOnFocus: false,
        selectAllOnIncrement: false,
        size: "medium",
        small: false,
        stepSize: 1,
    };
    NumericInput.CONTINUOUS_CHANGE_DELAY = 300;
    NumericInput.CONTINUOUS_CHANGE_INTERVAL = 100;
    return NumericInput;
}(AbstractPureComponent));


;// ./app/components/PageNumInput.js



const PageNumInput_css = {
    label: {
        display: 'inline-block',
    },
};
class PageNumInput extends react.Component {
    render() {
        return react.createElement("div", { hidden: this.props.hidden },
            react.createElement("label", { className: "bp5-label", style: PageNumInput_css.label },
                this.props.label,
                react.createElement(Help, { title: this.props.label, content: this.props.help }),
                react.createElement(NumericInput, { allowNumericCharactersOnly: true, min: this.props.min, minorStepSize: this.props.minorStepSize, max: this.props.max, stepSize: this.props.stepSize, majorStepSize: this.props.majorStepSize, disabled: this.props.disabled, selectAllOnFocus: this.props.selectAllOnFocus, onValueChange: (val) => {
                        if (this.props.max && val > this.props.max) {
                            val = this.props.max;
                        }
                        this.props.onChange(val);
                    }, value: this.props.value })));
    }
}

;// ./app/components/Config.js






const Config_css = {
    message: {
        margin: "0 0 6px 0",
    },
    header: {
        margin: "0 0 5px 0",
    },
    card: {
        position: "relative",
        margin: "8px",
    },
    footer: {
        margin: 0,
    },
};
class ConfigView extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onChange = () => {
            this.setState({
                ...this.state,
                config: stores_ConfigStore.config,
            });
        };
        this.onCancel = () => {
            this.setState({
                ...this.state,
                changed: false,
                config: stores_ConfigStore.config,
            });
        };
        this.onSave = () => {
            this.setState({
                ...this.state,
                disabled: true,
            });
            if (this.state.safeStorage !== null) {
                app_Config.save({
                    safe_storage: this.state.safeStorage,
                });
            }
            if (this.state.config) {
                ConfigActions_commit(this.state.config).then(() => {
                    this.setState({
                        ...this.state,
                        changed: false,
                        disabled: false,
                    });
                });
            }
        };
        this.state = {
            config: stores_ConfigStore.config,
            safeStorage: null,
            changed: false,
            disabled: false,
        };
    }
    componentDidMount() {
        stores_ConfigStore.addChangeListener(this.onChange);
        ConfigActions_sync();
    }
    componentWillUnmount() {
        stores_ConfigStore.removeChangeListener(this.onChange);
    }
    set(name, val) {
        let config;
        config = {
            ...this.state.config,
        };
        config[name] = val;
        this.setState({
            ...this.state,
            changed: true,
            config: config,
        });
    }
    render() {
        let safeStorage = this.state.safeStorage;
        if (safeStorage === null) {
            safeStorage = app_Config.safe_storage;
        }
        return react.createElement("div", { className: "bp5-card layout vertical flex", style: Config_css.card },
            react.createElement("div", { className: "layout horizontal" },
                react.createElement("h3", { style: Config_css.header }, "Advanced Settings")),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageSwitch, { disabled: this.state.disabled, label: "Disable DNS watch", help: "Disable automatic correction of DNS changes if configuration is lost from system network change.", checked: !!this.state.config.disable_dns_watch, onToggle: () => {
                        this.set("disable_dns_watch", !this.state.config.disable_dns_watch);
                    } })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageSwitch, { disabled: this.state.disabled, label: "Enable DNS refresh", help: "Automatically refresh DNS to fix issues with macOS DNS cache.", checked: !!this.state.config.enable_dns_refresh, onToggle: () => {
                        this.set("enable_dns_refresh", !this.state.config.enable_dns_refresh);
                    } })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageSwitch, { disabled: this.state.disabled, label: "Disable WireGuard DNS watch", help: "Disable WireGuard DNS watch on macOS.", checked: !!this.state.config.disable_wg_dns, onToggle: () => {
                        this.set("disable_wg_dns", !this.state.config.disable_wg_dns);
                    } })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageSwitch, { disabled: this.state.disabled, label: "Disable device wake watch", help: "Disable wake watch used for faster reconnections when device is resumed from sleep.", checked: !!this.state.config.disable_wake_watch, onToggle: () => {
                        this.set("disable_wake_watch", !this.state.config.disable_wake_watch);
                    } })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageSwitch, { disabled: this.state.disabled, label: "Disable network clean", help: "Disable Windows VPN interface cleanup on startup.", checked: !!this.state.config.disable_net_clean, onToggle: () => {
                        this.set("disable_net_clean", !this.state.config.disable_net_clean);
                    } })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageSwitch, { disabled: this.state.disabled, label: "Enable safe storage", help: "Enable encryption of profile keys with safe storage. May cause client to become unresponsive or connections to fail.", checked: !!safeStorage, onToggle: () => {
                        this.setState({
                            ...this.state,
                            changed: true,
                            safeStorage: !safeStorage,
                        });
                    } })),
            react.createElement("div", { className: "layout horizontal" },
                react.createElement(PageNumInput, { label: "Interface Metric", help: "Configure the VPN interfaces metric on Windows. Set to 0 to leave interfaces unmodified.", min: 0, max: 9999, stepSize: 1, disabled: this.state.disabled, selectAllOnFocus: true, value: this.state.config.interface_metric, onChange: (val) => {
                        this.set('interface_metric', val);
                    } })),
            react.createElement("div", { className: "layout horizontal flex" }),
            react.createElement("div", { className: "bp5-dialog-footer", style: Config_css.footer },
                react.createElement("div", { className: "bp5-dialog-footer-actions" },
                    react.createElement("button", { className: "bp5-button bp5-intent-danger bp5-icon-cross", type: "button", disabled: this.state.disabled || !this.state.changed, onClick: this.onCancel }, "Cancel"),
                    react.createElement("button", { className: "bp5-button bp5-intent-success bp5-icon-tick", type: "button", disabled: this.state.disabled || !this.state.changed, onClick: this.onSave }, "Save"))));
    }
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/menu/menu.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Menu component.
 *
 * @see https://blueprintjs.com/docs/#core/components/menu
 */
var Menu = function (props) {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    var className = props.className, children = props.children, large = props.large, _a = props.size, size = _a === void 0 ? "medium" : _a, small = props.small, ulRef = props.ulRef, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["className", "children", "large", "size", "small", "ulRef"]);
    return (react.createElement("ul", (0,tslib_es6/* __assign */.Cl)({ role: "menu" }, htmlProps, { className: classnames_default()(className, MENU, sizeClass(size, { large: large, small: small })), ref: ulRef }), children));
};
Menu.displayName = "".concat(DISPLAYNAME_PREFIX, ".Menu");

;// ./node_modules/@blueprintjs/core/lib/esm/components/menu/menuDivider.js
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Menu divider component.
 *
 * @see https://blueprintjs.com/docs/#core/components/menu.menu-divider
 */
var MenuDivider = function (_a) {
    var className = _a.className, title = _a.title, titleId = _a.titleId;
    var dividerClasses = classnames_default()(title ? MENU_HEADER : MENU_DIVIDER, className);
    return (react.createElement("li", { className: dividerClasses, role: "separator" }, title && react.createElement(H6, { id: titleId }, title)));
};
MenuDivider.displayName = "".concat(DISPLAYNAME_PREFIX, ".MenuDivider");

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/components/small-tick.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var SmallTick = react.forwardRef(function (props, ref) {
    var isLarge = props.size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var translation = "".concat(-1 * pixelGridSize / 0.05 / 2);
    var style = { transformOrigin: "center" };
    return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ iconName: "small-tick", ref: ref }, props),
        react.createElement("path", { d: isLarge ? "M300 300C294.4000000000001 300 289.4000000000001 297.8 285.8 294.2L160 168.2L114.2 214.2C110.6 217.8 105.6 220 100 220C89 220 80 211 80 200C80 194.4 82.2 189.4 85.8 185.8L145.8 125.8C149.4 122.2 154.4 120 160 120S170.6 122.2 174.2 125.8L314.2000000000001 265.8C317.8 269.4 320 274.4 320 280C320 291 311 300 300 300z" : "M240 220C234.4 220 229.4 217.8 225.8 214.2L140 128.2L94.2 174.2C90.6 177.8 85.6 180 80 180C69 180 60 171 60 160C60 154.4 62.2 149.4 65.8 145.8L125.8 85.8C129.4 82.2 134.4 80 140 80S150.6 82.2 154.2 85.8L254.2 185.8C257.8 189.4 260 194.4 260 200C260 211 251 220 240 220z", fillRule: "evenodd", transform: "scale(0.05, -0.05) translate(".concat(translation, ", ").concat(translation, ")"), style: style })));
});
SmallTick.defaultProps = {
    size: iconTypes/* IconSize */.l.STANDARD,
};
SmallTick.displayName = "Blueprint5.Icon.SmallTick";
/* harmony default export */ const small_tick = ((/* unused pure expression or super */ null && (SmallTick)));

;// ./node_modules/@blueprintjs/icons/lib/esm/generated/components/caret-right.js
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var CaretRight = react.forwardRef(function (props, ref) {
    var isLarge = props.size >= iconTypes/* IconSize */.l.LARGE;
    var pixelGridSize = isLarge ? iconTypes/* IconSize */.l.LARGE : iconTypes/* IconSize */.l.STANDARD;
    var translation = "".concat(-1 * pixelGridSize / 0.05 / 2);
    var style = { transformOrigin: "center" };
    return (react.createElement(SVGIconContainer, (0,tslib_es6/* __assign */.Cl)({ iconName: "caret-right", ref: ref }, props),
        react.createElement("path", { d: isLarge ? "M280 200C280 206.2 277 211.4 272.6 215.2L272.8 215.4L152.8 315.4L152.6 315.2C149.2 318 144.8 320 140 320C129 320 120 311 120 300V100C120 89 129 80 140 80C144.8 80 149.2 82 152.6 84.8L152.8 84.6L272.8 184.6L272.6 184.8C277 188.6 280 193.8 280 200z" : "M220 160C220 163 218.6 165.6 216.6 167.4L216.6 167.4L136.6 237.4L136.6 237.4C134.8 239 132.6 240 130 240C124.4 240 120 235.6 120 230V90C120 84.4 124.4 80 130 80C132.6 80 134.8 81 136.6 82.6C136.6 82.6 136.6 82.6 136.6 82.6L216.6 152.6L216.6 152.6C218.6 154.4 220 157 220 160z", fillRule: "evenodd", transform: "scale(0.05, -0.05) translate(".concat(translation, ", ").concat(translation, ")"), style: style })));
});
CaretRight.defaultProps = {
    size: iconTypes/* IconSize */.l.STANDARD,
};
CaretRight.displayName = "Blueprint5.Icon.CaretRight";
/* harmony default export */ const caret_right = ((/* unused pure expression or super */ null && (CaretRight)));

;// ./node_modules/react-popper/lib/esm/Manager.js

var ManagerReferenceNodeContext = react.createContext();
var ManagerReferenceNodeSetterContext = react.createContext();
function Manager(_ref) {
  var children = _ref.children;

  var _React$useState = react.useState(null),
      referenceNode = _React$useState[0],
      setReferenceNode = _React$useState[1];

  var hasUnmounted = react.useRef(false);
  react.useEffect(function () {
    return function () {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = react.useCallback(function (node) {
    if (!hasUnmounted.current) {
      setReferenceNode(node);
    }
  }, []);
  return /*#__PURE__*/react.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, /*#__PURE__*/react.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}
// EXTERNAL MODULE: ./node_modules/warning/warning.js
var warning_warning = __webpack_require__(6365);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning_warning);
;// ./node_modules/react-popper/lib/esm/utils.js


/**
 * Takes an argument and if it's an array, returns the first item in the array,
 * otherwise returns the argument. Used for Preact compatibility.
 */
var unwrapArray = function unwrapArray(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
/**
 * Takes a maybe-undefined function and arbitrary args and invokes the function
 * only if it is defined.
 */

var safeInvoke = function safeInvoke(fn) {
  if (typeof fn === 'function') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return fn.apply(void 0, args);
  }
};
/**
 * Sets a ref using either a ref callback or a ref object
 */

var utils_setRef = function setRef(ref, node) {
  // if its a function call it
  if (typeof ref === 'function') {
    return safeInvoke(ref, node);
  } // otherwise we should treat it as a ref object
  else if (ref != null) {
      ref.current = node;
    }
};
/**
 * Simple ponyfill for Object.fromEntries
 */

var fromEntries = function fromEntries(entries) {
  return entries.reduce(function (acc, _ref) {
    var key = _ref[0],
        value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
/**
 * Small wrapper around `useLayoutEffect` to get rid of the warning on SSR envs
 */

var utils_useIsomorphicLayoutEffect = typeof window !== 'undefined' && window.document && window.document.createElement ? react.useLayoutEffect : react.useEffect;
;// ./node_modules/react-popper/lib/esm/Reference.js




function Reference(_ref) {
  var children = _ref.children,
      innerRef = _ref.innerRef;
  var setReferenceNode = react.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = react.useCallback(function (node) {
    utils_setRef(innerRef, node);
    safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]); // ran on unmount
  // eslint-disable-next-line react-hooks/exhaustive-deps

  react.useEffect(function () {
    return function () {
      return utils_setRef(innerRef, null);
    };
  }, []);
  react.useEffect(function () {
    warning_default()(Boolean(setReferenceNode), '`Reference` should not be used outside of a `Manager` component.');
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js


function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}


;// ./node_modules/@popperjs/core/lib/utils/math.js
var math_max = Math.max;
var math_min = Math.min;
var round = Math.round;
;// ./node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js




function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
;// ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js



function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}
;// ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}
;// ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js








function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}
;// ./node_modules/@popperjs/core/lib/enums.js
var enums_top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [enums_top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
;// ./node_modules/@popperjs/core/lib/utils/orderModifiers.js
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
;// ./node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}
;// ./node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
;// ./node_modules/@popperjs/core/lib/createPopper.js









var createPopper_DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? createPopper_DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, createPopper_DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/(/* unused pure expression or super */ null && (popperGenerator())); // eslint-disable-next-line import/no-unused-modules


;// ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const eventListeners = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});
;// ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js

function getBasePlacement(placement) {
  return placement.split('-')[0];
}
;// ./node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split('-')[1];
}
;// ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
;// ./node_modules/@popperjs/core/lib/utils/computeOffsets.js




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case enums_top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}
;// ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_popperOffsets = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});
;// ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = enums_top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === enums_top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_computeStyles = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});
;// ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function applyStyles_effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_applyStyles = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: applyStyles_effect,
  requires: ['computeStyles']
});
;// ./node_modules/@popperjs/core/lib/modifiers/offset.js

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = enums_placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_offset = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});
;// ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
;// ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var getOppositeVariationPlacement_hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return getOppositeVariationPlacement_hash[matched];
  });
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js




function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/contains.js

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}
;// ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js















function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = math_max(rect.top, accRect.top);
    accRect.right = math_min(rect.right, accRect.right);
    accRect.bottom = math_min(rect.bottom, accRect.bottom);
    accRect.left = math_max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
;// ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
;// ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
;// ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
;// ./node_modules/@popperjs/core/lib/utils/detectOverflow.js








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}
;// ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
;// ./node_modules/@popperjs/core/lib/modifiers/flip.js






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_flip = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});
;// ./node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
;// ./node_modules/@popperjs/core/lib/utils/within.js

function within(min, value, max) {
  return math_max(min, math_min(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
;// ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? enums_top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? enums_top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_preventOverflow = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});
;// ./node_modules/@popperjs/core/lib/modifiers/arrow.js








 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? enums_top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function arrow_effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_arrow = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: arrow_effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});
;// ./node_modules/@popperjs/core/lib/modifiers/hide.js



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [enums_top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_hide = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});
;// ./node_modules/@popperjs/core/lib/popper.js










var defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];
var popper_createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules


// EXTERNAL MODULE: ./node_modules/react-fast-compare/index.js
var react_fast_compare = __webpack_require__(2169);
var react_fast_compare_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare);
;// ./node_modules/react-popper/lib/esm/usePopper.js





var EMPTY_MODIFIERS = [];
var usePopper = function usePopper(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }

  var prevOptions = react.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || 'bottom',
    strategy: options.strategy || 'absolute',
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };

  var _React$useState = react.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: '0',
        top: '0'
      },
      arrow: {
        position: 'absolute'
      }
    },
    attributes: {}
  }),
      state = _React$useState[0],
      setState = _React$useState[1];

  var updateStateModifier = react.useMemo(function () {
    return {
      name: 'updateState',
      enabled: true,
      phase: 'write',
      fn: function fn(_ref) {
        var state = _ref.state;
        var elements = Object.keys(state.elements);
        react_dom.flushSync(function () {
          setState({
            styles: fromEntries(elements.map(function (element) {
              return [element, state.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function (element) {
              return [element, state.attributes[element]];
            }))
          });
        });
      },
      requires: ['computeStyles']
    };
  }, []);
  var popperOptions = react.useMemo(function () {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: 'applyStyles',
        enabled: false
      }])
    };

    if (react_fast_compare_default()(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = react.useRef();
  utils_useIsomorphicLayoutEffect(function () {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  utils_useIsomorphicLayoutEffect(function () {
    if (referenceElement == null || popperElement == null) {
      return;
    }

    var createPopper = options.createPopper || popper_createPopper;
    var popperInstance = createPopper(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function () {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
;// ./node_modules/react-popper/lib/esm/Popper.js





var NOOP = function NOOP() {
  return void 0;
};

var NOOP_PROMISE = function NOOP_PROMISE() {
  return Promise.resolve(null);
};

var Popper_EMPTY_MODIFIERS = [];
function Popper(_ref) {
  var _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? 'bottom' : _ref$placement,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === void 0 ? 'absolute' : _ref$strategy,
      _ref$modifiers = _ref.modifiers,
      modifiers = _ref$modifiers === void 0 ? Popper_EMPTY_MODIFIERS : _ref$modifiers,
      referenceElement = _ref.referenceElement,
      onFirstUpdate = _ref.onFirstUpdate,
      innerRef = _ref.innerRef,
      children = _ref.children;
  var referenceNode = react.useContext(ManagerReferenceNodeContext);

  var _React$useState = react.useState(null),
      popperElement = _React$useState[0],
      setPopperElement = _React$useState[1];

  var _React$useState2 = react.useState(null),
      arrowElement = _React$useState2[0],
      setArrowElement = _React$useState2[1];

  react.useEffect(function () {
    utils_setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = react.useMemo(function () {
    return {
      placement: placement,
      strategy: strategy,
      onFirstUpdate: onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: 'arrow',
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);

  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options),
      state = _usePopper.state,
      styles = _usePopper.styles,
      forceUpdate = _usePopper.forceUpdate,
      update = _usePopper.update;

  var childrenProps = react.useMemo(function () {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
;// ./node_modules/@blueprintjs/core/lib/esm/components/resize-sensor/resizeSensor.js
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Resize sensor component.
 *
 * It requires a single DOM element child and will error otherwise.
 *
 * @see https://blueprintjs.com/docs/#core/components/resize-sensor
 **/
var ResizeSensor = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(ResizeSensor, _super);
    function ResizeSensor() {
        var _a;
        var _this = _super.apply(this, arguments) || this;
        _this.targetRef = (_a = _this.props.targetRef) !== null && _a !== void 0 ? _a : react.createRef();
        _this.prevElement = undefined;
        return _this;
    }
    ResizeSensor.prototype.render = function () {
        var onlyChild = react.Children.only(this.props.children);
        // If we're provided a mutable ref to the child element already, we must re-use that one. This is necessary
        // in cases where the child node is not a native DOM element and does not use `React.forwardRef`, since
        // there's no way for us to know how to attach to the underlying DOM node.
        if (this.props.targetRef !== undefined) {
            return onlyChild;
        }
        return react.cloneElement(onlyChild, { ref: this.targetRef });
    };
    ResizeSensor.prototype.componentDidMount = function () {
        var _this = this;
        // ResizeObserver is available in all modern browsers supported by Blueprint but not in server-side rendering
        // and some test environments like jsdom, so we to do a feature check here.
        this.observer =
            globalThis.ResizeObserver != null
                ? new ResizeObserver(function (entries) { var _a, _b; return (_b = (_a = _this.props).onResize) === null || _b === void 0 ? void 0 : _b.call(_a, entries); })
                : undefined;
        this.observeElement();
    };
    ResizeSensor.prototype.componentDidUpdate = function (prevProps) {
        this.observeElement(this.props.observeParents !== prevProps.observeParents);
    };
    ResizeSensor.prototype.componentWillUnmount = function () {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        this.prevElement = undefined;
    };
    /**
     * Observe the DOM element, if defined and different from the currently
     * observed element. Pass `force` argument to skip element checks and always
     * re-observe.
     */
    ResizeSensor.prototype.observeElement = function (force) {
        if (force === void 0) { force = false; }
        if (this.observer === undefined) {
            return;
        }
        if (!(this.targetRef.current instanceof Element)) {
            // stop everything if not defined
            this.observer.disconnect();
            return;
        }
        if (this.targetRef.current === this.prevElement && !force) {
            // quit if given same element -- nothing to update (unless forced)
            return;
        }
        else {
            // clear observer list if new element
            this.observer.disconnect();
            // remember element reference for next time
            this.prevElement = this.targetRef.current;
        }
        // observer callback is invoked immediately when observing new elements
        this.observer.observe(this.targetRef.current);
        if (this.props.observeParents) {
            var parent_1 = this.targetRef.current.parentElement;
            while (parent_1 != null) {
                this.observer.observe(parent_1);
                parent_1 = parent_1.parentElement;
            }
        }
    };
    ResizeSensor.displayName = "".concat(DISPLAYNAME_PREFIX, ".ResizeSensor");
    return ResizeSensor;
}(AbstractPureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/popperUtils.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Popper placement utils
// ======================
/** Converts a full placement to one of the four positions by stripping text after the `-`. */
function popperUtils_getBasePlacement(placement) {
    return placement.split("-")[0];
}
/** Returns true if position is left or right. */
function isVerticalPlacement(side) {
    return ["left", "right"].indexOf(side) !== -1;
}
/** Returns the opposite position. */
function popperUtils_getOppositePlacement(side) {
    switch (side) {
        case "top":
            return "bottom";
        case "left":
            return "right";
        case "bottom":
            return "top";
        default:
            return "left";
    }
}
/** Returns the CSS alignment keyword corresponding to given placement. */
function getAlignment(placement) {
    var align = placement.split("-")[1];
    switch (align) {
        case "start":
            return "left";
        case "end":
            return "right";
        default:
            return "center";
    }
}
// Popper modifiers
// ================
/** Modifier helper function to compute popper transform-origin based on arrow position */
function getTransformOrigin(placement, arrowStyles) {
    var basePlacement = popperUtils_getBasePlacement(placement);
    if (arrowStyles === undefined) {
        return isVerticalPlacement(basePlacement)
            ? "".concat(popperUtils_getOppositePlacement(basePlacement), " ").concat(getAlignment(basePlacement))
            : "".concat(getAlignment(basePlacement), " ").concat(popperUtils_getOppositePlacement(basePlacement));
    }
    else {
        // const arrowSizeShift = state.elements.arrow.clientHeight / 2;
        var arrowSizeShift = 30 / 2;
        // can use keyword for dimension without the arrow, to ease computation burden.
        // move origin by half arrow's height to keep it centered.
        return isVerticalPlacement(basePlacement)
            ? "".concat(popperUtils_getOppositePlacement(basePlacement), " ").concat(parseInt(arrowStyles.top, 10) + arrowSizeShift, "px")
            : "".concat(parseInt(arrowStyles.left, 10) + arrowSizeShift, "px ").concat(popperUtils_getOppositePlacement(basePlacement));
    }
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/popoverArrow.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// these paths come from the Core Kit Sketch file
// https://github.com/palantir/blueprint/blob/develop/resources/sketch/Core%20Kit.sketch
var SVG_SHADOW_PATH = "M8.11 6.302c1.015-.936 1.887-2.922 1.887-4.297v26c0-1.378" +
    "-.868-3.357-1.888-4.297L.925 17.09c-1.237-1.14-1.233-3.034 0-4.17L8.11 6.302z";
var SVG_ARROW_PATH = "M8.787 7.036c1.22-1.125 2.21-3.376 2.21-5.03V0v30-2.005" +
    "c0-1.654-.983-3.9-2.21-5.03l-7.183-6.616c-.81-.746-.802-1.96 0-2.7l7.183-6.614z";
// additional space between arrow and edge of target
var ARROW_SPACING = 4;
var POPOVER_ARROW_SVG_SIZE = 30;
var TOOLTIP_ARROW_SVG_SIZE = 22;
/* istanbul ignore next */
/** Modifier helper function to compute arrow rotate() transform */
function getArrowAngle(placement) {
    if (placement == null) {
        return 0;
    }
    // can only be top/left/bottom/right - auto is resolved internally
    switch (popperUtils_getBasePlacement(placement)) {
        case "top":
            return -90;
        case "left":
            return 180;
        case "bottom":
            return 90;
        default:
            return 0;
    }
}
/* istanbul ignore next */
/**
 * Popper's builtin "arrow" modifier options.padding doesn't seem to work for us, so we
 * need to compute our own offset in the direction of the popover relative to the reference.
 */
function getArrowReferenceOffsetStyle(placement) {
    var offset = POPOVER_ARROW_SVG_SIZE / 2 - ARROW_SPACING;
    switch (popperUtils_getBasePlacement(placement)) {
        case "top":
            return { bottom: -offset };
        case "left":
            return { right: -offset };
        case "bottom":
            return { top: -offset };
        default:
            return { left: -offset };
    }
}
var PopoverArrow = function (_a) {
    var _b = _a.arrowProps, ref = _b.ref, style = _b.style, placement = _a.placement;
    return (
    // data attribute allows popper.js to position the arrow
    react.createElement("div", { "aria-hidden": true, className: POPOVER_ARROW, "data-popper-arrow": true, ref: ref, style: (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, style), getArrowReferenceOffsetStyle(placement)) },
        react.createElement("svg", { viewBox: "0 0 ".concat(POPOVER_ARROW_SVG_SIZE, " ").concat(POPOVER_ARROW_SVG_SIZE), style: { transform: "rotate(".concat(getArrowAngle(placement), "deg)") } },
            react.createElement("path", { className: POPOVER_ARROW + "-border", d: SVG_SHADOW_PATH }),
            react.createElement("path", { className: POPOVER_ARROW + "-fill", d: SVG_ARROW_PATH }))));
};
PopoverArrow.displayName = "".concat(DISPLAYNAME_PREFIX, ".PopoverArrow");

;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/tooltipContext.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var noOpDispatch = function () { return null; };
var TooltipContext = react.createContext([
    {},
    noOpDispatch,
]);
var tooltipContextReducer = function (state, action) {
    switch (action.type) {
        case "FORCE_DISABLED_STATE":
            return { forceDisabled: true };
        case "RESET_DISABLED_STATE":
            return {};
        default:
            return state;
    }
};
var TooltipProvider = function (_a) {
    var children = _a.children, forceDisable = _a.forceDisable;
    var _b = react.useReducer(tooltipContextReducer, {}), state = _b[0], dispatch = _b[1];
    var contextValue = react.useMemo(function () { return [state, dispatch]; }, [state, dispatch]);
    react.useEffect(function () {
        if (forceDisable) {
            dispatch({ type: "FORCE_DISABLED_STATE" });
        }
        else {
            dispatch({ type: "RESET_DISABLED_STATE" });
        }
    }, [forceDisable]);
    return (react.createElement(TooltipContext.Provider, { value: contextValue }, typeof children === "function" ? children(state) : children));
};

;// ./node_modules/@blueprintjs/core/lib/esm/components/tooltip/tooltip.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// eslint-disable-next-line import/no-cycle



/**
 * Tooltip component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tooltip
 */
var Tooltip = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(Tooltip, _super);
    function Tooltip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.popoverRef = react.createRef();
        // any descendant ContextMenus may update this ctxState
        _this.renderPopover = function (ctxState) {
            var _a;
            var _b;
            var _c = _this.props, children = _c.children, compact = _c.compact, disabled = _c.disabled, intent = _c.intent, popoverClassName = _c.popoverClassName, restProps = (0,tslib_es6/* __rest */.Tt)(_c, ["children", "compact", "disabled", "intent", "popoverClassName"]);
            var popoverClasses = classnames_default()(TOOLTIP, classes_intentClass(intent), popoverClassName, (_a = {},
                _a[COMPACT] = compact,
                _a));
            return (react.createElement(Popover, (0,tslib_es6/* __assign */.Cl)({ modifiers: {
                    arrow: {
                        enabled: !_this.props.minimal,
                    },
                    offset: {
                        options: {
                            offset: [0, TOOLTIP_ARROW_SVG_SIZE / 2],
                        },
                    },
                } }, restProps, { autoFocus: false, canEscapeKeyClose: false, disabled: (_b = ctxState.forceDisabled) !== null && _b !== void 0 ? _b : disabled, enforceFocus: false, lazy: true, popoverClassName: popoverClasses, portalContainer: _this.props.portalContainer, ref: _this.popoverRef }), children));
        };
        return _this;
    }
    Tooltip.prototype.render = function () {
        var _this = this;
        // if we have an ancestor TooltipContext, we should take its state into account in this render path,
        // it was likely created by a parent ContextMenu
        return (react.createElement(TooltipContext.Consumer, null, function (_a) {
            var state = _a[0];
            return react.createElement(TooltipProvider, (0,tslib_es6/* __assign */.Cl)({}, state), _this.renderPopover);
        }));
    };
    Tooltip.prototype.reposition = function () {
        var _a;
        (_a = this.popoverRef.current) === null || _a === void 0 ? void 0 : _a.reposition();
    };
    Tooltip.displayName = "".concat(DISPLAYNAME_PREFIX, ".Tooltip");
    Tooltip.defaultProps = {
        compact: false,
        hoverCloseDelay: 0,
        hoverOpenDelay: 100,
        interactionKind: "hover-target",
        minimal: false,
        transitionDuration: 100,
    };
    return Tooltip;
}(AbstractPureComponent));


;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/customModifiers.js
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable sort-keys */
// adapted from https://popper.js.org/docs/v2/modifiers/community-modifiers/
var matchReferenceWidthModifier = {
    enabled: true,
    name: "matchReferenceWidth",
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: function (_a) {
        var state = _a.state;
        state.styles.popper.width = "".concat(state.rects.reference.width, "px");
    },
    effect: function (_a) {
        var state = _a.state;
        var referenceWidth = state.elements.reference.getBoundingClientRect().width;
        state.elements.popper.style.width = "".concat(referenceWidth, "px");
    },
};

;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/popoverPosition.js
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var PopoverPosition = (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, Position), { AUTO: "auto", AUTO_END: "auto-end", AUTO_START: "auto-start" });

;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/popoverPlacementUtils.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert a position to a placement.
 *
 * @param position the position to convert
 */
function positionToPlacement(position) {
    /* istanbul ignore next */
    switch (position) {
        case PopoverPosition.TOP_LEFT:
            return "top-start";
        case PopoverPosition.TOP:
            return "top";
        case PopoverPosition.TOP_RIGHT:
            return "top-end";
        case PopoverPosition.RIGHT_TOP:
            return "right-start";
        case PopoverPosition.RIGHT:
            return "right";
        case PopoverPosition.RIGHT_BOTTOM:
            return "right-end";
        case PopoverPosition.BOTTOM_RIGHT:
            return "bottom-end";
        case PopoverPosition.BOTTOM:
            return "bottom";
        case PopoverPosition.BOTTOM_LEFT:
            return "bottom-start";
        case PopoverPosition.LEFT_BOTTOM:
            return "left-end";
        case PopoverPosition.LEFT:
            return "left";
        case PopoverPosition.LEFT_TOP:
            return "left-start";
        case "auto":
        case "auto-start":
        case "auto-end":
            // Return the string unchanged.
            return position;
        default:
            return assertNever(position);
    }
}
/* istanbul ignore next */
function assertNever(x) {
    throw new Error("Unexpected position: " + x);
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/popover/popover.js
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








// eslint-disable-next-line import/no-cycle





var PopoverInteractionKind = {
    CLICK: "click",
    CLICK_TARGET_ONLY: "click-target",
    HOVER: "hover",
    HOVER_TARGET_ONLY: "hover-target",
};
/**
 * Popover component, used to display a floating UI next to and tethered to a target element.
 *
 * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML
 * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for
 * this type param).
 * @see https://blueprintjs.com/docs/#core/components/popover
 */
var Popover = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.C6)(Popover, _super);
    function Popover() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            hasDarkParent: false,
            isClosingViaEscapeKeypress: false,
            isOpen: _this.getIsOpen(_this.props),
        };
        /**
         * DOM element that contains the popover.
         * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,
         * so this reference can be very useful for testing.
         *
         * @public for testing
         */
        _this.popoverElement = null;
        /** Popover ref handler */
        _this.popoverRef = refHandler(_this, "popoverElement", _this.props.popoverRef);
        /**
         * Target DOM element ref.
         *
         * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target
         * DOM element in order to observe its dimensions.
         *
         * @public for testing
         */
        _this.targetRef = react.createRef();
        /**
         * Overlay2 transition container element ref.
         */
        _this.transitionContainerElement = react.createRef();
        // a flag that lets us detect mouse movement between the target and popover,
        // now that mouseleave is triggered when you cross the gap between the two.
        _this.isMouseInTargetOrPopover = false;
        // a flag that indicates whether the target previously lost focus to another
        // element on the same page.
        _this.lostFocusOnSamePage = true;
        _this.isControlled = function () { return _this.props.isOpen !== undefined; };
        // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled
        _this.isArrowEnabled = function () { var _a, _b; return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false; };
        _this.isHoverInteractionKind = function () {
            return (_this.props.interactionKind === PopoverInteractionKind.HOVER ||
                _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY);
        };
        /**
         * Instance method to instruct the `Popover` to recompute its position.
         *
         * This method should only be used if you are updating the target in a way
         * that does not cause it to re-render, such as changing its _position_
         * without changing its _size_ (since `Popover` already repositions when it
         * detects a resize).
         */
        _this.reposition = function () { var _a; return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this); };
        _this.renderTarget = function (_a) {
            var _b, _c;
            var _d, _e;
            var popperChildRef = _a.ref;
            var _f = _this.props, children = _f.children, className = _f.className, disabled = _f.disabled, fill = _f.fill, openOnTargetFocus = _f.openOnTargetFocus, renderTarget = _f.renderTarget;
            var isOpen = _this.state.isOpen;
            var isControlled = _this.isControlled();
            var isHoverInteractionKind = _this.isHoverInteractionKind();
            var targetTagName = _this.props.targetTagName;
            if (fill) {
                targetTagName = "div";
            }
            // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,
            // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17
            var ref = mergeRefs(popperChildRef, _this.targetRef);
            var targetEventHandlers = isHoverInteractionKind
                ? {
                    // HOVER handlers
                    onBlur: _this.handleTargetBlur,
                    onContextMenu: _this.handleTargetContextMenu,
                    onFocus: _this.handleTargetFocus,
                    onMouseEnter: _this.handleMouseEnter,
                    onMouseLeave: _this.handleMouseLeave,
                }
                : {
                    // CLICK needs only one handler
                    onClick: _this.handleTargetClick,
                    // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE
                    onKeyDown: _this.handleKeyDown,
                };
            // Ensure target is focusable if relevant prop enabled
            var targetTabIndex = !_this.getIsContentEmpty() && !disabled && openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;
            var ownTargetProps = (0,tslib_es6/* __assign */.Cl)({ 
                // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.
                // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is
                // applied to the generated target wrapper element.
                className: classnames_default()(className, POPOVER_TARGET, (_b = {},
                    _b[POPOVER_OPEN] = isOpen,
                    // this class is mainly useful for button targets
                    _b[ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,
                    _b)), ref: ref }, targetEventHandlers);
            var childTargetProps = {
                "aria-expanded": isHoverInteractionKind ? undefined : isOpen,
                "aria-haspopup": _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY
                    ? undefined
                    : (_d = _this.props.popupKind) !== null && _d !== void 0 ? _d : "menu",
            };
            var targetModifierClasses = (_c = {},
                // this class is mainly useful for Blueprint <Button> targets; we should only apply it for
                // uncontrolled popovers when they are opened by a user interaction
                _c[ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,
                // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.
                _c[FILL] = fill,
                _c);
            var target;
            if (renderTarget !== undefined) {
                target = renderTarget((0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, ownTargetProps), childTargetProps), { className: classnames_default()(ownTargetProps.className, targetModifierClasses), 
                    // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip
                    // when *this* popover is open
                    isOpen: isOpen, tabIndex: targetTabIndex }));
            }
            else {
                var childTarget = ensureElement(react.Children.toArray(children)[0]);
                if (childTarget === undefined) {
                    return null;
                }
                var clonedTarget = react.cloneElement(childTarget, (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, childTargetProps), { className: classnames_default()(childTarget.props.className, targetModifierClasses), 
                    // force disable single Tooltip child when popover is open
                    disabled: isOpen && isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled, tabIndex: (_e = childTarget.props.tabIndex) !== null && _e !== void 0 ? _e : targetTabIndex }));
                var wrappedTarget = react.createElement(targetTagName, (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({}, ownTargetProps), _this.props.targetProps), clonedTarget);
                target = wrappedTarget;
            }
            // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can
            // notify both popper.js and our components about the mounted DOM element.
            return (react.createElement(ResizeSensor, { targetRef: _this.targetRef, onResize: _this.reposition }, target));
        };
        _this.renderPopover = function (popperProps) {
            var _a;
            var _b = _this.props, autoFocus = _b.autoFocus, enforceFocus = _b.enforceFocus, backdropProps = _b.backdropProps, canEscapeKeyClose = _b.canEscapeKeyClose, hasBackdrop = _b.hasBackdrop, interactionKind = _b.interactionKind, usePortal = _b.usePortal;
            var _c = _this.state, isClosingViaEscapeKeypress = _c.isClosingViaEscapeKeypress, isOpen = _c.isOpen;
            // compute an appropriate transform origin so the scale animation points towards target
            var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);
            // need to update our reference to this function on every render as it will change.
            _this.popperScheduleUpdate = popperProps.update;
            var popoverHandlers = {
                // always check popover clicks for dismiss class
                onClick: _this.handlePopoverClick,
                // treat ENTER/SPACE keys the same as a click for accessibility
                onKeyDown: function (event) { return keyboardUtils_isKeyboardClick(event) && _this.handlePopoverClick(event); },
            };
            if (interactionKind === PopoverInteractionKind.HOVER ||
                (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)) {
                popoverHandlers.onMouseEnter = _this.handleMouseEnter;
                popoverHandlers.onMouseLeave = _this.handleMouseLeave;
            }
            var basePlacement = popperUtils_getBasePlacement(popperProps.placement);
            var popoverClasses = classnames_default()(POPOVER, (_a = {},
                _a[DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent,
                _a[MINIMAL] = _this.props.minimal,
                _a[POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss,
                _a[POPOVER_MATCH_TARGET_WIDTH] = _this.props.matchTargetWidth,
                _a[POPOVER_REFERENCE_HIDDEN] = popperProps.isReferenceHidden === true,
                _a[POPOVER_POPPER_ESCAPED] = popperProps.hasPopperEscaped === true,
                _a), "".concat(POPOVER_CONTENT_PLACEMENT, "-").concat(basePlacement), _this.props.popoverClassName);
            var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;
            // if hover interaction, it doesn't make sense to take over focus control
            var shouldReturnFocusOnClose = _this.isHoverInteractionKind()
                ? false
                : isClosingViaEscapeKeypress
                    ? true
                    : _this.props.shouldReturnFocusOnClose;
            return (react.createElement(Overlay2, { autoFocus: autoFocus !== null && autoFocus !== void 0 ? autoFocus : defaultAutoFocus, backdropClassName: POPOVER_BACKDROP, backdropProps: backdropProps, canEscapeKeyClose: canEscapeKeyClose, canOutsideClickClose: interactionKind === PopoverInteractionKind.CLICK, childRef: _this.transitionContainerElement, enforceFocus: enforceFocus, hasBackdrop: hasBackdrop, isOpen: isOpen, lazy: _this.props.lazy, onClose: _this.handleOverlayClose, onClosed: _this.props.onClosed, onClosing: _this.props.onClosing, onOpened: _this.props.onOpened, onOpening: _this.props.onOpening, transitionDuration: _this.props.transitionDuration, transitionName: POPOVER, usePortal: usePortal, portalClassName: _this.props.portalClassName, portalContainer: _this.props.portalContainer, 
                // eslint-disable-next-line @typescript-eslint/no-deprecated
                portalStopPropagationEvents: _this.props.portalStopPropagationEvents, shouldReturnFocusOnClose: shouldReturnFocusOnClose },
                react.createElement("div", { className: POPOVER_TRANSITION_CONTAINER, 
                    // We need to attach a ref that notifies both react-popper and our Popover component about the DOM
                    // element inside the Overlay2. We cannot re-use `PopperChildrenProps.ref` because Overlay2 only
                    // accepts a ref object (not a callback) due to a CSSTransition API limitation.
                    // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,
                    // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Popper.js#L94
                    ref: mergeRefs(popperProps.ref, _this.transitionContainerElement), style: popperProps.style },
                    react.createElement(ResizeSensor, { onResize: _this.reposition },
                        react.createElement("div", (0,tslib_es6/* __assign */.Cl)({ className: popoverClasses, style: { transformOrigin: transformOrigin }, ref: _this.popoverRef }, popoverHandlers),
                            _this.isArrowEnabled() && (react.createElement(PopoverArrow, { arrowProps: popperProps.arrowProps, placement: popperProps.placement })),
                            react.createElement("div", { className: POPOVER_CONTENT }, _this.props.content))))));
        };
        _this.handleTargetFocus = function (e) {
            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {
                if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {
                    // ignore this focus event -- the target was already focused but the page itself
                    // lost focus (e.g. due to switching tabs).
                    return;
                }
                _this.handleMouseEnter(e);
            }
        };
        _this.handleTargetBlur = function (e) {
            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {
                if (e.relatedTarget != null) {
                    // if the next element to receive focus is within the popover, we'll want to leave the
                    // popover open.
                    if (e.relatedTarget !== _this.popoverElement &&
                        !_this.isElementInPopover(e.relatedTarget)) {
                        _this.handleMouseLeave(e);
                    }
                }
                else {
                    _this.handleMouseLeave(e);
                }
            }
            _this.lostFocusOnSamePage = e.relatedTarget != null;
        };
        _this.handleTargetContextMenu = function (e) {
            // we assume that when someone prevents the default interaction on this event (a browser native context menu),
            // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip
            if (e.defaultPrevented) {
                _this.setOpenState(false, e);
            }
        };
        _this.handleMouseEnter = function (e) {
            _this.isMouseInTargetOrPopover = true;
            // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually
            // trigger the mouse leave event, as hovering over the popover shouldn't count.
            if (!_this.props.usePortal &&
                _this.isElementInPopover(e.target) &&
                _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&
                !_this.props.openOnTargetFocus) {
                _this.handleMouseLeave(e);
            }
            else if (!_this.props.disabled) {
                // only begin opening popover when it is enabled
                _this.setOpenState(true, e, _this.props.hoverOpenDelay);
            }
        };
        _this.handleMouseLeave = function (e) {
            _this.isMouseInTargetOrPopover = false;
            // Wait until the event queue is flushed, because we want to leave the
            // popover open if the mouse entered the popover immediately after
            // leaving the target (or vice versa). Make sure to persist the event since
            // we need to access `nativeEvent` in `this.setOpenState()`.
            e.persist();
            _this.setTimeout(function () {
                if (_this.isMouseInTargetOrPopover) {
                    return;
                }
                // user-configurable closing delay is helpful when moving mouse from target to popover
                _this.setOpenState(false, e, _this.props.hoverCloseDelay);
            });
        };
        _this.handlePopoverClick = function (e) {
            var _a, _b, _c;
            var eventTarget = e.target;
            var eventPopover = eventTarget.closest(".".concat(POPOVER));
            var eventPopoverV1 = eventTarget.closest(".".concat(POPOVER));
            var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();
            var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(POPOVER_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false;
            // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.
            var dismissElement = eventTarget.closest(".".concat(POPOVER_DISMISS, ", .").concat(POPOVER_DISMISS_OVERRIDE));
            var shouldDismiss = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(POPOVER_DISMISS)) !== null && _c !== void 0 ? _c : false;
            var isDisabled = eventTarget.closest(":disabled, .".concat(DISABLED)) != null;
            if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {
                _this.setOpenState(false, e);
            }
        };
        _this.handleOverlayClose = function (e) {
            var _a;
            if (_this.targetRef.current == null || e === undefined) {
                return;
            }
            var event = ((_a = e.nativeEvent) !== null && _a !== void 0 ? _a : e);
            var eventTarget = (event.composed ? event.composedPath()[0] : event.target);
            // if click was in target, target event listener will handle things, so don't close
            if (!elementIsOrContains(_this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {
                _this.setOpenState(false, e);
            }
        };
        _this.handleKeyDown = function (e) {
            var isKeyboardClick = keyboardUtils_isKeyboardClick(e);
            // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE
            if (isKeyboardClick) {
                _this.handleTargetClick(e);
            }
        };
        _this.handleTargetClick = function (e) {
            // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore
            // see: https://github.com/palantir/blueprint/issues/5775
            var shouldIgnoreClick = _this.state.isOpen && _this.isSimulatedButtonClick(e);
            if (!shouldIgnoreClick) {
                // ensure click did not originate from within inline popover before closing
                if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {
                    if (_this.props.isOpen == null) {
                        _this.setState(function (prevState) { return ({ isOpen: !prevState.isOpen }); });
                    }
                    else {
                        _this.setOpenState(!_this.props.isOpen, e);
                    }
                }
            }
        };
        _this.isSimulatedButtonClick = function (e) {
            return !e.isTrusted && e.target.matches(".".concat(BUTTON));
        };
        return _this;
    }
    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,
    // so if we want to look at our actual popover element, we need to reach inside a bit
    Popover.prototype.getPopoverElement = function () {
        var _a;
        return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(".".concat(POPOVER));
    };
    Popover.prototype.getIsOpen = function (props) {
        var _a;
        // disabled popovers should never be allowed to open.
        if (props.disabled) {
            return false;
        }
        else {
            return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;
        }
    };
    Popover.prototype.render = function () {
        var _a = this.props, disabled = _a.disabled, placement = _a.placement, _b = _a.position, position = _b === void 0 ? "auto" : _b, positioningStrategy = _a.positioningStrategy;
        var isOpen = this.state.isOpen;
        if (this.getIsContentEmpty()) {
            // need to do this check in render(), because `isOpen` is derived from
            // state, and state can't necessarily be accessed in validateProps.
            if (!disabled && isOpen !== false && !isNodeEnv("production")) {
                console.warn(POPOVER_WARN_EMPTY_CONTENT);
            }
            // just render the target without a content overlay if there is no content to display
            return this.renderTarget({ ref: popover_noop });
        }
        // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode
        // see https://github.com/floating-ui/react-popper/pull/459
        return (react.createElement(Manager, null,
            react.createElement(Reference, null, this.renderTarget),
            react.createElement(Popper, { innerRef: this.popoverRef, placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position), strategy: positioningStrategy, modifiers: this.getPopperModifiers() }, this.renderPopover)));
    };
    Popover.prototype.componentDidMount = function () {
        this.updateDarkParent();
    };
    Popover.prototype.componentDidUpdate = function (props, state) {
        _super.prototype.componentDidUpdate.call(this, props, state);
        this.updateDarkParent();
        var nextIsOpen = this.getIsOpen(this.props);
        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {
            this.setOpenState(nextIsOpen);
            // tricky: setOpenState calls setState only if this.props.isOpen is
            // not controlled, so we need to invoke setState manually here.
            this.setState({ isOpen: nextIsOpen });
        }
        else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {
            // special case: close an uncontrolled popover when disabled is set to true
            this.setOpenState(false);
        }
    };
    Popover.prototype.validateProps = function (props) {
        if (props.isOpen == null && props.onInteraction != null) {
            console.warn(POPOVER_WARN_UNCONTROLLED_ONINTERACTION);
        }
        if (props.hasBackdrop && !props.usePortal) {
            console.warn(POPOVER_WARN_HAS_BACKDROP_INLINE);
        }
        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {
            console.warn(POPOVER_HAS_BACKDROP_INTERACTION);
        }
        if (props.placement !== undefined && props.position !== undefined) {
            console.warn(POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);
        }
        var childrenCount = react.Children.count(props.children);
        var hasRenderTargetProp = props.renderTarget !== undefined;
        var hasTargetPropsProp = props.targetProps !== undefined;
        if (childrenCount === 0 && !hasRenderTargetProp) {
            console.warn(POPOVER_REQUIRES_TARGET);
        }
        if (childrenCount > 1) {
            console.warn(POPOVER_WARN_TOO_MANY_CHILDREN);
        }
        if (childrenCount > 0 && hasRenderTargetProp) {
            console.warn(POPOVER_WARN_DOUBLE_TARGET);
        }
        if (hasRenderTargetProp && hasTargetPropsProp) {
            console.warn(POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);
        }
    };
    Popover.prototype.getPopperModifiers = function () {
        var _a, _b, _c, _d;
        var _e = this.props, matchTargetWidth = _e.matchTargetWidth, modifiers = _e.modifiers, modifiersCustom = _e.modifiersCustom;
        var popperModifiers = [
            (0,tslib_es6/* __assign */.Cl)({ enabled: this.isArrowEnabled(), name: "arrow" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow),
            (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ name: "computeStyles" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), { options: (0,tslib_es6/* __assign */.Cl)({ adaptive: true, 
                    // We disable the built-in gpuAcceleration so that
                    // Popper.js will return us easy to interpolate values
                    // (top, left instead of transform: translate3d)
                    // We'll then use these values to generate the needed
                    // css transform values blended with the react-spring values
                    gpuAcceleration: false }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options) }),
            (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ enabled: this.isArrowEnabled(), name: "offset" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), { options: (0,tslib_es6/* __assign */.Cl)({ offset: [0, POPOVER_ARROW_SVG_SIZE / 2] }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options) }),
            (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ name: "flip" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), { options: (0,tslib_es6/* __assign */.Cl)({ boundary: this.props.boundary, rootBoundary: this.props.rootBoundary }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options) }),
            (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ name: "preventOverflow" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), { options: (0,tslib_es6/* __assign */.Cl)({ boundary: this.props.boundary, rootBoundary: this.props.rootBoundary }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options) }),
        ];
        if (matchTargetWidth) {
            popperModifiers.push(matchReferenceWidthModifier);
        }
        if (modifiersCustom !== undefined) {
            popperModifiers.push.apply(popperModifiers, modifiersCustom);
        }
        return popperModifiers;
    };
    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.
    // starts a timeout to delay changing the state if a non-zero duration is provided.
    Popover.prototype.setOpenState = function (isOpen, e, timeout) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        // cancel any existing timeout because we have new state
        (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);
        if (timeout !== undefined && timeout > 0) {
            // Persist the react event since it will be used in a later macrotask.
            e === null || e === void 0 ? void 0 : e.persist();
            this.cancelOpenTimeout = this.setTimeout(function () {
                _this.setOpenState(isOpen, e);
            }, timeout);
        }
        else {
            if (this.props.isOpen == null) {
                this.setState({ isOpen: isOpen });
            }
            else {
                (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);
            }
            if (!isOpen) {
                // non-null assertion because the only time `e` is undefined is when in controlled mode
                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true
                (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);
                this.setState({ isClosingViaEscapeKeypress: isEscapeKeypressEvent(e === null || e === void 0 ? void 0 : e.nativeEvent) });
            }
        }
    };
    Popover.prototype.updateDarkParent = function () {
        var _a;
        if (this.props.usePortal && this.state.isOpen) {
            var hasDarkParent = ((_a = this.targetRef.current) === null || _a === void 0 ? void 0 : _a.closest(".".concat(DARK))) != null;
            this.setState({ hasDarkParent: hasDarkParent });
        }
    };
    Popover.prototype.isElementInPopover = function (element) {
        var _a, _b;
        return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;
    };
    Popover.prototype.getIsContentEmpty = function () {
        var content = this.props.content;
        return content == null || isEmptyString(content);
    };
    Popover.displayName = "".concat(DISPLAYNAME_PREFIX, ".Popover");
    Popover.defaultProps = {
        boundary: "clippingParents",
        captureDismiss: false,
        defaultIsOpen: false,
        disabled: false,
        fill: false,
        hasBackdrop: false,
        hoverCloseDelay: 300,
        hoverOpenDelay: 150,
        inheritDarkTheme: true,
        interactionKind: PopoverInteractionKind.CLICK,
        matchTargetWidth: false,
        minimal: false,
        openOnTargetFocus: true,
        // N.B. we don't set a default for `placement` or `position` here because that would trigger
        // a warning in validateProps if the other prop is specified by a user of this component
        positioningStrategy: "absolute",
        renderTarget: undefined,
        shouldReturnFocusOnClose: false,
        targetTagName: "span",
        transitionDuration: 300,
        usePortal: true,
    };
    return Popover;
}(AbstractPureComponent));

function isEscapeKeypressEvent(e) {
    return e instanceof KeyboardEvent && e.key === "Escape";
}
function popover_noop() {
    // no-op
}

;// ./node_modules/@blueprintjs/core/lib/esm/components/menu/menuItem.js
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Menu item component.
 *
 * @see https://blueprintjs.com/docs/#core/components/menu.menu-item
 */
var MenuItem = react.forwardRef(function (props, ref) {
    var _a, _b;
    var _c = props.active, active = _c === void 0 ? false : _c, className = props.className, children = props.children, _d = props.disabled, disabled = _d === void 0 ? false : _d, icon = props.icon, intent = props.intent, labelClassName = props.labelClassName, labelElement = props.labelElement, _e = props.multiline, multiline = _e === void 0 ? false : _e, _f = props.popoverProps, popoverProps = _f === void 0 ? {} : _f, _g = props.roleStructure, roleStructure = _g === void 0 ? "menuitem" : _g, selected = props.selected, _h = props.shouldDismissPopover, shouldDismissPopover = _h === void 0 ? true : _h, submenuProps = props.submenuProps, _j = props.text, text = _j === void 0 ? "" : _j, textClassName = props.textClassName, _k = props.tagName, tagName = _k === void 0 ? "a" : _k, htmlTitle = props.htmlTitle, htmlProps = (0,tslib_es6/* __rest */.Tt)(props, ["active", "className", "children", "disabled", "icon", "intent", "labelClassName", "labelElement", "multiline", "popoverProps", "roleStructure", "selected", "shouldDismissPopover", "submenuProps", "text", "textClassName", "tagName", "htmlTitle"]);
    var _l = roleStructure === "listoption" // "listoption": parent has listbox role, or is a <select>
        ? [
            "option",
            undefined, // target should have no role
            Boolean(selected), // aria-selected prop
        ]
        : roleStructure === "menuitem" // "menuitem": parent has menu role
            ? [
                "none",
                "menuitem",
                undefined, // don't set aria-selected prop
            ]
            : roleStructure === "none" // "none": allows wrapping MenuItem in custom <li>
                ? [
                    "none",
                    undefined, // target should have no role
                    undefined, // don't set aria-selected prop
                ]
                : // roleStructure === "listitem"
                    [
                        undefined, // needs no role prop, li is listitem by default
                        undefined,
                        undefined, // don't set aria-selected prop
                    ], liRole = _l[0], targetRole = _l[1], ariaSelected = _l[2];
    var isSelectable = roleStructure === "listoption";
    var isSelected = isSelectable && selected;
    var hasIcon = icon != null;
    var hasSubmenu = children != null;
    var intentClass = classes_intentClass(intent);
    var anchorClasses = classnames_default()(MENU_ITEM, intentClass, (_a = {},
        _a[ACTIVE] = active,
        _a[DISABLED] = disabled,
        // prevent popover from closing when clicking on submenu trigger or disabled item
        _a[POPOVER_DISMISS] = shouldDismissPopover && !disabled && !hasSubmenu,
        _a[MENU_ITEM_IS_SELECTABLE] = isSelectable,
        _a[SELECTED] = isSelected,
        _a), className);
    var maybeLabel = props.label == null && labelElement == null ? null : (react.createElement("span", { className: classnames_default()(MENU_ITEM_LABEL, labelClassName) },
        props.label,
        labelElement));
    var target = react.createElement(tagName, (0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)((0,tslib_es6/* __assign */.Cl)({ 
        // for menuitems, onClick when enter key pressed doesn't take effect like it does for a button-- fix this
        onKeyDown: clickElementOnKeyPress(["Enter", " "]), 
        // if hasSubmenu, must apply correct role and tabIndex to the outer popover target <span> instead of this target element
        role: hasSubmenu ? "none" : targetRole, tabIndex: hasSubmenu ? -1 : 0 }, removeNonHTMLProps(htmlProps)), (disabled ? DISABLED_PROPS : {})), { className: anchorClasses }), isSelected ? react.createElement(SmallTick, { className: MENU_ITEM_SELECTED_ICON }) : undefined, hasIcon ? (
    // wrap icon in a <span> in case `icon` is a custom element rather than a built-in icon identifier,
    // so that we always render this class
    react.createElement("span", { className: MENU_ITEM_ICON },
        react.createElement(Icon, { icon: icon, "aria-hidden": true, tabIndex: -1 }))) : undefined, react.createElement(Text, { className: classnames_default()(FILL, textClassName), ellipsize: !multiline, title: htmlTitle }, text), maybeLabel, hasSubmenu ? react.createElement(CaretRight, { className: MENU_SUBMENU_ICON, title: "Open sub menu" }) : undefined);
    var liClasses = classnames_default()((_b = {}, _b[MENU_SUBMENU] = hasSubmenu, _b));
    return (react.createElement("li", { className: liClasses, ref: ref, role: liRole, "aria-selected": ariaSelected }, children == null ? (target) : (react.createElement(Popover, (0,tslib_es6/* __assign */.Cl)({ autoFocus: false, captureDismiss: false, disabled: disabled, enforceFocus: false, hoverCloseDelay: 0, interactionKind: "hover", modifiers: SUBMENU_POPOVER_MODIFIERS, targetProps: { role: targetRole, tabIndex: 0 }, placement: "right-start", usePortal: false }, popoverProps, { content: react.createElement(Menu, (0,tslib_es6/* __assign */.Cl)({}, submenuProps), children), minimal: true, popoverClassName: classnames_default()(MENU_SUBMENU, popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.popoverClassName) }), target))));
});
MenuItem.displayName = "".concat(DISPLAYNAME_PREFIX, ".MenuItem");
var SUBMENU_POPOVER_MODIFIERS = {
    // 20px padding - scrollbar width + a bit
    flip: { enabled: true, options: { padding: 20, rootBoundary: "viewport" } },
    // shift popover up 5px so MenuItems align
    offset: { enabled: true, options: { offset: [-5, 0] } },
    preventOverflow: { enabled: true, options: { padding: 20, rootBoundary: "viewport" } },
};
// props to ignore when disabled
var DISABLED_PROPS = {
    "aria-disabled": true,
    href: undefined,
    onClick: undefined,
    onMouseDown: undefined,
    onMouseEnter: undefined,
    onMouseLeave: undefined,
    tabIndex: -1,
};

;// ./app/components/Main.js















let upgradeShown = false;
const Main_css = {
    card: {
        minWidth: '310px',
        maxWidth: '380px',
        width: 'calc(100% - 20px)',
        margin: '60px auto',
    },
    nav: {
        overflowX: 'auto',
        overflowY: 'auto',
        userSelect: 'none',
        height: 'auto',
        padding: '0 4px 0 8px',
    },
    navTitle: {
        flexWrap: 'wrap',
        height: 'auto',
    },
    navGroup: {
        flexWrap: 'wrap',
        height: 'auto',
        padding: '4px 0',
    },
    link: {
        padding: '0 7px',
    },
    sub: {
        color: 'inherit',
    },
    heading: {
        fontFamily: "'Fredoka One', cursive",
        marginRight: '11px',
        fontSize: '26px',
    },
    loading: {
        position: 'absolute',
        width: '100%',
        zIndex: '100',
    },
    container: {
        height: '100%',
    },
    content: {
        overflowY: 'auto',
    },
    menuLabel: {
        fontSize: '15px',
        textAlign: 'center',
    },
    updateButton: {
        marginTop: "7px",
    },
};
class Main extends react.Component {
    constructor(props, context) {
        super(props, context);
        this.onChange = () => {
            this.setState({
                ...this.state,
            });
        };
        this.onRefresh = () => {
            let pathname = "";
            this.setState({
                ...this.state,
                disabled: true,
            });
            if (pathname === '/profiles') {
                sync().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                }).catch(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                });
            }
            else if (pathname === '/logs') {
                sync().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                }).catch(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                });
            }
            else if (pathname === '/config') {
                ConfigActions_sync().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                }).catch(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                });
            }
            else {
                sync().then(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                }).catch(() => {
                    this.setState({
                        ...this.state,
                        disabled: false,
                    });
                });
            }
        };
        this.onTrayIcon = async () => {
            app_Config.disable_tray_icon = !app_Config.disable_tray_icon;
            await app_Config.save({
                disable_tray_icon: app_Config.disable_tray_icon,
            });
            if (app_Config.disable_tray_icon) {
                success("Tray icon disabled, restart client " +
                    "for configuration to take effect");
            }
            else {
                success("Tray icon enabled, restart client " +
                    "for configuration to take effect");
            }
        };
        this.onWindowFrame = async () => {
            app_Config.frameless = !app_Config.frameless;
            await app_Config.save({
                frameless: app_Config.frameless,
            });
            if (app_Config.frameless) {
                success("Window frame disabled, restart client " +
                    "for configuration to take effect");
            }
            else {
                success("Window frame enabled, restart client " +
                    "for configuration to take effect");
            }
        };
        this.onAlert = (toasts) => {
            if (!toasts) {
                document.getElementById("toaster2").style.display = "none";
            }
            this.setState({
                ...this.state,
                showErrors: !!toasts,
            });
        };
        this.state = {
            path: "/",
            disabled: false,
            menu: false,
            showErrors: false,
        };
    }
    componentDidMount() {
        Constants_addChangeListener(this.onChange);
        addChangeListener(this.onAlert);
    }
    componentWillUnmount() {
        Constants_removeChangeListener(this.onChange);
        removeChangeListener(this.onAlert);
    }
    render() {
        if (state.upgrade && !upgradeShown) {
            upgradeShown = true;
            if (state.security) {
                let updateElm = react.createElement("div", null,
                    react.createElement("div", null,
                        react.createElement("b", null, "Important security update available, download the latest release below")),
                    react.createElement("button", { className: "bp5-button bp5-intent-primary bp5-icon-download", type: "button", style: Main_css.updateButton, onClick: () => {
                            external_electron_namespaceObject.ipcRenderer.send("control", "download-update");
                        } }, "Download Update"));
                error(updateElm, 0);
            }
            else {
                let updateElm = react.createElement("div", null,
                    react.createElement("div", null, "Update available, download the latest release below"),
                    react.createElement("button", { className: "bp5-button bp5-intent-primary bp5-icon-download", type: "button", style: Main_css.updateButton, onClick: () => {
                            external_electron_namespaceObject.ipcRenderer.send("control", "download-update");
                        } }, "Download Update"));
                info(updateElm, 0);
            }
        }
        let themeLabel = "";
        let themeIcon;
        if (theme === "dark") {
            themeLabel = "Light Theme";
            themeIcon = "flash";
        }
        else {
            themeLabel = "Dark Theme";
            themeIcon = "moon";
        }
        let themeVerLabel = "";
        let themeVerIcon;
        if (themeVer === 3) {
            themeVerLabel = "Square Theme";
            themeVerIcon = "style";
        }
        else {
            themeVerLabel = "Round Theme";
            themeVerIcon = "style";
        }
        let trayLabel = "";
        if (app_Config.disable_tray_icon) {
            trayLabel = "Enable Tray Icon";
        }
        else {
            trayLabel = "Disable Tray Icon";
        }
        let frameLabel = "";
        if (app_Config.frameless) {
            frameLabel = "Enable Window Frame";
        }
        else {
            frameLabel = "Disable Window Frame";
        }
        let profilesHidden = false;
        let page;
        switch (this.state.path) {
            case "/":
                profilesHidden = true;
                page = react.createElement(Profiles, null);
                break;
            case "/profiles":
                profilesHidden = true;
                page = react.createElement(Profiles, null);
                break;
            case "/logs":
                page = react.createElement(Logs, null);
                break;
            case "/config":
                page = react.createElement(ConfigView, null);
                break;
        }
        let version = state.version;
        if (state.version) {
            version = " v" + state.version;
        }
        let menu = react.createElement(Menu, null,
            react.createElement("li", { className: "bp5-menu-header" },
                react.createElement("h6", { className: "bp5-heading", style: Main_css.menuLabel }, "Pritunl Client" + version)),
            react.createElement(MenuDivider, null),
            react.createElement(MenuItem, { text: themeLabel, icon: themeIcon, onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        toggle();
                        save();
                    }
                }, onClick: () => {
                    toggle();
                    save();
                } }),
            react.createElement(MenuItem, { text: themeVerLabel, icon: themeVerIcon, onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        toggleVer();
                        save();
                    }
                }, onClick: () => {
                    toggleVer();
                    save();
                } }),
            react.createElement(MenuItem, { text: "Refresh", icon: "refresh", hidden: true, disabled: this.state.disabled, onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        this.onRefresh();
                    }
                }, onClick: this.onRefresh }),
            react.createElement(MenuItem, { text: trayLabel, icon: "dashboard", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        this.onTrayIcon();
                    }
                }, onClick: this.onTrayIcon }),
            react.createElement(MenuItem, { text: frameLabel, icon: "application", hidden: platform === "win32", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        this.onWindowFrame();
                    }
                }, onClick: this.onWindowFrame }),
            react.createElement(MenuItem, { text: "View Logs", icon: "history", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        this.setState({
                            ...this.state,
                            path: "/logs",
                        });
                    }
                }, onClick: () => {
                    this.setState({
                        ...this.state,
                        path: "/logs",
                    });
                } }),
            react.createElement(MenuItem, { text: "Reload App", icon: "refresh", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        external_electron_namespaceObject.ipcRenderer.send("control", "reload");
                    }
                }, onClick: () => {
                    external_electron_namespaceObject.ipcRenderer.send("control", "reload");
                } }),
            react.createElement(MenuItem, { text: "Advanced Settings", icon: "cog", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        this.setState({
                            ...this.state,
                            path: "/config",
                        });
                    }
                }, onClick: () => {
                    this.setState({
                        ...this.state,
                        path: "/config",
                    });
                } }),
            react.createElement(MenuItem, { text: "Reset DNS", intent: "warning", icon: "search", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        resetDns(false);
                    }
                }, onClick: () => {
                    resetDns(false);
                } }),
            react.createElement(MenuItem, { text: "Reset Networking", intent: "warning", icon: "globe-network", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        resetAll(false);
                    }
                }, onClick: () => {
                    resetAll(false);
                } }),
            react.createElement(MenuItem, { text: "Reset Secure Enclave Key", intent: "danger", icon: "globe-network", hidden: platform !== "darwin", onKeyDown: (evt) => {
                    if (evt.key === "Enter") {
                        resetEnclave(false);
                    }
                }, onClick: () => {
                    resetEnclave(false);
                } }),
            react.createElement(MenuItem, { text: "Developer Tools", intent: "warning", icon: "code", onClick: () => {
                    external_electron_namespaceObject.ipcRenderer.send("control", "dev-tools");
                } }));
        return react.createElement("div", { style: Main_css.container, className: "layout vertical" },
            react.createElement(LoadingBar, { intent: "primary", style: Main_css.loading }),
            react.createElement("nav", { className: "bp5-navbar layout horizontal", style: Main_css.nav },
                react.createElement("div", { className: "bp5-navbar-group bp5-align-left flex webkit-drag", style: Main_css.navTitle },
                    react.createElement("div", { className: "bp5-navbar-heading", style: Main_css.heading }, "pritunl")),
                react.createElement("div", { className: "bp5-navbar-group bp5-align-right", style: Main_css.navGroup },
                    react.createElement("button", { className: "bp5-button bp5-minimal bp5-intent-danger bp5-icon-error", style: Main_css.link, hidden: !this.state.showErrors, onClick: () => {
                            let elmnt = document.getElementById("toaster2");
                            if (elmnt.style.display === "block") {
                                elmnt.style.display = "none";
                            }
                            else {
                                elmnt.style.display = "block";
                            }
                        } }),
                    react.createElement("button", { className: "bp5-button bp5-minimal bp5-icon-people", style: Main_css.link, hidden: profilesHidden, onClick: () => {
                            this.setState({
                                ...this.state,
                                path: "/profiles",
                            });
                        } }, "Profiles"),
                    react.createElement(ProfileImport, { style: Main_css.link }),
                    react.createElement("button", { className: "bp5-button bp5-minimal bp5-icon-history", hidden: true, style: Main_css.link, onClick: () => {
                            this.setState({
                                ...this.state,
                                path: "/logs",
                            });
                        } }, "Logs"),
                    react.createElement("div", null,
                        react.createElement(Popover, { interactionKind: "click", popoverClassName: "main-menu", placement: Position.BOTTOM, content: menu, defaultIsOpen: false, renderTarget: ({ isOpen, ...targetProps }) => (react.createElement(Button, { ...targetProps, minimal: true, icon: "menu" })), usePortal: true, minimal: true })),
                    react.createElement("button", { className: "bp5-button bp5-minimal bp5-icon-minus", type: "button", hidden: !frameless, onClick: () => {
                            external_electron_namespaceObject.ipcRenderer.send("control", "minimize");
                        } }),
                    react.createElement("button", { className: "bp5-button bp5-minimal bp5-icon-cross close-button", type: "button", hidden: !frameless, onClick: () => {
                            window.close();
                        } }))),
            react.createElement("div", { className: "layout vertical flex", style: Main_css.content }, page));
    }
}

;// ./app/Event.js





let connectionLost = false;
let registered = false;
function Event_init() {
    if (registered) {
        return;
    }
    registered = true;
    external_electron_namespaceObject.ipcRenderer.on("event.reconnected", () => {
        connectionLost = false;
        success("Events: Service connection restored");
        clearAlert2();
    });
    external_electron_namespaceObject.ipcRenderer.on("event.closed", (evt, errStr) => {
        if (!connectionLost) {
            connectionLost = true;
            error("Events: Service connection lost");
        }
    });
    external_electron_namespaceObject.ipcRenderer.on("event.error", (evt, errStr) => {
        let err = new Error(errStr);
        err = new RequestError(err, "Failed to connect to background service, retrying");
        errorAlert2(err, 3);
    });
    external_electron_namespaceObject.ipcRenderer.on("event", (evt, dataStr) => {
        let data = JSON.parse(dataStr);
        dispatcher_EventDispatcher.dispatch(data);
    });
}

;// ./app/App.js













let sourceMap;
let sourceMapPath = window.source_map;
let unerrCount = 0;
let unrejCount = 0;
window.onerror = (event, source, line, col, err) => {
    unerrCount += 1;
    if (unerrCount == 100) {
        errorAlert("Main: Ending unhandled error infinite loop");
        return;
    }
    else if (unerrCount > 100) {
        return;
    }
    err = new UnknownError(err, "Main: Unhandled exception", {
        event: event,
        source: source,
        line: line,
        column: col,
    });
    errorAlert(err, 0);
};
window.onunhandledrejection = (event) => {
    unrejCount += 1;
    if (unrejCount == 100) {
        errorAlert("Main: Ending unhandled rejection infinite loop");
        return;
    }
    else if (unrejCount > 100) {
        return;
    }
    let message = "";
    let stack = "";
    try {
        message = event.reason.message;
    }
    catch {
        message = event.reason;
    }
    try {
        stack = event.reason.stack;
    }
    catch {
    }
    try {
        if (stack && sourceMap) {
            let stackLines = stack.split("\n");
            new source_map.SourceMapConsumer(sourceMap).then((consumer) => {
                try {
                    let newStack = "";
                    for (let line of stackLines) {
                        let lines = line.split(":");
                        if (lines.length < 3) {
                            newStack += line + "\n";
                            continue;
                        }
                        let lineNum = parseInt(lines[lines.length - 2], 10);
                        let colNum = parseInt(lines[lines.length - 1], 10);
                        let position = consumer.originalPositionFor({
                            line: lineNum,
                            column: colNum,
                        });
                        let source = position.source.replace("webpack://pritunl/app/", "");
                        if (position.name) {
                            newStack += "  " + position.name + " (" + source +
                                ":" + position.line + ":" + position.column + ")\n";
                        }
                        else {
                            newStack += "  " + source + ":" +
                                position.line + ":" + position.column + "\n";
                        }
                    }
                    let err = new UnhandledError(null, "Main: Unhandled rejection", message, newStack);
                    errorAlert(err, 0);
                }
                catch {
                    let err = new UnhandledError(null, "Main: Unhandled rejection", message, stack);
                    errorAlert(err, 0);
                }
            }, () => {
                let err = new UnhandledError(null, "Main: Unhandled rejection", message, stack);
                errorAlert(err, 0);
            });
            return;
        }
    }
    catch {
    }
    let err = new UnhandledError(null, "Main: Unhandled rejection", message, stack);
    errorAlert(err, 0);
};
try {
    let sourceMapReq = new XMLHttpRequest();
    sourceMapReq.open("GET", sourceMapPath);
    sourceMapReq.onreadystatechange = () => {
        if (sourceMapReq.readyState === 4) {
            sourceMap = JSON.parse(sourceMapReq.responseText);
        }
    };
    sourceMapReq.send();
}
catch (err) {
    err = new ReadError(err, "Main: Failed to load source map", {
        path: sourceMapPath,
    });
    Logger_error(err);
}
try {
    source_map.SourceMapConsumer.initialize({
        "lib/mappings.wasm": "static/mappings.wasm"
    });
}
catch (err) {
    err = new ReadError(err, "Main: Failed to initialize source map", {
        path: sourceMapPath,
    });
    Logger_error(err);
}
FocusStyleManager.onlyShowFocusOnTabs();
init();
app_Config.load().then(() => {
    if (app_Config.theme) {
        let themeParts = app_Config.theme.split("-");
        if (themeParts[1] === "5") {
            themeVer5();
        }
        else {
            themeVer3();
        }
        if (themeParts[0] === "light") {
            light();
        }
        else {
            dark();
        }
    }
    else {
        dark();
    }
    if (app_Config.editor_theme) {
        setEditorTheme(app_Config.editor_theme);
    }
    app_Constants_load();
    load().then(() => {
        Event_init();
        react_dom.render(react.createElement("div", null,
            react.createElement(Main, null)), document.getElementById("app"));
    });
});

})();

/******/ })()
;
//# sourceMappingURL=app.js.map